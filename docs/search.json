[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Packages (2e)",
    "section": "",
    "text": "Welcome!\n欢迎使用 Hadley Wickham 和 Jennifer Bryan 编写的 R packages。Packages 是可重现的 R 代码的基本单元。它们包括可重用的 R functions、描述如何使用它们的 documentation 以及示例数据。在本书中，您将学习如何将代码转换成其他人可以轻松下载和使用的 packages。写一个 package 一开始似乎让人不知所措。因此，从基础开始，并随着时间的推移进行改进。如果您的第一个版本不完美，只要下一个版本更好就没关系。\n这是本书第二版的在线版本。"
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-evolution",
    "href": "lifecycle.html#sec-lifecycle-evolution",
    "title": "21  Lifecycle",
    "section": "\n21.1 Package evolution",
    "text": "21.1 Package evolution\nFirst we should establish a working definition of what it means for your package to change. Technically, you could say that the package has changed every time any file in its source changes. This level of pedantry isn’t terribly useful, though. The smallest increment of change that’s meaningful is probably a Git commit. This represents a specific state of the source package that can be talked about, installed from, compared to, subjected to R CMD check, reverted to, and so on. This level of granularity is really only of interest to developers. But the package states accessible via the Git history are genuinely useful for the maintainer, so if you needed any encouragement to be more intentional with your commits, let this be it.\nThe primary signal of meaningful change is to increment the package version number and release it, for some definition of release, such as releasing on CRAN (Chapter 22). Recall that this important piece of metadata lives in the Version field of the DESCRIPTION file:\nPackage: usethis\nTitle: Automate Package and Project Setup\nVersion: 2.1.6\n...\nIf you visit the CRAN landing page for usethis, you can access its history via Downloads > Old sources > usethis archive. That links to a folder of package bundles (Section 3.3), reflecting usethis’s source for each version released on CRAN, presented in Table 21.1:\n\n#> Warning: package 'tidyverse' was built under R version 4.2.3\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n#> Warning: package 'tibble' was built under R version 4.2.3\n#> Warning: package 'tidyr' was built under R version 4.2.3\n#> Warning: package 'readr' was built under R version 4.2.3\n#> Warning: package 'purrr' was built under R version 4.2.3\n#> Warning: package 'dplyr' was built under R version 4.2.3\n#> Warning: package 'stringr' was built under R version 4.2.2\n#> Warning: package 'forcats' was built under R version 4.2.3\n#> Warning: package 'lubridate' was built under R version 4.2.3\n#> Warning: package 'pkgsearch' was built under R version 4.2.3\n\n\n\nTable 21.1: Releases of the usethis package.\n\nVersion\nDate\n\n\n\n1.0.0\n2017-10-22 17:36:29 UTC\n\n\n1.1.0\n2017-11-17 22:52:07 UTC\n\n\n1.2.0\n2018-01-19 18:23:54 UTC\n\n\n1.3.0\n2018-02-24 21:53:51 UTC\n\n\n1.4.0\n2018-08-14 12:10:02 UTC\n\n\n1.5.0\n2019-04-07 10:50:44 UTC\n\n\n1.5.1\n2019-07-04 11:00:05 UTC\n\n\n1.6.0\n2020-04-09 04:50:02 UTC\n\n\n1.6.1\n2020-04-29 05:50:02 UTC\n\n\n1.6.3\n2020-09-17 17:00:03 UTC\n\n\n2.0.0\n2020-12-10 09:00:02 UTC\n\n\n2.0.1\n2021-02-10 10:40:06 UTC\n\n\n2.1.0\n2021-10-16 23:30:02 UTC\n\n\n2.1.2\n2021-10-25 07:30:02 UTC\n\n\n2.1.3\n2021-10-27 15:00:02 UTC\n\n\n2.1.5\n2021-12-09 23:00:02 UTC\n\n\n2.1.6\n2022-05-25 20:50:02 UTC\n\n\n2.2.0\n2023-06-06 09:30:02 UTC\n\n\n\n\n\n\nThis is the type of package evolution we’re going to address in this chapter. In Section 21.2, we’ll delve into the world of software version numbers, which is a richer topic than you might expect. R also has some specific rules and tools around package version numbers. Finally, we’ll explain the conventions we use for the version numbers of tidyverse packages (Section 21.3).\nBut first, this is a good time to revisit a resource we first pointed out in Section 3.2, when introducing the different states of an R package. Recall that the (unofficial) cran organization on GitHub provides a read-only history of all CRAN packages. For example, you can get a different view of usethis’s released versions at https://github.com/cran/usethis/.\nThe archive provided by CRAN itself allows you to download older versions of usethis as .tar.gz files, which is useful if you truly want to get your hands on the source of an older version. However, if you just want to quickly check something about a version or compare two versions of usethis, the read-only GitHub mirror is much more useful. Each commit in this repo’s history represents a CRAN release, which makes it easy to see exactly what changed: https://github.com/cran/usethis/commits/HEAD. Furthermore, you can browse the state of all the package’s source files at any specific version, such as usethis’s initial release at version 1.0.01.\nThis information is technically available from the repository where usethis is actually developed (https://github.com/r-lib/usethis). But you have to work much harder to zoom out to the level of CRAN releases, amid the clutter of the small incremental steps in which development actually unfolds. These three different views of usethis’s evolution are all useful for different purposes:\n\nhttps://cran.r-project.org/src/contrib/Archive/usethis/: the official CRAN package bundles.\nhttps://github.com/cran/usethis/commits/HEAD: the unofficial read-only CRAN mirror, obtained by unpacking CRAN’s bundles.\nhttps://github.com/r-lib/usethis/commits/HEAD: the official development home for usethis."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number",
    "href": "lifecycle.html#sec-lifecycle-version-number",
    "title": "21  Lifecycle",
    "section": "\n21.2 Package version number",
    "text": "21.2 Package version number\nFormally, an R package version is a sequence of at least two integers separated by either . or -. For example, 1.0 and 0.9.1-10 are valid versions, but 1 and 1.0-devel are not. Base R offers the utils::package_version()2 function to parse a package version string into a proper S3 class by the same name. This class makes it easier to do things like compare versions.\n\npackage_version(c(\"1.0\", \"0.9.1-10\"))\n#> [1] '1.0'      '0.9.1.10'\nclass(package_version(\"1.0\"))\n#> [1] \"package_version\" \"numeric_version\"\n\n# these versions are not allowed for an R package\npackage_version(\"1\")\n#> Error: invalid version specification '1'\npackage_version(\"1.0-devel\")\n#> Error: invalid version specification '1.0-devel'\n\n# comparing package versions\npackage_version(\"1.9\") == package_version(\"1.9.0\")\n#> [1] TRUE\npackage_version(\"1.9\") < package_version(\"1.9.2\")\n#> [1] TRUE\npackage_version(c(\"1.9\", \"1.9.2\")) < package_version(\"1.10\")\n#> [1] TRUE TRUE\n\nThe last examples above make it clear that R considers version 1.9 to be equal to 1.9.0 and to be less than 1.9.2. And both 1.9 and 1.9.2 are less than 1.10, which you should think of as version “one point ten”, not “one point one zero”.\nIf you’re skeptical that the package_version class is really necessary, check out this example:\n\n\"2.0\" > \"10.0\"\n#> [1] TRUE\npackage_version(\"2.0\") > package_version(\"10.0\")\n#> [1] FALSE\n\nThe string 2.0 is considered to be greater than the string 10.0, because the character 2 comes after the character 1. By parsing version strings into proper package_version objects, we get the correct comparison, i.e. that version 2.0 is less than version 10.0.\nR offers this support for working with package versions, because it’s necessary, for example, to determine whether package dependencies are satisfied (Section 9.6.1). Under-the-hood, this tooling is used to enforce minimum versions recorded like this in DESCRIPTION:\nImports:\n    dplyr (>= 1.0.0),\n    tidyr (>= 1.1.0)\nIn your own code, if you need to determine which version of a package is installed, use utils::packageVersion()3:\n\npackageVersion(\"usethis\")\n#> [1] '2.2.0'\nstr(packageVersion(\"usethis\"))\n#> Classes 'package_version', 'numeric_version'  hidden list of 1\n#>  $ : int [1:3] 2 2 0\n\npackageVersion(\"usethis\") > package_version(\"10.0\")\n#> [1] FALSE\npackageVersion(\"usethis\") > \"10.0\"\n#> [1] FALSE\n\nThe return value of packageVersion() has the package_version class and is therefore ready for comparison to other version numbers. Note the last example where we seem to be comparing a version number to a string. How can we get the correct result without explicitly converting 10.0 to a package version? It turns out this conversion is automatic as long as one of the comparators has the package_version class."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "href": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "title": "21  Lifecycle",
    "section": "\n21.3 Tidyverse package version conventions",
    "text": "21.3 Tidyverse package version conventions\nR considers 0.9.1-10 to be a valid package version, but you’ll never see a version number like that for a tidyverse package. Here is our recommended framework for managing the package version number:\n\nAlways use . as the separator, never -.\nA released version number consists of three numbers, <major>.<minor>.<patch>. For version number 1.9.2, 1 is the major number, 9 is the minor number, and 2 is the patch number. Never use versions like 1.0. Always spell out the three components, 1.0.0.\n\nAn in-development package has a fourth component: the development version. This should start at 9000. The number 9000 is arbitrary, but provides a clear signal that there’s something different about this version number. There are two reasons for this practice: First, the presence of a fourth component makes it easy to tell if you’re dealing with a released or in-development version. Also, the use of the fourth place means that you’re not limited to what the next released version will be. 0.0.1, 0.1.0, and 1.0.0 are all greater than 0.0.0.9000.\nIncrement the development version, e.g. from 9000 to 9001, if you’ve added an important feature and you (or others) need to be able to detect or require the presence of this feature. For example, this can happen when two packages are developing in tandem. This is generally the only reason that we bother to increment the development version. This makes in-development versions special and, in some sense, degenerate. Since we don’t increment the development component with each Git commit, the same package version number is associated with many different states of the package source, in between releases.\n\n\nThe advice above is inspired in part by Semantic Versioning and by the X.Org versioning schemes. Read them if you’d like to understand more about the standards of versioning used by many open source projects. But we should underscore that our practices are inspired by these schemes and are somewhat less regimented. Finally, know that other maintainers follow different philosophies on how to manage the package version number."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "title": "21  Lifecycle",
    "section": "\n21.4 Backward compatibility and breaking change",
    "text": "21.4 Backward compatibility and breaking change\nThe version number of your package is always increasing, but it’s more than just an incrementing counter – the way the number changes with each release can convey information about the nature of the changes. The transition from 0.3.1 to 0.3.2, which is a patch release, has a very different vibe from the transition from 0.3.2 to 1.0.0, which is a major release. A package version number can also convey information about where the package is in its lifecycle. For example, the version 1.0.0 often signals that the public interface of a package is considered stable.\nHow do you decide which type of release to make, i.e. which component(s) of the version should you increment? A key concept is whether the associated changes are backward compatible, meaning that pre-existing code will still “work” with the new version. We put “work” in quotes, because this designation is open to a certain amount of interpretation. A hardliner might take this to mean “the code works in exactly the same way, in all contexts, for all inputs”. A more pragmatic interpretation is that “the code still works, but could produce a different result in some edge cases”. A change that is not backward compatible is often described as a breaking change. Here we’re going to talk about how to assess whether a change is breaking. In Section 21.6 we’ll talk about how to decide if a breaking change is worth it.\nIn practice, backward compatibility is not a clear-cut distinction. It is typical to assess the impact of a change from a few angles:\n\nDegree of change in behaviour. The most extreme is to make something that used to be possible into an error, i.e. impossible.\nHow the changes fit into the design of the package. A change to low-level infrastructure, such as a utility that gets called in all user-facing functions, is more fraught than a change that only affects one parameter of a single function.\nHow much existing usage is affected. This is a combination of how many of your users will perceive the change and how many existing users there are to begin with.\n\nHere are some concrete examples of breaking change:\n\nRemoving a function\nRemoving an argument\nNarrowing the set of valid inputs to a function\n\nConversely, these are usually not considered breaking:\n\nAdding a function. Caveat: there’s a small chance this could introduce a conflict in user code.\nAdding an argument. Caveat: this could be breaking for some usage, e.g. if a user is relying on position-based argument matching. This also requires some care in a function that accepts ….\nIncreasing the set of valid inputs.\nChanging the text of a print method or error. Caveat: This can be breaking if other packages depend on yours in fragile ways, such as building logic or a test that relies on an error message from your package.\nFixing a bug. Caveat: It really can happen that users write code that “depends” on a bug. Sometimes such code was flawed from the beginning, but the problem went undetected until you fixed your bug. Other times this surfaces code that uses your package in an unexpected way, i.e. it’s not necessarily wrong, but neither is it right.\n\nIf reasoning about code was a reliable way to assess how it will work in real life, the world wouldn’t have so much buggy software. The best way to gauge the consequences of a change in your package is to try it and see what happens. In addition to running your own tests, you can also run the tests of your reverse dependencies and see if your proposed change breaks anything. The tidyverse team has a fairly extensive set of tools for running so-called reverse dependency checks (Section 22.5), where we run R CMD check on all the packages that depend on ours. Sometimes we use this infrastructure to study the impact of a potential change, i.e. reverse dependency checks can be used to guide development, not only as a last-minute, pre-release check. This leads to yet another, deeply pragmatic definition of a breaking change:\n\nA change is breaking if it causes a CRAN package that was previously passing R CMD check to now fail AND the package’s original usage and behavior is correct.\n\nThis is obviously a narrow and incomplete definition of breaking change, but at least it’s relatively easy to get solid data.\nHopefully we’ve made the point that backward compatibility is not always a clearcut distinction. But hopefully we’ve also provided plenty of concrete criteria to consider when thinking about whether a change could break someone else’s code."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-release-type",
    "href": "lifecycle.html#sec-lifecycle-release-type",
    "title": "21  Lifecycle",
    "section": "\n21.5 Major vs minor vs patch release",
    "text": "21.5 Major vs minor vs patch release\nRecall that a version number will have one of these forms, if you’re following the conventions described in Section 21.3:\n<major>.<minor>.<patch>        # released version\n<major>.<minor>.<patch>.<dev>  # in-development version\nIf the current package version is 0.8.1.9000, here’s our advice on how to pick the version number for the next release:\n\nIncrement patch, e.g. 0.8.2 for a patch release: you’ve fixed bugs, but you haven’t added any significant new features and there are no breaking changes. For example, if we discover a show-stopping bug shortly after a release, we would make a quick patch release with the fix. Most releases will have a patch number of 0.\nIncrement minor, e.g. 0.9.0, for a minor release. A minor release can include bug fixes, new features, and changes that are backward compatible4. This is the most common type of release. It’s perfectly fine to have so many minor releases that you need to use two (or even three!) digits, e.g. 1.17.0.\nIncrement major, e.g. 1.0.0, for a major release. This is the most appropriate time to make changes that are not backward compatible and that are likely to affect many users. The 1.0.0 release has special significance and typically indicates that your package is feature complete with a stable API.\n\nThe trickiest decision you are likely to face is whether a change is “breaking” enough to deserve a major release. For example, if you make an API-incompatible change to a rarely-used part of your code, it may not make sense to increase the major number. But if you fix a bug that many people depend on (it happens!), it will feel like a breaking change to those folks. It’s conceivable that such a bug fix could merit a major release.\nWe’re mostly dwelling on breaking change, but let’s not forget that sometimes you also add exciting new features to your package. From a marketing perspective, you probably want to save these for a major release, because your users are more likely to learn about the new goodies, from reading a blog post or NEWS.\nHere are a few tidyverse blog posts that have accompanied different types of package releases:\n\nMajor release: dplyr 1.0.0, purrr 1.0.0, pkgdown 2.0.0, readr 2.0.0\nMinor release: stringr 1.5.0, ggplot2 3.4.0\nPatch release: These are usually not considered worthy of a blog post.\n\n\n21.5.1 Package version mechanics\nYour package should start with version number 0.0.0.9000. usethis::create_package() starts with this version, by default.\nFrom that point on, you can use usethis::use_version() to increment the package version. When called interactively, with no argument, it presents a helpful menu:\n\nusethis::use_version()\n#> Current version is 0.1.\n#> What should the new version be? (0 to exit) \n#> \n#> 1: major --> 1.0\n#> 2: minor --> 0.2\n#> 3: patch --> 0.1.1\n#> 4:   dev --> 0.1.0.9000\n#> \n#> Selection: \n\nIn addition to incrementing Version in DESCRIPTION (Chapter 9), use_version() also adds a new heading in NEWS.md (Section 18.2)."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "title": "21  Lifecycle",
    "section": "\n21.6 Pros and cons of breaking change",
    "text": "21.6 Pros and cons of breaking change\nThe big difference between major and minor releases is whether or not the code is backward compatible. In the general software world, the idea is that a major release signals to users that it may contain breaking changes and they should only upgrade when they have the capacity to deal with any issues that emerge.\nReality is a bit different in the R community, because of the way most users manage package installation. If we’re being honest, most R users don’t manage package versions in a very intentional way. Given the way update.packages() and install.packages() work, it’s quite easy to upgrade a package to a new major version without really meaning to, especially for dependencies of the target package. This, in turn, can lead to unexpected exposure to breaking changes in code that previously worked. This unpleasantness has implications both for users and for maintainers.\nIf it’s important to protect a data product against change in its R package dependencies, we recommend the use of a project-specific package library. In particular, we like to implement this approach using the renv package. This supports a lifestyle where a user’s default package library is managed in the usual, somewhat haphazard way. But any project that has a specific, higher requirement for reproducibility is managed with renv. This keeps package updates triggered by work in project A from breaking the code in project B and also helps with collaboration and deployment.\nWe suspect that package-specific libraries and tools like renv are currently under-utilized in the R world. That is, lots of R users still use just one package library. Therefore, package maintainers still need to exercise considerable caution and care when they introduce breaking changes, regardless of what’s happening with the version number. In Section 21.7, we describe how tidyverse packages approach this, supported by tools in the lifecycle package.\nAs with dependencies (Section 10.1), we find that extremism isn’t a very productive stance. Extreme resistance to breaking change puts a significant drag on ongoing development and maintenance. Backward compatible code tends to be harder to work with because of the need to maintain multiple paths to support functionality from previous versions. The harder you strive to maintain backward compatibility, the harder it is to develop new features or fix old mistakes. This, in turn, can discourage adoption by new users and can make it harder to recruit new contributors. On the other hand, if you constantly make breaking changes, users will become very frustrated with your package and will decide they’re better off without it. Find a happy medium. Be concerned about backward compatibility, but don’t let it paralyze you.\nThe importance of backward compatibility is directly proportional to the number of people using your package: you are trading your time and pain for that of your users. There are good reasons to make backward incompatible changes. Once you’ve decided it’s necessary, your main priority is to use a humane process that is respectful of your users."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-stages-and-package",
    "href": "lifecycle.html#sec-lifecycle-stages-and-package",
    "title": "21  Lifecycle",
    "section": "\n21.7 Lifecycle stages and supporting tools",
    "text": "21.7 Lifecycle stages and supporting tools\nThe tidyverse team’s approach to package evolution has become more structured and deliberate over the years. The associated tooling and documentation lives in the lifecycle package (lifecycle.r-lib.org). The approach relies on two major components:\n\nLifecycle stages, which can be applied at different levels, i.e. to an individual argument or function or to an entire package.\nConventions and functions to use when transitioning a function from one lifecycle stage to another. The deprecation process is the one that demands the most care.\n\nWe won’t duplicate too much of the lifecycle documentation here. Instead, we highlight the general principles of lifecycle management and present specific examples of successful lifecycle “moves”.\n\n21.7.1 Lifecycle stages and badges\n\n\n\n\nFigure 21.1: The four primary stages of the tidyverse lifecycle: stable, deprecated, superseded, and experimental.\n\n\n\n\nThe four lifecycle stages are:\n\nStable. This is the default stage and signals that users should feel comfortable relying on a function or package. Breaking changes should be rare and should happen gradually, giving users sufficient time and guidance to adapt their usage.\nExperimental. This is appropriate when a function is first introduced and the maintainer reserves the right to change it without much of a deprecation process. This is the implied stage for any package with a major version of 0, i.e. that hasn’t had a 1.0.0 release yet.\nDeprecated. This applies to functionality that is slated for removal. Initially, it still works, but triggers a deprecation warning with information about preferred alternatives. After a suitable amount of time and with an appropriate version change, such functions are typically removed.\nSuperseded. This is a softer version of deprecated, where legacy functionality is preserved as if in a time capsule. Superseded functions receive only minimal maintenance, such as critical bug fixes.\n\nYou can get much more detail in vignette(\"stages\", package = \"lifecycle\").\nThe lifecycle stage is often communicated through a badge. If you’d like to use lifecycle badges, call usethis::use_lifecycle() to do some one-time setup:\n\nusethis::use_lifecycle()\n#> ✔ Adding 'lifecycle' to Imports field in DESCRIPTION\n#> • Refer to functions with `lifecycle::fun()`\n#> ✔ Adding '@importFrom lifecycle deprecated' to 'R/somepackage-package.R'\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Creating 'man/figures/'\n#> ✔ Copied SVG badges to 'man/figures/'\n#> • Add badges in documentation topics by inserting one of:\n#>   #' `r lifecycle::badge('experimental')`\n#>   #' `r lifecycle::badge('superseded')`\n#>   #' `r lifecycle::badge('deprecated')`\n\nThis leaves you in a position to use lifecycle badges in help topics and to use lifecycle functions, as described in the remainder of this section.\nFor a function, include the badge in its @description block. Here’s how we indicate that dplyr::top_n() is superseded:\n\n#' Select top (or bottom) n rows (by value)\n#'\n#' @description\n#' `r lifecycle::badge(\"superseded\")`\n#' `top_n()` has been superseded in favour of ...\n\nFor a function argument, include the badge in the @param tag. Here’s how the deprecation of readr::write_file(path =) is documented:\n\n#' @param path `r lifecycle::badge(\"deprecated\")` Use the `file` argument\n#'   instead.\n\nCall usethis::use_lifecycle_badge() if you want to use a badge in README to indicate the lifecycle of an entire package (Section 18.1).\nIf the lifecycle of a package is stable, it’s not really necessary to use a badge, since that is the assumed default stage. Similarly, we typically only use a badge for a function if its stage differs from that of the associated package and likewise for an argument and the associated function.\n\n21.7.2 Deprecating a function\nIf you’re going to remove or make significant changes to a function, it’s usually best to do so in phases. Deprecation is a general term for the situation where something is explicitly discouraged, but it has not yet been removed. Various deprecation scenarios are explored in vignette(\"communicate\", package = \"lifecycle\"); we’re just going to cover the main idea here.\nThe lifecycle::deprecate_warn() function can be used inside a function to inform your user that they’re using a deprecated feature and, ideally, to let them know about the preferred alternative. In this example, the plus3() function is being replaced by add3():\n\n# new function\nadd3 <- function(x, y, z) {\n  x + y + z\n}\n\n# old function\nplus3 <- function(x, y, z) {\n  lifecycle::deprecate_warn(\"1.0.0\", \"plus3()\", \"add3()\")\n  add3(x, y, z)\n}\n\nplus3(1, 2, 3)\n#> Warning: `plus3()` was deprecated in somepackage 1.0.0.\n#> ℹ Please use `add3()` instead.\n#> [1] 6\n\nAt this point, a user who calls plus3() sees a warning explaining that the function has a new name, but we go ahead and call add3() with their inputs. Pre-existing code still “works”. In some future major release, plus3() could be removed entirely.\nlifecycle::deprecate_warn() and friends have a few features that are worth highlighting:\n\nThe warning message is built up from inputs like when, what, with, and details, which gives deprecation warnings a predictable form across different functions, packages, and time. The intent is to reduce the cognitive load for users who may already be somewhat stressed.\nBy default, a specific warning is only issued once every 8 hours, in an effort to cause just the right amount of aggravation. The goal is to be just annoying enough to motivate the user to update their code before the function or argument goes away, but not so annoying that they fling their computer into the sea. Near the end of the deprecation process, the always argument can be set to TRUE to warn on every call.\nIf you use lifecycle::deprecate_soft() (instead of deprecate_warn()), a warning is only issued if the person reading it is the one who can actually do something about it, i.e. update the offending code. If a user calls a deprecated function indirectly, i.e. because they are using a package that’s using a deprecated function, by default that user doesn’t get a warning. (But the maintainer of the guilty package will see these warnings in their test results.)\n\nHere’s a hypothetical schedule for removing a function fun():\n\nPackage version 1.5.0: fun() exists. The lifecycle stage of the package is stable, as indicated by its post-1.0.0 version number and, perhaps, a package-level badge. The lifecycle stage of fun() is also stable, by extension, since it hasn’t been specifically marked as experimental.\n\nPackage version 1.6.0: The deprecation process of fun() begins. We insert a badge in its help topic:\n\n#' @description\n#' `r lifecycle::badge(\"deprecated\")`\n\nIn the body of fun(), we add a call to lifecycle::deprecate_warn() to inform users about the situation. Otherwise, fun() still works as it always has.\n\nPackage version 1.7.0 or 2.0.0: fun() is removed. Whether this happens in a minor or major release will depend on the context, i.e. how widely used this package and function are.\n\nIf you’re using base R only, the .Deprecated() and .Defunct() functions are the closest substitutes for lifecycle::deprecate_warn() and friends.\n\n21.7.3 Deprecating an argument\nlifecycle::deprecate_warn() is also useful when deprecating an argument. In this case, it’s also handy to use lifecycle::deprecated() as the default value for the deprecated argument. Here we continue an example from above, i.e. the switch from path to file in readr::write_file():\n\nwrite_file <- function(x,\n                       file,\n                       append = FALSE,\n                       path = deprecated()) {\n  if (is_present(path)) {\n    lifecycle::deprecate_warn(\"1.4.0\", \"write_file(path)\", \"write_file(file)\")\n    file <- path\n  }\n  ...\n}\n\nHere’s what a user sees if they use the deprecated argument:\n\nreadr::write_file(\"hi\", path = tempfile(\"lifecycle-demo-\"))\n#> Warning: The `path` argument of `write_file()` is deprecated as of readr\n#> 1.4.0.\n#> ℹ Please use the `file` argument instead.\n\nThe use of deprecated() as the default accomplishes two things. First, if the user reads the documentation, this is a strong signal that an argument is deprecated. But deprecated() also has benefits for the package maintainer. Inside the affected function, you can use lifecycle::is_present() to determine if the user has specified the deprecated argument and proceed accordingly, as shown above.\nIf you’re using base R only, the missing() function has substantial overlap with lifecycle::is_present(), although it can be trickier to finesse issues around default values.\n\n21.7.4 Deprecation helpers\nSometimes a deprecation affects code in multiple places and it’s clunky to inline the full logic everywhere. In this case, you might create an internal helper to centralize the deprecation logic.\nThis happened in googledrive, when we changed how to control the package’s verbosity. The original design let the user specify this in every single function, via the verbose = TRUE/FALSE argument. Later, we decided it made more sense to use a global option to control verbosity at the package level. This is a case of (eventually) removing an argument, but it affects practically every single function in the package. Here’s what a typical function looks like after starting the deprecation process:\n\ndrive_publish <- function(file, ..., verbose = deprecated()) {\n  warn_for_verbose(verbose)\n  # rest of the function ...\n}\n\nNote the use of verbose = deprecated(). Here’s a slightly simplified version of warn_for_verbose():\n\nwarn_for_verbose <- function(verbose = TRUE,\n                             env = rlang::caller_env(),\n                             user_env = rlang::caller_env(2)) {\n  # This function is not meant to be called directly, so don't worry about its\n  # default of `verbose = TRUE`.\n  # In authentic, indirect usage of this helper, this picks up on whether\n  # `verbose` was present in the **user's** call to the calling function.\n  if (!lifecycle::is_present(verbose) || isTRUE(verbose)) {\n    return(invisible())\n  }\n\n  lifecycle::deprecate_warn(\n    when = \"2.0.0\",\n    what = I(\"The `verbose` argument\"),\n    details = c(\n      \"Set `options(googledrive_quiet = TRUE)` to suppress all googledrive messages.\",\n      \"For finer control, use `local_drive_quiet()` or `with_drive_quiet()`.\",\n      \"googledrive's `verbose` argument will be removed in the future.\"\n    ),\n    user_env = user_env\n  )\n  # only set the option during authentic, indirect usage\n  if (!identical(env, global_env())) {\n    local_drive_quiet(env = env)\n  }\n  invisible()\n}\n\nThe user calls a function, such as drive_publish(), which then calls warn_for_verbose(). If the user leaves verbose unspecified or if they request verbose = TRUE (default behavior), warn_for_verbose() does nothing. But if they explicitly ask for verbose = FALSE, we throw a warning with advice on the preferred way to suppress googledrive’s messaging. We also go ahead and honor their wishes for the time being, via the call to googledrive::local_drive_quiet(). In the next major release, the verbose argument can be removed everywhere and this helper can be deleted.\n\n21.7.5 Dealing with change in a dependency\nWhat if you want to use functionality in a new version of another package? Or the less happy version: what if changes in another package are going to break your package? There are a few possible scenarios, depending on whether the other package has been released and the experience you want for your users. We’ll start with the simple, happier case of using features newly available in a dependency.\nIf the other package has already been released, you could bump the minimum version you declare for it in DESCRIPTION and use the new functionality unconditionally. This also means that users who update your package will be forced to update the other package, which you should at least contemplate. Note, also, that this only works for a dependency in Imports. While it’s a good idea to record a minimum version for a suggested package, it’s not generally enforced the same as for Imports.\nIf you don’t want to require your users to update this other package, you could make your package work with both new and old versions. This means you’ll check its version at run-time and proceed accordingly. Here is a sketch of how that might look in the context of an existing or new function:\n\nyour_existing_function <- function(..., cool_new_feature = FALSE) {\n  if (isTRUE(cool_new_feature) && packageVersion(\"otherpkg\") < \"1.0.0\") {\n    message(\"otherpkg >= 1.0.0 is needed for cool_new_feature\")\n    cool_new_feature <- FALSE\n  }\n  # the rest of the function\n}\n\nyour_new_function <- function(...) {\n  if (packageVersion(\"otherpkg\") < \"1.0.0\") {\n    stop(\"otherpkg >= 1.0.0 needed for this function.\")\n  }\n  # the rest of the function\n}\n\nAlternatively, this would also be a great place to use rlang::is_installed() and rlang::check_installed() with the version argument (see examples of usage in Section 11.5.1).\nThis approach can also be adapted if you’re responding to not-yet-released changes that are coming soon in one of your dependencies. It’s helpful to have a version of your package that works both before and after the change. This allows you to release your package at any time, even before the other package. Sometimes you can refactor your code to make it work with either version of the other package, in which case you don’t need to condition on the other package’s version at all. But sometimes you might really need different code for the two versions. Consider this example:\n\nyour_function <- function(...) {\n  if (packageVersion(\"otherpkg\") >= \"1.3.9000\") {\n    otherpkg::their_new_function()\n  } else {\n    otherpkg::their_old_function()\n  }\n  # the rest of the function\n}\n\nThe hypothetical minimum version of 1.3.9000 suggests a case where the development version of otherpkg already has the change you’re responding to, which is a new function in this case. Assuming their_new_function() doesn’t exist in the latest release of otherpkg, you’ll get a note from R CMD check stating that their_new_function() doesn’t exist in otherpkg’s namespace. If you’re submitting such a version to CRAN, you can explain that you’re doing this for the sake of backward and forward compatibility with otherpkg and they are likely to be satisfied.\n\n21.7.6 Superseding a function\nThe last lifecycle stage that we’ll talk about is superseded. This is appropriate when you feel like a function is no longer the preferred solution to a problem, but it has enough usage and history that you don’t want to initiate the process of removing it. Good examples of this are tidyr::spread() and tidyr::gather(). Those functions have been superseded by tidyr::pivot_wider() and tidyr::pivot_longer(). But some users still prefer the older functions and it’s likely that they’ve been used a lot in projects that are not under active development. Thus spread() and gather() are marked as superseded, they don’t receive any new innovations, but they aren’t at risk of removal.\nA related phenomenon is when you want to change some aspect of a package, but you also want to give existing users a way to opt-in to the legacy behaviour. The idea is to provide users a band-aid they can apply to get old code working quickly, until they have the bandwidth to do a more thorough update (which might not ever happen, in some cases). Here are some examples where legacy behaviour was preserved for users who opt-in:\n\nIn tidyr 1.0.0, the interface of tidyr::nest() and tidyr::unnest() changed. Most authentic usage can be translated to the new syntax, which tidyr does automatically, along with conveying the preferred modern syntax via a warning. But the old interface remains available via tidyr::nest_legacy() and tidyr::unnest_legacy(), which were marked superseded upon creation.\ndplyr 1.1.0 takes advantage of a much faster algorithm for computing groups. But this speedier method also sorts the groups with respect to the C locale, whereas previously the system locale was used. The global option dplyr.legacy_locale allows a user to explicitly request the legacy behaviour.5\nThe tidyverse packages have been standardizing on a common approach to name repair, which is implemented in vctrs::vec_as_names(). The vctrs package also offers vctrs::vec_as_names_legacy(), which makes it easier to get names repaired with older strategies previously used in packages like tibble, tidyr, and readxl.\nreadr 2.0.0 introduced a so-called second edition, marking the switch to a backend provided by the vroom package. Functions like readr::with_edition(1, ...) and readr::local_edition(1) make it easier for a user to request first edition behaviour for a specific bit of code or for a specific script."
  },
  {
    "objectID": "release.html#decide-the-release-type",
    "href": "release.html#decide-the-release-type",
    "title": "22  Releasing to CRAN",
    "section": "\n22.1 Decide the release type",
    "text": "22.1 Decide the release type\nWhen you call use_release_issue(), you’ll be asked which type of release you intend to make.\n\n> use_release_issue()\n✔ Setting active project to '/Users/jenny/rrr/usethis'\nCurrent version is 2.1.6.9000.\nWhat should the release version be? (0 to exit) \n\n1: major --> 3.0.0\n2: minor --> 2.2.0\n3: patch --> 2.1.7\n\nSelection: \n\nThe immediate question feels quite mechanical: which component of the version number do you want to increment? But remember that we discussed the substantive differences in release types in Section 21.5.\nIn our workflow, this planned version number is recorded in the GitHub issue that holds the release checklist, but we don’t actually increment the version in DESCRIPTION until later in the process (Section 22.7). However, it’s important to declare the release type up front, because the process (and, therefore, the checklist) looks different for, e.g., a patch release versus a major release."
  },
  {
    "objectID": "release.html#sec-release-initial",
    "href": "release.html#sec-release-initial",
    "title": "22  Releasing to CRAN",
    "section": "\n22.2 Initial CRAN release: Special considerations",
    "text": "22.2 Initial CRAN release: Special considerations\nEvery new package receives a higher level of scrutiny from CRAN. In addition to the usual automated checks, new packages are also reviewed by a human, which inevitably introduces a certain amount of subjectivity and randomness. There are many packages on CRAN that would not be accepted in their current form, if submitted today as a completely new package. This isn’t meant to discourage you. But you should be aware that, just because you see some practice in an established package (or even in base R), that doesn’t mean you can do the same in your new package.\nLuckily, the community maintains lists of common “gotchas” for new packages. If your package is not yet on CRAN, the checklist begins with a special section that reflects this recent collective wisdom. Attending to these checklist items has dramatically improved our team’s success rate for initial submissions.\nFirst release\n\n\nusethis::use_news_md()\n\n\nusethis::use_cran_comments()\n\n\nUpdate (aspirational) install instructions in README\n\n\nProofread Title: and Description:\n\n\nCheck that all exported functions have @returns and @examples\n\n\nCheck that Authors@R: includes a copyright holder (role ‘cph’)\n\nCheck licensing of included files\n\nReview https://github.com/DavisVaughan/extrachecks\n\n\nIf you don’t already have a NEWS.md file, you are encouraged to create one now with usethis::use_news_md(). You’ll want this file eventually and this anticipates the fact that the description of your eventual GitHub release (Section 22.9) is drawn from NEWS.md.\nusethis::use_cran_comments() initiates a file to hold submission comments for your package. It’s very barebones at first, e.g.:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* This is a new release.\nIn subsequent releases, this file becomes less pointless; for example, it is where we report the results of reverse dependency checks. This is not a place to wax on with long explanations about your submission. In general, you should eliminate the need for such explanations, especially for an initial submission.\nWe highly recommend that your package have a README file (Section 18.1). If it does, this is a good time to check the installation instructions provided there. You may need to switch from instructions to install it from GitHub, in favor of installing from CRAN, in anticipation of your package’s acceptance.\nThe Title and Description fields of DESCRIPTION are real hotspots for nitpicking during CRAN’s human review. Carefully review the advice given in Section 9.2. Also check that Authors@R includes a copyright holder, indicated by the ‘cph’ role. The two most common scenarios are that you add ‘cph’ to your other roles (probably ‘cre’ and ‘aut’) or that you add your employer to Authors@R: with the ‘cph’ and, perhaps, ‘fnd’ role. (When you credit a funder via the ‘fnd’ role, they are acknowledged in the footer of your pkgdown website.) This is also a good time to ensure that the maintainer’s e-mail address is appropriate. This is the only way that CRAN can correspond with you. If there are problems and they can’t get in touch with you, they will remove your package from CRAN. Make sure this email address is likely to be around for a while and that it’s not heavily filtered.\nDouble check that each of your exported functions documents its return value (with the @returns tag, Section 16.4) and has an @examples section (Section 16.5). If you have examples that cannot be run on CRAN, you absolutely must use the techniques in Section 16.5.4 to express the relevant pre-conditions properly. Do not take shortcuts, such as having no examples, commenting out your examples, or putting all of your examples inside \\dontrun{}.\nIf you have embedded third party code in your package, check that you are correctly abiding by and declaring its license (Section 12.4).\nFinally, take advantage of any list of ad hoc checks that other package developers have recently experienced with CRAN. At the time of writing, https://github.com/DavisVaughan/extrachecks is a good place to find such first-hand reports. Reading such a list and preemptively modifying your package can often make the difference between a smooth acceptance and a frustrating process requiring multiple attempts.\n\n22.2.1 CRAN policies\nWe alert you to specific CRAN policies throughout this book and, especially, through this chapter. However, this is something of a moving target, so it pays off to make some effort to keep yourself informed about future changes to CRAN policy.\nThe official home of CRAN policy is https://cran.r-project.org/web/packages/policies.html. However, it’s not very practical to read this document, e.g., once a week and simply hope that you’ll notice any changes. The GitHub repository eddelbuettel/crp monitors the CRAN Repository Policy by tracking the evolution of the underlying files in the source of the CRAN website. Therefore the commit history of that repository makes policy changes much easier to navigate. You may also want to follow the CRAN Policy Watch Mastodon account, which toots whenever a change is detected.2\nThe R-package-devel mailing list is another good resource for learning more about package development. You could subscribe to it to keep tabs on what other maintainers are talking about. Even if you don’t subscribe, it can be useful to search this list, when you’re researching a specific topic."
  },
  {
    "objectID": "release.html#keeping-up-with-change",
    "href": "release.html#keeping-up-with-change",
    "title": "22  Releasing to CRAN",
    "section": "\n22.3 Keeping up with change",
    "text": "22.3 Keeping up with change\nNow we move into the main checklist items for a minor or major release of a package that is already on CRAN. Many of these items also appear in the checklist for a patch or initial release.\n\n\nCheck current CRAN check results\n\nCheck if any deprecation processes should be advanced, as described in Gradual deprecation\n\n\nPolish NEWS\n\n\nurlchecker::url_check()\n\n\ndevtools::build_readme()\n\n\nThese first few items confirm that your package is keeping up with its surroundings and with itself. The first item, “Check current CRAN check results”, will be a hyperlink to the CRAN check results for the version of the package that is currently on CRAN. If there are any WARNINGs or ERRORs or NOTEs there, you should investigate and determine what’s going on. Occasionally there can be an intermittent hiccup at CRAN, but generally speaking, any result other than “OK” is something you should address with the release you are preparing. You may discover your package is in a dysfunctional state due to changes in base R, CRAN policies, CRAN tooling, or packages you depend on.\nIf you are in the process of deprecating a function or an argument, a minor or major release is a good time to consider moving that process along as described in Section 21.7. This is also a good time to look at all the NEWS bullets that have accumulated since the last release (“Polish NEWS”). Even if you’ve been diligent about jotting down all the news-worthy changes, chances are these bullets will benefit from some re-organization and editing for consistency and clarity (Section 18.2).\nAnother very important check is to run urlchecker::url_check(). CRAN’s URL checks are described at https://cran.r-project.org/web/packages/URL_checks.html and are implemented by code that ships with R itself. However, these checks are not exposed in a very usable way. The urlchecker package was created to address this and exposes CRAN’s URL-checking logic in the url_check() function. The main problems that surface tend to be URLs that don’t work anymore or URLs that use redirection. Obviously, you should update or remove any URL that no longer exists. Redirection, however, is trickier. If the status code is “301 Moved Permanently”, CRAN’s view is that your package should use the redirected URL. The problem is that many folks don’t follow RFC7231 to the letter and use this sort of redirect even when they have a different intent, i.e. their intent is to provide a stable, user-friendly URL that then redirects to something less user-friendly or more volatile. If a legitimate URL you want to use runs afoul of CRAN’s checks, you’ll have to choose between a couple of less-than-appealing options. You could try to explain the situation to CRAN, but this requires human review, and thus is not recommended. Or you can convert such URLs into non-hyperlinked, verbatim text. Note also that even though urlchecker is using the same code as CRAN, your local results may still differ from CRAN’s, due to differences in other ambient conditions, such as environment variables and system capabilities.\nIf you have a README.Rmd file, you will also want to re-build the static README.md file with the current version of your package. The best function to use for this is devtools::build_readme(), because it is guaranteed to render README.Rmd against the current source code of your package."
  },
  {
    "objectID": "release.html#double-r-cmd-checking",
    "href": "release.html#double-r-cmd-checking",
    "title": "22  Releasing to CRAN",
    "section": "\n22.4 Double R CMD checking",
    "text": "22.4 Double R CMD checking\nNext come a couple of items related to R CMD check. Remember that this should not be the first time you’ve run R CMD check since the previous release! Hopefully, you are running R CMD check often during local development and are using a continuous integration service, like GitHub Actions. This is meant to be a last-minute, final reminder to double-check that all is still well:\n\ndevtools::check(remote = TRUE, manual = TRUE). This happens on your primary development machine, presumably with the current version of R, and with some extra checks that are usually turned off to make day-to-day development faster.\ndevtools::check_win_devel(). This sends your package off to be checked with CRAN’s win-builder service, against the latest development version of R (a.k.a. r-devel). You should receive an e-mail within about 30 minutes with a link to the check results. It’s a good idea to check your package with r-devel, because base R and R CMD check are constantly evolving. Checking with r-devel is required by CRAN policy and it will be done as part of CRAN’s incoming checks. There is no point in skipping this step and hoping for the best.\n\nNote that the brevity of this list implicitly reflects that tidyverse packages are checked after every push via GitHub Actions, across multiple operating systems and versions of R (including the development version), and that most of the tidyverse team develops primarily on macOS. CRAN expects you to “make all reasonable efforts” to get your package working across all of the major R platforms and packages that don’t work on at least two will typically not be accepted.\nThe next subsection (Section 22.4.1) is optional reading with more details on the all the platforms that CRAN cares about and how you can access them. If your ongoing checks are more limited than ours, you may want to make up for that with more extensive pre-submission checks. You may also need this knowledge to troubleshoot a concrete problem that surfaces in CRAN’s checks, either for an incoming submission or for a package that’s already on CRAN.\nWhen running R CMD check for a CRAN submission, you have to address any problems that show up:\n\nYou must fix all ERRORs and WARNINGs. A package that contains any errors or warnings will not be accepted by CRAN.\nEliminate as many NOTEs as possible. Each NOTE requires human oversight, which creates friction for both you and CRAN. If there are notes that you do not believe are important, it is almost always easier to fix them (even if the fix is a bit of a hack) than to persuade CRAN that they’re OK. See our online-only guide to R CMD check for details on how to fix individual problems.\n\nIf you can’t eliminate a NOTE, list it in cran-comments.md and explain why you think it is spurious. We discuss this file further in Section 22.6.\nNote that there will always be one NOTE when you first submit your package. This reminds CRAN that this is a new submission and that they’ll need to do some extra checks. You can’t eliminate this NOTE, so just mention in cran-comments.md that this is your first submission.\n\n\n\n22.4.1 CRAN check flavors and related services\nCRAN runs R CMD check on all contributed packages upon submission and on a regular basis, on multiple platforms or what they call “flavors”. You can see CRAN’s current check flavors here: https://cran.r-project.org/web/checks/check_flavors.html. There are various combinations of:\n\nOperating system and CPU: Windows, macOS (x86_64, arm64), Linux (various distributions)\nR version: r-devel, r-release, r-oldrel\nC, C++, FORTRAN compilers\nLocale, in the sense of the LC_CTYPE environment variable (this is about which human language is in use and character encoding)\n\nCRAN’s check flavors almost certainly include platforms other than your preferred development environment(s), so you will eventually need to make an explicit effort to check and, perhaps, troubleshoot your package on these other flavors.\nIt would be impractical for individual package developers to personally maintain all of these testing platforms. Instead, we turn to various community- and CRAN-maintained resources for this. Here is a selection, in order of how central they are to our current practices:\n\nGitHub Actions (GHA) is our primary means of testing packages on multiple flavors, as covered in Section 20.2.1.\n\nR-hub builder (R-hub). This is a service supported by the R Consortium where package developers can submit their package for checks that replicate various CRAN check flavors.\nYou can use R-hub via a web interface (https://builder.r-hub.io) or, as we recommend, through the rhub R package.\nrhub::check_for_cran() is a good option for a typical CRAN package and is morally similar to the GHA workflow configured by usethis::use_github_action(\"check-standard\"). However, unlike GHA, R-hub currently does not cover macOS, only Windows and Linux.\nrhub also helps you access some of the more exotic check flavors and offers specialized checks relevant to packages with compiled code, such as rhub::check_with_sanitizers().\n\n\nmacOS builder is a service maintained by the CRAN personnel who build the macOS binaries for CRAN packages. This is a relatively new addition to the list and checks packages with “the same setup and available packages as the CRAN M1 build machine”.\nYou can submit your package using the web interface (https://mac.r-project.org/macbuilder/submit.html) or with devtools::check_mac_release()."
  },
  {
    "objectID": "release.html#sec-release-revdep-checks",
    "href": "release.html#sec-release-revdep-checks",
    "title": "22  Releasing to CRAN",
    "section": "\n22.5 Reverse dependency checks",
    "text": "22.5 Reverse dependency checks\n\n\nrevdepcheck::revdep_check(num_workers = 4)\n\n\nThis innocuous checklist item can actually represent a considerable amount of effort. At a high-level, checking your reverse dependencies (“revdeps”) breaks down into:\n\nForm a list of your reverse dependencies. These are CRAN packages that list your package in their Depends, Imports, Suggests or LinkingTo fields.\nRun R CMD check on each one.\nMake sure you haven’t broken someone else’s package with the planned changes in your package.\n\nEach of these steps can require considerable work and judgment. So, if you have no reverse dependencies, you should rejoice that you can skip this step. If you only have a couple of reverse dependencies, you can probably do this “by hand”, i.e. download each package’s source and run R CMD check.\nHere we explain ways to do reverse dependency checks at scale, which is the problem we face. Some of the packages maintained by our team have thousands of reverse dependencies and even some of the lower-level packages have hundreds. We have to approach this in an automated fashion and this section will be most useful to other maintainers in the same boat.\nAll of our reverse dependency tooling is concentrated in the revdepcheck package (https://revdepcheck.r-lib.org/). Note that, at least at the time of writing, the revdepcheck package is not on CRAN. You can install it from Github via devtools::install_github(\"r-lib/revdepcheck\") or pak::pak(\"r-lib/revdepcheck\").\nDo this when you’re ready to do revdep checks for the first time:\n\nusethis::use_revdep()\n\nThis does some one-time setup in your package’s .gitignore and .Rbuildignore files. Revdep checking will create some rather large folders below revdep/, so you definitely want to configure these ignore files. You will also see this reminder to actually perform revdep checks like so, as the checklist item suggests:\n\nrevdepcheck::revdep_check(num_workers = 4)\n\nThis runs ⁠R CMD check⁠ on all of your reverse dependencies, with our recommendation to use 4 parallel workers to speed things along. The output looks something like this:\n> revdepcheck::revdep_check(num_workers = 4)\n── INIT ───────────────────────────────────── Computing revdeps ──\n── INSTALL ───────────────────────────────────────── 2 versions ──\nInstalling CRAN version of cellranger\nalso installing the dependencies 'cli', 'glue', 'utf8', 'fansi', 'lifecycle', 'magrittr', 'pillar', 'pkgconfig', 'rlang', 'vctrs', 'rematch', 'tibble'\n\nInstalling DEV version of cellranger\nInstalling 13 packages: rlang, lifecycle, glue, cli, vctrs, utf8, fansi, pkgconfig, pillar, magrittr, tibble, rematch2, rematch\n── CHECK ─────────────────────────────────────────── 8 packages ──\n✔ AOV1R 0.1.0                     ── E: 0     | W: 0     | N: 0\n✔ mschart 0.4.0                   ── E: 0     | W: 0     | N: 0\n✔ googlesheets4 1.0.1             ── E: 0     | W: 0     | N: 1\n✔ readODS 1.8.0                   ── E: 0     | W: 0     | N: 0\n✔ readxl 1.4.2                    ── E: 0     | W: 0     | N: 0\n✔ readxlsb 0.1.6                  ── E: 0     | W: 0     | N: 0\n✔ unpivotr 0.6.3                  ── E: 0     | W: 0     | N: 0\n✔ tidyxl 1.0.8                    ── E: 0     | W: 0     | N: 0                  \nOK: 8                                                                                 \nBROKEN: 0\nTotal time: 6 min\n── REPORT ────────────────────────────────────────────────────────\nWriting summary to 'revdep/README.md'\nWriting problems to 'revdep/problems.md'\nWriting failures to 'revdep/failures.md'\nWriting CRAN report to 'revdep/cran.md'\nTo minimize false positives, revdep_check() runs ⁠R CMD check⁠ twice per revdep: once with the released version of your package currently on CRAN and again with the local development version, i.e. with your release candidate. Why two checks? Because sometimes the revdep is already failing R CMD check and it would be incorrect to blame your planned release for the breakage. revdep_check() reports the packages that can’t be checked and, most importantly, those where there are so-called “changes to the worse”, i.e. where your release candidate is associated with new problems. Note also that revdep_check() always works with a temporary, self-contained package library, i.e. it won’t modify your default user or system library.\n\n\n\n\n\n\ntidyverse team\n\n\n\nWe actually use a different function for our reverse dependency checks: revdepcheck::cloud_check(). This runs the checks in the cloud, massively in parallel, making it possible to run revdep checks for packages like testthat (with >10,000 revdeps) in just a few hours!\ncloud_check() has been a gamechanger for us, allowing us to run revdep checks more often. For example, we even do this now when assessing the impact of a potential change to a package (Section 21.4), instead of only right before a release.\nAt the time of writing, cloud_check() is only available for package maintainers at Posit, but we hope to offer this service for the broader R community in the future.\n\n\nIn addition to some interactive messages, the revdep check results are written to the revdep/ folder:\n\n\nrevdep/README.md: This is a high-level summary aimed at maintainers. The filename and Markdown format are very intentional, in order to create a nice landing page for the revdep/ folder on GitHub.\n\nrevdep/problems.md: This lists the revdeps that appear to be broken by your release candidate.\n\nrevdep/failures.md: This lists the revdeps that could not be checked, usually because of an installation failure, either of the revdep itself or one of its dependencies.\n\nrevdep/cran.md: This is a high-level summary aimed at CRAN. You should copy and paste this into cran-comments.md (Section 22.6).\nOther files and folders, such as checks.noindex, data.sqlite, and library.noindex. These are for revdepcheck’s internal use and we won’t discuss them further.\n\nThe easiest way to get a feel for these different files is to look around at the latest revdep results for some tidyverse packages, such as dplyr or tidyr.\nThe revdep check results – local, cloud, or CRAN – are not perfect, because this is not a simple task. There are various reasons why a result might be missing, incorrect, or contradictory in different runs.\n\nFalse positives: sometimes revdepcheck reports a package has been broken, but things are actually fine (or, at least, no worse than before). This most commonly happens because of flaky tests that fail randomly (Section 15.4.1), such as HTTP requests. This can also happen because the instance runs out of disk space or other resources, so the first check using the CRAN version succeeds and the second check using the dev version fails. Sometimes it’s obvious that the problem is not related to your package.\nFalse negatives: sometimes a package has been broken, but you don’t detect that. For us, this usually happens when cloud_check() can’t check a revdep because it can’t be installed, typically because of a missing system requirement (e.g. Java). These are separately reported as “failed to test” but are still included in problems.md, because this could still be direct breakage caused by your package. For example, if you remove an exported function that’s used by another package, installation will fail.\n\nGenerally these differences are less of a worry now that CRAN’s own revdep checks are well automated, so new failures typically don’t involve a human.\n\n22.5.1 Revdeps and breaking changes\nIf the revdep check reveals breakages, you need to examine each failure and determine if it’s:\n\nA false positive.\nA non-breaking change, i.e. a failure caused by off-label usage of your package.\nA bug in your package that you need to fix.\nA deliberate breaking change.\n\nIf your update will break another package (regardless of why), you need to inform the maintainer, so they hear it first from you, rather than CRAN. The nicest way to do this is with a patch that updates their package to play nicely with yours, perhaps in the form of a pull request. This can be a decent amount of work and is certainly not feasible for all maintainers. But working through a few of these can be a good way to confront the pain that breaking change causes and to reconsider whether the benefits outweigh the costs. In most cases, a change that affects revdeps is likely to also break less visible code that lives outside of CRAN packages, such as scripts, reports, and Shiny apps.\nIf you decide to proceed, functions such as revdepcheck::revdep_maintainers() and revdepcheck::revdep_email() can help you notify revdep maintainers en masse. Make sure the email includes a link to documentation that describes the most common breaking changes and how to fix them. You should let the maintainers know when you plan to submit to CRAN (we recommend giving at least two weeks notice), so they can submit their updated version before that. When your release date rolls around, re-run your checks to see how many problems have been resolved. Explain any remaining failures in cran-comments.md as demonstrated in Section 22.6. The two most common cases are that you are unable to check a package because you aren’t able to install it locally or a legitimate change in the API which the maintainer hasn’t addressed yet. As long as you have given sufficient advanced notice, CRAN will accept your update, even if it breaks some other packages.\n\n\n\n\n\n\ntidyverse team\n\n\n\nLately the tidyverse team is trying to meet revdep maintainers more than halfway in terms of dealing with breaking changes. For example, in GitHub issue tidyverse/dplyr#6262, the dplyr maintainers tracked hundreds of pull requests in the build-up to the release of dplyr v1.1.0. As the PRs are created, it’s helpful to add links to those as well. As the revdep maintainers merge the PRs, they can be checked off as resolved. If some PRs are still in-flight when the announced submission date rolls around, the situation can be summarized in cran-comments.md, as was true in the case of dplyr v1.1.0."
  },
  {
    "objectID": "release.html#sec-release-cran-comments",
    "href": "release.html#sec-release-cran-comments",
    "title": "22  Releasing to CRAN",
    "section": "\n22.6 Update comments for CRAN",
    "text": "22.6 Update comments for CRAN\n\n\nUpdate cran-comments.md\n\n\nWe use the cran-comments.md file to record comments about a submission, mainly just the results from R CMD check and revdep checks. If you are making a specific change at CRAN’s request, possibly under a deadline, that would also make sense to mention. We like to track this file in Git, so we can see how it changes over time. It should also be listed in .Rbuildignore, since it should not appear in your package bundle. When you’re ready to submit, devtools::submit_cran() (Section 22.7) incorporates the contents of cran-comments.md when it uploads your submission.\nThe target audience for these comments is the CRAN personnel, although there is no guarantee that they will read the comments (or when in the submission process they read them). For example, if your package breaks other packages, you will likely receive an automated email about that, even if you’ve explained that in the comments. Sometimes a human at CRAN then reads the comments, is satisfied, and accepts your package anyway, without further action from you. At other times, your package may be stuck in the queue until you copy cran-comments.md and paste it into an email exchange to move things along. In either case, it’s worth keeping these comments in their own, version-controlled file.\nHere is a fairly typical cran-comments.md from a recent release of forcats. Note that the R CMD check results are clean, i.e. there is nothing that needs to be explained or justified, and there is a concise summary of the revdep process.\n## R CMD check results\n\n0 errors | 0 warnings | 0 notes\n\n## revdepcheck results\n\nWe checked 231 reverse dependencies (228 from CRAN + 3 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.\n\nWe saw 2 new problems:\n\n* epikit\n* stevemisc\n\nBoth maintainers were notified on Jan 12 (~2 week ago) and supplied with patches.\n\nWe failed to check 3 packages\n\n* genekitr     (NA)\n* OlinkAnalyze (NA)\n* SCpubr       (NA)\nThis layout is designed to be easy to skim, and easy to match up to the R CMD check results seen by CRAN maintainers. It includes two sections:\n\n\nCheck results: We always state that there were no errors or warnings (and we make sure that’s true!). Ideally we can also say there were no notes. But if not, any NOTEs are presented in a bulleted list. For each NOTE, we include the message from R CMD check and a brief description of why we think it’s OK.\nHere is how a NOTE is explained for the nycflights13 data package:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* Checking installed package size:\n  installed size is  6.9Mb\n  sub-directories of 1Mb or more:\n    data   6.9Mb\n\n  This is a data package that will be rarely updated.\n\nReverse dependencies: If there are revdeps, this is where we paste the contents of revdep/cran.md (Section 22.5). If there are no revdeps, we recommend that you keep this section, but say something like: “There are currently no downstream dependencies for this package”."
  },
  {
    "objectID": "release.html#sec-release-process",
    "href": "release.html#sec-release-process",
    "title": "22  Releasing to CRAN",
    "section": "\n22.7 The submission process",
    "text": "22.7 The submission process\n\n\nusethis::use_version('minor') (or ‘patch’ or ‘major’)\n\ndevtools::submit_cran()\n\n\nApprove email\n\nWhen you’re truly ready to submit, it’s time to actually bump the version number in DESCRIPTION. This checklist item will reflect the type of release declared at the start of this process (patch, minor, or major), in the initial call to use_release_issue().\nWe recommend that you submit your package to CRAN by calling devtools::submit_cran(). This convenience function wraps up a few steps:\n\nCreates the package bundle (Section 3.3) with pkgbuild::build(manual = TRUE), which ultimately calls R CMD build.\nPosts the resulting *.tar.gz file to CRAN’s official submission form (https://cran.r-project.org/submit.html), populating your name and email from DESCRIPTION and your submission comments from cran-comments.md.\nConfirms that the submission was successful and reminds you to check your email for the confirmation link.\nWrites submission details to a local CRAN-SUBMISSION file, which records the package version, SHA, and time of submission. This information is used later by usethis::use_github_release() to create a GitHub release once your package has been accepted. CRAN-SUBMISSION will be added to .Rbuildignore. We generally do not gitignore this file, but neither do we commit it. It’s an ephemeral note that exists during the interval between submission and (hopefully) acceptance.\n\nAfter a successful upload, you should receive an email from CRAN within a few minutes. This email notifies you, as maintainer, of the submission and provides a confirmation link. Part of what this does is confirm that the maintainer’s email address is correct. At the confirmation link, you are required to re-confirm that you’ve followed CRAN’s policies and that you want to submit the package. If you fail to complete this step, your package is not actually submitted to CRAN!\nOnce your package enters CRAN’s system it is automatically checked on Windows and Linux, probably against both the released and development versions of R. You will get another email with links to these check results, usually within a matter of hours. An initial submission (Section 22.2) will receive additional scrutiny from CRAN personnel. The process is potentially fully automated when updating a package that is already on CRAN. If a package update passes its initial checks, CRAN will then run reverse dependency checks."
  },
  {
    "objectID": "release.html#failure-modes",
    "href": "release.html#failure-modes",
    "title": "22  Releasing to CRAN",
    "section": "\n22.8 Failure modes",
    "text": "22.8 Failure modes\nThere are at least three ways for your CRAN submission to fail:\n\nIt does not pass R CMD check. This is an automated result.\nHuman review finds the package to be in violation of CRAN policies. This applies mostly to initial submissions, but sometimes CRAN personnel decides to engage in ad hoc review of updates to existing packages that fail any automated checks.\nReverse dependency checks suggest there are “changes to the worse”. This is an automated result.\n\nFailures are frustrating and the feedback may be curt and may feel downright insulting. Take comfort in the fact that this a widely shared experience across the R community. It happens to us on a regular basis. Don’t rush to respond, especially if you are feeling defensive.\nWait until you are able to focus your attention on the technical issues that have been raised. Read any check results or emails carefully and investigate the findings. Unless you feel extremely strongly that discussion is merited, don’t respond to the e-mail. Instead:\n\nFix the identified problems and make recommended changes. Re-run devtools::check() on any relevant platforms to make sure you didn’t accidentally introduce any new problems.\nIncrease the patch version of your package. Yes, this means that there might be gaps in your released version numbers. This is not a big deal.\n\nAdd a “Resubmission” section at the top of cran-comments.md. This should clearly identify that the package is a resubmission, and list the changes that you made.\n## Resubmission\nThis is a resubmission. In this version I have:\n\n* Converted the DESCRIPTION title to title case.\n\n* More clearly identified the copyright holders in the DESCRIPTION\n  and LICENSE files.\n\nIf necessary, update the check results and revdep sections.\nRun devtools::submit_cran() to re-submit the package.\n\nIf your analysis indicates that the initial failure was a false positive, reply to CRAN’s email with a concise explanation. For us, this scenario mostly comes up with respect to revdep checks. It’s extremely rare for us to see failure for CRAN’s initial R CMD check runs and, when it happens, it’s often legitimate. On the other hand, for packages with a large number of revdeps, it’s inevitable that a subset of these packages have some flaky tests or brittle examples. Therefore it’s quite common to see revdep failures that have nothing to do with the proposed package update. In this case, it is appropriate to send a reply email to CRAN explaining why you think these are false positives."
  },
  {
    "objectID": "release.html#sec-release-post-acceptance",
    "href": "release.html#sec-release-post-acceptance",
    "title": "22  Releasing to CRAN",
    "section": "\n22.9 Celebrating success",
    "text": "22.9 Celebrating success\nNow we move into the happiest section of the check list.\n\n\nAccepted 🎉\n\ngit push\n\n\nusethis::use_github_release()\n\n\nusethis::use_dev_version()\n\n\ngit push\n\n\nFinish blog post, share on social media, etc.\n\nAdd link to blog post in pkgdown news menu\n\nCRAN will notify you by email once your package is accepted. This is when we first push to GitHub with the new version number, i.e. we wait until it’s certain that this version will actually be released on CRAN. Next we create a GitHub release corresponding to this CRAN release, using usethis::use_github_release(). A GitHub release is basically a glorified Git tag. The only aspect of GitHub releases that we regularly take advantage of is the release notes. usethis::use_github_release() creates release notes from the NEWS bullets relevant to the current release. Note that usethis::use_github_release() depends crucially on the CRAN-SUBMISSION file that was written by devtools::submit_cran(): that’s how it knows which SHA to tag. After the successful creation of the GitHub release, use_github_release() deletes this temporary file.\nNow we prepare for the next release by incrementing the version number yet again, this time to a development version using usethis::use_dev_version(). It makes sense to immediately push this state to GitHub so that, for example, any new branches or pull requests clearly have a development version as their base.\nAfter the package has been accepted by CRAN, binaries are built for macOS and Windows. It will also be checked across the panel of CRAN check flavors. These processes unfold over a few days, post-acceptance, and sometimes they uncover errors that weren’t detected by the less comprehensive incoming checks. It’s a good idea to visit your package’s CRAN landing page a few days after release and just make sure that all still seems to be well. Figure 22.1 highlights where these results are linked from a CRAN landing page.\n\n\n\n\n\nFigure 22.1: Link to CRAN check results.\n\n\n\n\nIf there is a problem, prepare a patch release to address it and submit using the same process as before. If this means you are making a second submission less than a week after the previous, explain the situation in cran-comments.md. Getting a package established on CRAN can take a couple of rounds, although the guidance in this chapter is intended to maximize the chance of success on the first try. Future releases, initiated from your end, should be spaced at least one or two months apart, according to CRAN policy.\nOnce your package’s binaries are built and it has passed checks across CRAN’s flavors, it’s time for the fun part: publicizing your package. This takes different forms, depending on the type of release. If this is your initial release (or, at least, the first release for which you really want to attract users), it’s especially important to spread the word. No one will use your helpful new package if they don’t know that it exists. There are a number of places to announce your package, such as Twitter, Mastodon, LinkedIn, Slack communities, etc. Make sure to use any relevant tags, such as the #rstats hashtag. If you have a blog, it’s a great idea to write a post about your release.\nWhen introducing a package, the vibe should be fairly similar to writing your README or a “Getting Started” vignette. Make sure to describe what the package does, so that people who haven’t used it before can understand why they should even care. For existing packages, we tend to write blog posts for minor and major releases, but not for a patch release. In all cases, we find that these blog posts are most effective when they include lots of examples, i.e. “show, don’t tell”. For package updates, remember that the existence of a comprehensive NEWS file frees you from the need to list every last change in your blog post. Instead, you can focus on the most important changes and link to the full release notes, for those who want the gory details.\nIf you do blog about your package, it’s good to capture this as yet another piece of documentation in your pkgdown website. A typical pkgdown site has a “News” item in the top navbar, linking to a “Changelog” which is built from NEWS.md. This drop-down menu is a common place to insert links to any blog posts about the package. You can accomplish this by having YAML like this in your _pkgdown.yml configuration file:\nnews:\n  releases:\n  - text: \"Renaming the default branch (usethis >= 2.1.2)\"\n    href: https://www.tidyverse.org/blog/2021/10/renaming-default-branch/\n  - text: \"usethis 2.0.0\"\n    href: https://www.tidyverse.org/blog/2020/12/usethis-2-0-0/\n  - text: \"usethis 1.6.0\"\n    href: https://www.tidyverse.org/blog/2020/04/usethis-1-6-0/\nCongratulations! You have released your first package to CRAN and made it to the end of the book!"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "23  References",
    "section": "",
    "text": "Bryan, Jennifer. 2018. “Excuse Me, Do You Have a Moment to Talk\nabout Version Control?” The American Statistician 72\n(1): 20–27. https://doi.org/10.1080/00031305.2017.1399928.\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a.\n“Packaging Data Analytical Work Reproducibly Using r (and\nFriends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r\n(and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive\nPretty Printing of R Code. http://styler.r-lib.org.\n\n\nSilge, Julia, John C. Nash, and Spencer Graves. 2018. “Navigating the R Package Universe.”\nThe R Journal 10 (2): 558–63. https://doi.org/10.32614/RJ-2018-058."
  },
  {
    "objectID": "R-CMD-check.html#check-metadata",
    "href": "R-CMD-check.html#check-metadata",
    "title": "Appendix A — R CMD check",
    "section": "A.1 Check metadata",
    "text": "A.1 Check metadata\nR CMD check always starts by describing your current environment.\n\nUsing log directory ‘/some/tmp/path/googledrive.Rcheck’\nUsing R version 4.2.2 (2022-10-31)\nUsing platform: x86_64-apple-darwin17.0 (64-bit)\nUsing session charset: UTF-8\n\nNext the DESCRIPTION file is parsed and the package version and encoding is printed.\n\n\nChecking for file ‘googledrive/DESCRIPTION’\nThis is package ‘googledrive’ version ‘2.1.0.9000’\nPackage encoding: UTF-8"
  },
  {
    "objectID": "R-CMD-check.html#package-structure",
    "href": "R-CMD-check.html#package-structure",
    "title": "Appendix A — R CMD check",
    "section": "A.2 Package structure",
    "text": "A.2 Package structure\n\n\nChecking package directory. The directory you’re checking must exist - devtools::check() protects you against this problem.\n\n\n\nChecking if this is a source package. You must check a source package, not a binary or installed package. This should never fail if you use devtools::check().\n\n\n\nChecking for executable files. You must not have executable files in your package: they’re not portable, they’re not open source, and they are a security risk. Delete any executable files from your package. (If you’re not submitting to CRAN, you can silence this warning by listing each executable file in the BinaryFiles field in your DESCRIPTION.)\n\n\n\nChecking for hidden files and directories. On Linux and macOS, files with a name starting with . are hidden by default, and you’ve probably included them in your package by mistake. Either delete them, or if they are important, use .Rbuildignore to remove them from the package bundle. R automatically removes some common directories like .git and .svn.\n\n\n\nChecking for portable file names. R packages must work on Windows, Linux and macOS, so you can only use file names that work on all platforms. The easiest way to do this is to stick to letters, numbers, underscores and dashes. Avoid non-English letters and spaces. Fix this check by renaming the listed files.\n\n\n\nChecking for sufficient/correct file permissions. If you can’t read a file, you can’t check it. This check detects the unlikely occurrence that you have files in the package that you don’t have permission to read. Fix this problem by fixing the file permissions.\n\n\n\nChecking whether package ‘XYZ’ can be installed. R CMD check runs R CMD INSTALL to make sure that it’s possible to install your package. If this fails, you should run devtools::install() or the equivalent from RStudio’s menus and debug any problems before continuing.\n\n\n\nChecking installed package size. It’s easy to accidentally include large files that blow up the size of your package. This check ensures that the whole package is less than 5 MB and each subdirectory is less than 1 MB. If you see this message, check that you haven’t accidentally included a large file.\nIf submitting to CRAN, you’ll need to justify the size of your package. First, make sure the package is as small as it possibly can be: try recompressing the data, Section 7.1.1; and minimising vignettes, Chapter 17. If it’s still too large, consider moving data into its own package.\n\n\n\nChecking top-level files. Only specified files and directories are allowed at the top level of the package (e.g. DESCRIPTION, R/, src/). To include other files, you have two choices:\n\nIf they don’t need to be installed (i.e. they’re only used for development tasks), add them to .Rbuildignore with usethis::use_build_ignore().\nIf they need to be installed: move them into inst/. They’ll be moved back to the top-level package directory when installed. Learn more in Section 8.2.\n\n\n\n\nChecking package subdirectories.\n\nDon’t include any empty directories. These are usually removed automatically by R CMD build so you shouldn’t see this error. If you do, just delete the empty directory.\nThe case of files and directories is important. All sub-directories should be lower-case, except for R/. A citation file, if present, should be in inst/CITATION. Rename as needed.\nThe contents of inst/ shouldn’t clash with top-level contents of the package, such as data/ or R/. If they do, rename your files/directories. Learn more in Section 8.2.\n\n\n\n\nChecking for left-over files. Remove any files listed here. They’ve been included in your package by accident."
  },
  {
    "objectID": "R-CMD-check.html#description",
    "href": "R-CMD-check.html#description",
    "title": "Appendix A — R CMD check",
    "section": "A.3 DESCRIPTION",
    "text": "A.3 DESCRIPTION\n\n\nChecking DESCRIPTION meta-information.\n\nThe DESCRIPTION must be valid. You are unlikely to see this error, because devtools::load_all() runs the same check each time you re-load the package.\nIf you use any non-ASCII characters in the DESCRIPTION, you must also specify an encoding. There are only three encodings that work on all platforms: latin1, latin2 and UTF-8. We strongly recommend UTF-8: Encoding: UTF-8. Learn more in Section 7.1.3.\nThe License must refer to either a known license (a complete list can be found at https://svn.r-project.org/R/trunk/share/licenses/license.db), or it must use file LICENSE and that file must exist. Errors here are most likely to be typos. Learn more in Chapter 12.\nYou should either provide Authors@R or Authors and Maintainer. You’ll get an error if you’ve specified both, which you can fix by removing the one you didn’t want. Learn more in Section 9.3.\n\n\n\n\nChecking package dependencies.\n\nAll packages listed in Depends, Imports and LinkingTo must be installed, and their version requirements must be met, otherwise your package can’t be checked.\nPackages listed in Suggests must be installed, unless you’ve set the environment variable _R_CHECK_FORCE_SUGGESTS_ to a false value (e.g. with check(force_suggests = FALSE)). This is useful if some of the suggested packages are not available on all platforms.\nAn easy way to install any missing or outdated dependencies is to run devtools::install_deps(dependencies = TRUE). See also pak::local_install_deps() and pak::local_install_dev_deps().\nR packages can not have a cycle of dependencies: i.e. if package A requires B, then B can not require A (otherwise which one would you load first?). If you see this error, you’ll need to rethink the design of your package. One easy fix is to move the conflicting package from Imports or Depends to Suggests.\nAny packages used in the NAMESPACE must be listed in one of Imports (most commonly) or Depends (only in special cases).\nEvery package listed in Depends must also be imported in the NAMESPACE or accessed with pkg::foo(). If you don’t do this, your package will work when attached to the search path (with library(mypackage)) but will not work when only loaded (e.g. mypackage::foo())\n\n\n\n\nChecking CRAN incoming feasibility. These checks only apply if you’re submitting to CRAN.\n\nIf you’re submitting a new package, you can’t use the same name as an existing package. You’ll need to come up with a new name.\nIf you’re submitting an update, the version number must be higher than the current CRAN version. Update the Version field in DESCRIPTION.\nIf the maintainer of the package has changed (even if it’s just a change in email address), the new maintainer should submit to CRAN, and the old maintainer will receive an email prompting them to confirm the change.\nYou must use a standard open source license, as listed in https://svn.r-project.org/R/trunk/share/licenses/license.db. You can not use a custom license as CRAN does not have the legal resources to review custom agreements.\nThe Title and Description must be free from spelling mistakes. The title of the package must be in title case. Neither title nor description should include either the name of your package or the word “package”. Reword your title and description as needed.\nIf you’re submitting a new package, you’ll always get a NOTE. This reminds the CRAN maintainers to do some extra manual checks.\nAvoid submitting multiple versions of the same package in a short period of time. CRAN prefers at most one submission per month. If you need to fix a major bug, be apologetic."
  },
  {
    "objectID": "R-CMD-check.html#namespace",
    "href": "R-CMD-check.html#namespace",
    "title": "Appendix A — R CMD check",
    "section": "A.4 Namespace",
    "text": "A.4 Namespace\n\n\nChecking if there is a namespace. You must have a NAMESPACE file. This is handled for your automatically by the devtools workflow.\n\n\n\nChecking package namespace information. The NAMESPACE should be parseable by parseNamespaceFile() and valid. If this check fails, it’s a bug in roxygen2.\n\n\n\nChecking whether the package can be loaded with stated dependencies. Runs library(pkg) with R_DEFAULT_PACKAGES=NULL, so the search path is empty (i.e. stats, graphics, grDevices, utils, datasets and methods are not attached like usual). Failure here typically indicates that you’re missing a dependency on one of those packages.\n\n\n\nChecking whether the namespace can be loaded with stated dependencies. Runs loadNamespace(pkg) with R_DEFAULT_PACKAGES=NULL. Failure usually indicates a problem with the namespace."
  },
  {
    "objectID": "R-CMD-check.html#r-code",
    "href": "R-CMD-check.html#r-code",
    "title": "Appendix A — R CMD check",
    "section": "A.5 R code",
    "text": "A.5 R code\n\n\nChecking R files for non-ASCII characters. For maximum portability (i.e. so people can use your package on Windows) you should avoid using non-ASCII characters in R files. It’s ok to use them in comments, but object names shouldn’t use them, and in strings you should use unicode escapes. See the CRAN-specific notes in ?sec-code for more details.\n\n\n\nChecking R files for syntax errors. Obviously your R code must be valid. You’re unlikely to see this error if you’ve been regularly using devtools::load_all().\n\n\n\nChecking dependencies in R code. Errors here often indicate that you’ve forgotten to declare a needed package in the DESCRIPTION. Remember that you should never use require() or library() inside a package - see Section 9.6, Chapter 10, and Chapter 11 for more details on best practices.\nAlternatively, you may have accidentally used ::: to access an exported function from a package. Switch to :: instead.\n\n\n\nChecking S3 generic/method consistency. S3 methods must have a compatible function signature with their generic. This means that the method must have the same arguments as its generic, with one exception: if the generic includes ... the method can have additional arguments.\nA common cause of this error is defining print methods, because the print() generic contains...:\n\n# BAD\nprint.my_class <- function(x) cat(\"Hi\")\n\n# GOOD\nprint.my_class <- function(x, ...) cat(\"Hi\")\n\n# Also ok\nprint.my_class <- function(x, ..., my_arg = TRUE) cat(\"Hi\")\n\n\n\n\nChecking replacement functions. Replacement functions (e.g. functions that are called like foo(x) <- y), must have value as the last argument.\n\n\n\nChecking R code for possible problems. This is a compound check for a wide range of problems:\n\nCalls to library.dynam() (and library.dynam.unload()) should look like library.dynam(\"name\"), not library.dynam(\"name.dll\"). Remove the extension to fix this error.\nPut library.dynam() in .onLoad(), not .onAttach(); put packageStartupMessage() in .onAttach(), not .onLoad(). Put library.dynam.unload() in .onUnload(). If you use any of these functions, make sure they’re in the right place.\nDon’t use unlockBinding() or assignInNamespace() to modify objects that don’t belong to you.\ncodetools::checkUsagePackage() is called to check that your functions don’t use variables that don’t exist. This sometimes raises false positives with functions that use non-standard evaluation (NSE), like subset() or with(). Generally, we think you should avoid NSE in package functions, and hence avoid this NOTE, but if you can not, see ?globalVariables for how to suppress this NOTE.\nYou are not allowed to use .Internal() in a package. Either call the R wrapper function, or write your own C function. (If you copy and paste the C function from base R, make sure to maintain the copyright notice, use a GPL-2 compatible license, and list R-core in the Authors@R field.)\nSimilarly you are not allowed to use ::: to access non-exported functions from other packages. Either ask the package maintainer to export the function you need, or write your own version of it using exported functions. Alternatively, if the licenses are compatible you can copy and paste the exported function into your own package. If you do this, remember to update Authors@R.\nDon’t use assign() to modify objects in the global environment. If you need to maintain state across function calls, create your own environment, as described in Section 7.4.\nDon’t use attach() in your code. Instead refer to variables explicitly.\nDon’t use data() without specifying the envir argument. Otherwise the data will be loaded in the global environment.\nDon’t use deprecated or defunct functions. Update your code to use the latest versions.\nYou must use TRUE and FALSE in your code (and examples), not T and F.\n\n\n\n\nChecking whether the package can be loaded. R loads your package with library(). Failure here typically indicates a problem with .onLoad() or .onAttach().\n\n\n\nChecking whether the package can be unloaded cleanly. Loads with library() and then detach()es. If this fails, check .onUnload() and .onDetach().\n\n\n\nChecking whether the namespace can be unloaded cleanly. Runs loadNamespace(\"pkg\"); unloadNamespace(\"pkg\"). Check .onUnload() for problems.\n\n\n\nChecking loading without being on the library search path. Calls library(x, lib.loc = ...). Failure here indicates that you are making a false assumption in .onLoad() or .onAttach()."
  },
  {
    "objectID": "R-CMD-check.html#data",
    "href": "R-CMD-check.html#data",
    "title": "Appendix A — R CMD check",
    "section": "A.6 Data",
    "text": "A.6 Data\n\n\nChecking contents of ‘data’ directory.\n\nThe data directory can only contain file types described in Section 7.1.\nData files can contain non-ASCII characters only if the encoding is correctly set. This usually shouldn’t be a problem if you’re saving .Rdata files. If you do see this error, look at the Encoding() of each column in the data frame, and ensure none are “unknown”. (You’ll typically need to fix this somewhere in the import process). Learn more in Section 7.1.3.\nIf you’ve compressed a data file with bzip2 or xz you need to declare at least Depends: R (>= 2.10) in your DESCRIPTION.\nIf you’ve used a sub-optimal compression algorithm for your data, re-compress with the suggested algorithm."
  },
  {
    "objectID": "R-CMD-check.html#documentation",
    "href": "R-CMD-check.html#documentation",
    "title": "Appendix A — R CMD check",
    "section": "A.7 Documentation",
    "text": "A.7 Documentation\nIf you’re grappling with documentation problems specifically, you may be able to iterate more quickly by using devtools::check_man(), which attempts to run only the relevant subset of checks. It also automatically calls devtools::document() for you.\n\n\nChecking Rd files. This checks that all man/*.Rd files use the correct Rd syntax. If this fails, it indicates a bug in roxygen2.\n\n\n\nChecking Rd metadata. Names and aliases must be unique across all documentation files in a package. If you encounter this problem you’ve accidentally used the same @name or @aliases in multiple places; make sure they’re unique.\n\n\n\nChecking Rd line widths. Lines in Rd files must be less than 90 characters wide. This is unlikely to occur if you wrap your R code, and hence roxygen comments, to 80 characters. For very long URLs, use a link-shortening service like bit.ly.\n\n\n\nChecking Rd cross-references. Errors here usually represent typos.\n\n\n\nChecking for missing documentation entries. All exported objects must be documented. See ?tools::undoc for more details.\n\n\n\nChecking for code/documentation mismatches. This check ensures that the documentation matches the code. This should never fail because you’re using roxygen2 which automatically keeps them in sync and check() should usually re-document() your package. In any case, the solution is often to re-run devtools::document().\n\n\n\nChecking Rd \\usage sections. All arguments must be documented, and all @params must document an existing argument. You may have forgotten to document an argument, forgotten to remove the documentation for an argument that you’ve removed, or misspelled an argument name.\nS3 and S4 methods need to use special \\S3method{} and \\S4method{} markup in the Rd file. Roxygen2 will generate this for you automatically.\n\n\n\nChecking Rd contents. This checks for auto-generated content made by package.skeleton(). Since you’re not using package.skeleton() you should never have a problem here.\n\n\n\nChecking for unstated dependencies in examples. If you use a package only for an example, make sure it’s listed in the Suggests field. Learn more about how to use different types of dependencies in your examples in Chapter 11.\n\n\n\nChecking examples. Every documentation example must run without errors, and must not take too long. See Section 16.5 for details.\n\n\n\nChecking PDF version of manual. Occasionally you’ll get an error when building the PDF manual. This is usually because the pdf is built by latex and you’ve forgotten to escape something. Debugging this is painful - your best bet is to look up the latex logs and combined tex file and work back from there to .Rd files then back to a roxygen comment. Any such failure is potentially a bug in roxygen2, so open an issue."
  },
  {
    "objectID": "R-CMD-check.html#demos",
    "href": "R-CMD-check.html#demos",
    "title": "Appendix A — R CMD check",
    "section": "A.8 Demos",
    "text": "A.8 Demos\n\n\nChecking index information. If you’ve written demos, each demo must be listed in demo/00Index. The file should look like:\ndemo-name-without-extension  Demo description\nanother-demo-name            Another description"
  },
  {
    "objectID": "R-CMD-check.html#compiled-code",
    "href": "R-CMD-check.html#compiled-code",
    "title": "Appendix A — R CMD check",
    "section": "A.9 Compiled code",
    "text": "A.9 Compiled code\n\n\nChecking foreign function calls. .Call(), .C(), .Fortran(), .External() must always be called either with a NativeSymbolInfo object (as created with @useDynLib) or use the .package argument. See ?tools::checkFF for more details.\n\n\n\nChecking line endings in C/C++/Fortran sources/headers. Always use LF as a line ending.\n\n\n\nChecking line endings in Makefiles. As above.\n\n\n\nChecking for portable use of $(BLAS_LIBS) and $(LAPACK_LIBS). Errors here indicate an issue with your use of BLAS and LAPACK.\n\n\n\nChecking compiled code. Checks that you’re not using any C functions that you shouldn’t."
  },
  {
    "objectID": "R-CMD-check.html#tests",
    "href": "R-CMD-check.html#tests",
    "title": "Appendix A — R CMD check",
    "section": "A.10 Tests",
    "text": "A.10 Tests\n\n\nChecking for unstated dependencies in tests. Every package used by tests must be included in the dependencies.\n\n\n\nChecking tests. Each file in tests/ is run. If you’ve followed the instructions in Chapter 13 you’ll have at least one file: testthat.R. The output from R CMD check is not usually that helpful, so you may need to look at the log file package.Rcheck/tests/testthat.Rout. Fix any failing tests by iterating with devtools::test().\nOccasionally you may have a problem where the tests pass when run interactively with devtools::test(), but fail when in R CMD check. This usually indicates that you’ve made a faulty assumption about the testing environment, and it’s often hard to figure it out."
  },
  {
    "objectID": "R-CMD-check.html#vignettes",
    "href": "R-CMD-check.html#vignettes",
    "title": "Appendix A — R CMD check",
    "section": "A.11 Vignettes",
    "text": "A.11 Vignettes\nThis is a tricky enough topic that it also receives substantial coverage in the main body of the book; see Section 17.5.\n\n\nChecking ‘build’ directory. build/ is used to track vignette builds. It’s hard to imagine how this check could fail unless you’ve accidentally .Rbuildignored the build/ directory.\n\n\n\nChecking installed files from ‘inst/doc’. Don’t put files in inst/doc - keep your vignettes and the files they need in vignettes/.\n\n\n\nChecking files in ‘vignettes’. Problems here are usually straightforward - you’ve included files that are already included in R (like jss.cls, jss.bst, or Sweave.sty), or you have leftover latex compilation files. Delete these files.\n\n\n\nChecking for sizes of PDF files under ‘inst/doc’. If you’re making PDF vignettes, you can make them as small as possible by running tools::compactPDF().\n\n\n\nChecking for unstated dependencies in vignettes. As with tests, every package that you use in a vignette must be listed in the DESCRIPTION. If a package is used only for a vignette, and not elsewhere, make sure it’s listed in Suggests. If you really want to use a package and you don’t want to list it in DESCRIPTION, write an article instead of a vignette.\n\n\n\nChecking package vignettes in ‘inst/doc’. This checks that every source vignette (i.e. .Rmd) has a built equivalent (i.e. .html) in inst/doc. This shouldn’t fail if you’ve used the standard process outlined in Chapter 17. If there is a problem, start by checking your .Rbuildignore.\n\n\n\nChecking running R code from vignettes. The R code from each vignette is run. If you want to deliberately execute errors (to show the user what failure looks like), make sure the chunk has error = TRUE, purl = FALSE.\n\n\n\nChecking re-building of vignette outputs. Each vignette is re-knit to make sure that the output corresponds to the input. Again, this shouldn’t fail in normal circumstances."
  },
  {
    "objectID": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "href": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "title": "Appendix A — R CMD check",
    "section": "A.12 NOTEs that are informational",
    "text": "A.12 NOTEs that are informational\nOur blanket advice is to eliminate all ERRORs, WARNINGs, and even NOTEs that you see in R CMD check. But there are a few exceptions, i.e. there are a couple of NOTEs that do you not need to fix (and, indeed, probably can not fix).\n\nA.12.1 Initial CRAN submission\nWhen a package first goes to CRAN, there will always be one NOTE that alerts the CRAN maintainers that this is a new submission and that they’ll need to do some extra checks. You can’t eliminate this NOTE.\n* checking CRAN incoming feasibility ... NOTE\nMaintainer: 'Jane Doe <jane@example.com>'\n\nNew submission\n\n\nA.12.2 Non-ASCII characters in data\nIf your package’s data contains non-ASCII characters, you will get a NOTE like this, but it does not necessarily mean you need to do anything about it.\nCheck: data for non-ASCII characters\nResult: NOTE\n     Note: found 25 marked UTF-8 strings\nAs long as you are aware of the non-ASCII characters and the NOTE mentions your intended and declared encoding (preferably UTF-8), all is well.\n\n\nA.12.3 Rd cross-references\nIf your roxygen comments contain a cross-reference to a package that is not a formal, direct dependency, you might see a NOTE like this:\nCheck: Rd cross-references\nResult: NOTE\n    Undeclared package ‘jsonlite’ in Rd xrefs\nThis could happen if you want to document something related to a hard indirect dependency: There’s a legitimate reason to link to a topic in the other package and it is basically guaranteed to be installed. Therefore, in practice, often more good than harm comes from the cross-reference.\nIn our experience, this NOTE is only seen on certain CRAN check flavors and not others. Thus far, we have never been directed to address this NOTE by CRAN maintainers."
  },
  {
    "objectID": "whole-game.html#load-devtools-and-friends",
    "href": "whole-game.html#load-devtools-and-friends",
    "title": "1  The Whole Game",
    "section": "\n1.1 Load devtools and friends",
    "text": "1.1 Load devtools and friends\n您可以从任何活动的 R 会话启动你的新包。 您无需担心您是否处于现有项目或新项目中。 我们使用的函数确保我们为包创建一个新的干净项目。\n加载 devtools 包，它是一组支持包开发各个方面的包的公共面孔。 其中最明显的是 usethis 包，您将看到它也正在加载。\n\nlibrary(devtools)\n#> Warning: package 'devtools' was built under R version 4.2.3\n#> Loading required package: usethis\n#> Warning: package 'usethis' was built under R version 4.2.3\n\n你有旧版本的 devtools 吗？ 将您的版本与我们的版本进行比较，并在必要时进行升级。\n\npackageVersion(\"devtools\")\n#> [1] '2.4.5'"
  },
  {
    "objectID": "whole-game.html#toy-package-regexcite",
    "href": "whole-game.html#toy-package-regexcite",
    "title": "1  The Whole Game",
    "section": "\n1.2 Toy package: regexcite",
    "text": "1.2 Toy package: regexcite\n为了帮助您完成整个过程，我们使用 devtools 中的各种函数从头开始构建一个小玩具包，具有已发布包中常见的功能：\n\n满足特定需求的函数，在本例中是使用正则表达式的助手。\n版本控制和开放的开发过程。\n\n这在您的工作中是完全可选的，但强烈推荐。您将看到 Git 和 GitHub 如何帮助我们公开玩具包的所有中间阶段。\n\n\n访问已建立的安装工作流程、获得帮助和检查质量。\n\n通过 roxygen2 的各个功能的文档。\n使用 testthat 进行单元测试。\n通过可执行文件 README.Rmd 获取整个包的文档。\n\n\n\n我们称这个包为 regexcite，它包含几个函数，可以使使用正则表达式的常见任务变得更容易。 请注意，这些功能非常简单，我们在这里仅将它们用作指导您完成包开发过程的一种方式。 如果您正在寻找使用正则表达式的实际帮助程序，有几个合适的 R 包可以解决这个问题：\n\n\nstringr (which uses stringi)\nstringi\nrex\nrematch2\n\n同样，regexcite 包本身只是一个用于演示使用 devtools 进行包开发的典型工作流程的工具。"
  },
  {
    "objectID": "whole-game.html#preview-the-finished-product",
    "href": "whole-game.html#preview-the-finished-product",
    "title": "1  The Whole Game",
    "section": "\n1.3 Preview the finished product",
    "text": "1.3 Preview the finished product\nregexcite 包在其开发过程中使用 Git 版本控制系统进行跟踪。 这完全是可选的，您当然可以在不实现它的情况下进行。 一个很好的附带好处是我们最终将它连接到 GitHub 上的远程存储库，这意味着您可以通过访问 GitHub 上的 regexcite 看到我们正在努力取得的辉煌成果：https://github.com/jennybc/regexcite。 通过检查 commit history，尤其是 diffs，您可以准确地看到在下面列出的过程的每个步骤中发生了什么变化。"
  },
  {
    "objectID": "whole-game.html#create_package",
    "href": "whole-game.html#create_package",
    "title": "1  The Whole Game",
    "section": "\n1.4 create_package()\n",
    "text": "1.4 create_package()\n\n调用 create_package() 在计算机上的目录中初始化一个新包。 create_package() 将自动创建该目录，如果该目录尚不存在（通常是这种情况）。 关于更多创建包的信息，请参见 Section 4.1。\n慎重选择在您的计算机上创建此包的位置。 它可能应该在您的主目录中的某个位置，与您的其他 R 项目一起。 它不应嵌套在另一个 RStudio Project、R package 或 Git repo 中。 它也不应该在 R package library 中，它包含已经构建和安装的包。 将我们在此处创建的源码包转换为已安装的包是 devtools 的一部分。 不要试图为它做 devtools 的工作！\n一旦您选择了创建此包的位置，请将您选择的路径替换为 create_package() 调用，如下所示：\n\ncreate_package(\"~/path/to/regexcite\")\n\n为了创建这本书，我们必须在一个临时目录中工作，因为这本书是在云端以非交互方式构建的。 在幕后，我们正在执行自己的 create_package() 命令，但如果我们的输出与您的略有不同，请不要感到惊讶。\n\n#> ✔ Creating 'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite/'\n#> ✔ Setting active project to 'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite'\n#> ✔ Creating 'R/'\n#> ✔ Writing 'DESCRIPTION'\n#> Package: regexcite\n#> Title: What the Package Does (One Line, Title Case)\n#> Version: 0.0.0.9000\n#> Authors@R (parsed):\n#>     * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\n#> Description: What the package does (one paragraph).\n#> License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n#>     license\n#> Encoding: UTF-8\n#> Roxygen: list(markdown = TRUE)\n#> RoxygenNote: 7.2.3\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Writing 'regexcite.Rproj'\n#> ✔ Adding '^regexcite\\\\.Rproj$' to '.Rbuildignore'\n#> ✔ Adding '.Rproj.user' to '.gitignore'\n#> ✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n#> ✔ Setting active project to '<no active project>'\n\n如果您在 RStudio 中工作，您应该会发现自己在 RStudio 的一个新实例中，打开到您的新 regexcite package（and Project）中。 如果您不知何故需要手动执行此操作，请导航到目录并双击 regexcite.Rproj。 RStudio 对包有特殊处理，您现在应该在与环境（Environment）和历史记录（History）相同的窗格中看到构建（Build）选项卡。\n您可能需要再次调用 library(devtools)，因为 create_package() 可能已将您带入新包中的新 R 会话。\n\nlibrary(devtools)\n\n这个新目录中有什么，它也是一个 R 包，并且可能是一个 RStudio Project？ 这是一个清单（在本地，您可以查阅 Files 窗格）：\n\n\n\n\npath\ntype\n\n\n\n.gitignore\nfile\n\n\n.Rbuildignore\nfile\n\n\nDESCRIPTION\nfile\n\n\nNAMESPACE\nfile\n\n\nR\ndirectory\n\n\nregexcite.Rproj\nfile\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\n在 Files 窗格中，转到 More (gear symbol) > Show Hidden Files 以切换隐藏文件（又名 “dotfiles”）的可见性。 始终可以看到少数几个，但有时您希望看到所有这些。\n\n\n\n\n.Rbuildignore 列出了我们需要保留但在从源代码构建 R 包时不应包含的文件。 如果您不使用 RStudio，create_package() 一开始可能不会创建此文件（也不会创建 .gitignore），因为没有需要忽略的与 RStudio 相关的机制。 但是，无论您使用什么编辑器，您都可能在某个时候需要 .Rbuildignore。 Section 3.3.1 对此进行了更详细的讨论。\n\n.Rproj.user, 如果有的话，它是 RStudio 内部使用的目录。\n\n.gitignore 为 Git 的使用做好准备，它将忽略一些由 R 或 RStudio 创建的标准的幕后文件。 即使您不打算使用 Git，它也是没有害处的。\n\nDESCRIPTION 提供有关您的包的 metadata。 我们很快将开始编写它，Chapter 9 涵盖了 DESCRIPTION 文件的一般主题。\n\nNAMESPACE 声明了程序包导出以供外部使用的函数以及程序包从其他包导入的外部函数。 现在，除了一个注释声明这是一个我们不会手工编辑的文件外，它是空的。\n\nR/ 目录是程序包的“业务端”。 它很快将包含带有函数声明的 .R 文件。\n\nregexcite.Rproj 是使此目录成为 RStudio Project 的文件。 即使您不使用 RStudio，此文件也是无害的。 或者，您可以通过 create_package(..., rstudio = FALSE) 来禁止其创建。 更多内容请参见 Section 4.2。"
  },
  {
    "objectID": "whole-game.html#use_git",
    "href": "whole-game.html#use_git",
    "title": "1  The Whole Game",
    "section": "\n1.5 use_git()\n",
    "text": "1.5 use_git()\n\nregexcite 目录是一个 R source package 和一个 RStudio Project。 现在我们使用 use_git() 将它也变成一个 Git repository。 （顺便说一下，use_git() 适用于任何项目，无论它是否是 R 包。）\n\nuse_git()\n#> ✔ Initialising Git repo\n#> ✔ Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\n\n在交互式会话中，系统将询问您是否要在此处提交（commit）这些文件，您应该接受这个提议。 在幕后，我们还将提交（commit）这些相同的文件。\n那么这个包有什么变化呢？ 仅仅是创建了 .git 目录，该目录在大多数环境中都是隐藏的，包括 RStudio 文件浏览器。 但是它的存在证明我们确实在这里初始化了 Git repo。\n\n\n\n\npath\ntype\n\n\n.git\ndirectory\n\n\n\n\n如果您使用的是 RStudio，它可能会请求在此项目中重新启动。 您可以通过退出手动执行此操作，然后双击 regexcite.Rproj 重新启动 RStudio。 现在，除了包开发支持之外，您还可以在 Environment/History/Build 窗格的 Git 选项卡中访问基本的 Git 客户端。\n\n单击 History （时钟图标），如果您愿意，您将看到通过 use_git() 进行的初始提交（initial commit）：\n\n\n\n\ncommit\nauthor\nmessage\n\n\n9c6a0fbb2b…\nzhenghu 1308155474@qq.com\n\nInitial commit\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\n只要您设置了 RStudio + Git 集成，RStudio 可以在任何项目中初始化 Git repository，即使它不是 R 包项目。 依次点击 Tools > Version Control > Project Setup。 然后选择 Version control system: Git 和 initialize a new git repository for this project。"
  },
  {
    "objectID": "whole-game.html#write-the-first-function",
    "href": "whole-game.html#write-the-first-function",
    "title": "1  The Whole Game",
    "section": "\n1.6 Write the first function",
    "text": "1.6 Write the first function\n处理字符串时一个相当常见的任务是需要将单个字符串拆分成多个部分。 base R 中的 strsplit() 函数就是这样做的。\n\n(x <- \"alfa,bravo,charlie,delta\")\n#> [1] \"alfa,bravo,charlie,delta\"\nstrsplit(x, split = \",\")\n#> [[1]]\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n仔细查看返回值。\n\nstr(strsplit(x, split = \",\"))\n#> List of 1\n#>  $ : chr [1:4] \"alfa\" \"bravo\" \"charlie\" \"delta\"\n\n这个返回值的形状常常让人们感到惊讶，或者至少让他们感到不便。 输入是长度为 1 的字符向量，输出是长度为 1 的列表。 鉴于 R 的矢量化基本趋势，这是完全有道理的。 但有时它仍然有点无赖。 通常你知道你的输入是一个标量，即它只是一个字符串，并且真的希望输出是它的部分的字符向量。\n这导致 R 用户采用各种 “unlist”-ing 结果的方法：\n\nunlist(strsplit(x, split = \",\"))\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nstrsplit(x, split = \",\")[[1]]\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n第二种更安全的解决方案是 regexcite 的初始函数的基础：strsplit1()。\n\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n本书不教你如何在 R 中编写函数。 如果想了解更多，请参阅 R for Data Science 的 Functions chapter 和 Advanced R 的 Functions chapter。\n\n\n\n\n\n\nTip\n\n\n\nstrsplit1() 的名称是对非常方便的 paste0() 的致敬，它于 2012 年首次出现在 R 2.15.0 中。 创建 paste0() 是为了解决将字符串粘贴在一起的极其常见的用例，而无需使用分隔器。 paste0() 被亲切地描述为 “statistical computing’s most influential contribution of the 21st century”。\nstrsplit1() 函数非常鼓舞人心，它现在是 stringr 包中的一个真正的函数：stringr::str_split_1()！"
  },
  {
    "objectID": "whole-game.html#use_r",
    "href": "whole-game.html#use_r",
    "title": "1  The Whole Game",
    "section": "\n1.7 use_r()\n",
    "text": "1.7 use_r()\n\n你应该把 strsplit1() 的定义放在哪里？ 将其保存在包的 R/ 子目录中的 .R 文件中。 一个合理的起点是为包中每个面向用户的函数创建一个新的 .R 文件，并以函数命名文件。 随着添加更多函数，您会想要放松这一点，并开始将相关功能分组在一起。 我们将把 strsplit1() 的定义保存在文件 R/strsplit1.R 中。\n函数 use_r() 将帮助我们在 R/ 目录下创建或打开一个脚本文件。 当您在 .R 文件和关联测试的文件之间互相切换时，它确实在成熟的程序包中十分有用。 但是，即使在这里，在 Untitled4 中工作时，它也可以避免您因为太投入而忘记了当前工作的目录。\n\nuse_r(\"strsplit1\")\n#> • Edit 'R/strsplit1.R'\n\n将 strsplit1() 的定义放入 R/strsplit1.R 中，并保存。 文件 R/strsplit1.R 不应包含我们最近执行的任何其他顶级代码，例如练习输入 x 的定义、library(devtools) 或 use_git()。 这预示着您在从编写 R scripts 转换为编写 R packages 时需要进行调整。 Packages 和 scripts 使用不同的机制来声明它们对其他软件包的依赖关系以及存储示例或测试代码。 我们将在 Chapter 6 进一步探讨这个问题。"
  },
  {
    "objectID": "whole-game.html#sec-whole-game-load-all",
    "href": "whole-game.html#sec-whole-game-load-all",
    "title": "1  The Whole Game",
    "section": "\n1.8 load_all()\n",
    "text": "1.8 load_all()\n\n我们如何测试 strsplit1()？ 如果这是一个普通的 R 脚本，我们可能会使用 RStudio 将函数定义发送到 R 控制台并在全局环境中定义 strsplit1()。 或者也许我们会调用 source(\"R/strsplit1.R\")。 然而，对于包开发，devtools 提供了一种更强大的方法。\n调用 load_all() 函数以便可以使用 strsplit1() 进行实验。\n\nload_all()\n#> ℹ Loading regexcite\n\n现在调用 strsplit1(x) 看看它是如何工作的。\n\n(x <- \"alfa,bravo,charlie,delta\")\n#> [1] \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n请注意，load_all() 函数已经使得 strsplit1() 函数可用，尽管它并不存在于全局环境中。\n\nexists(\"strsplit1\", where = globalenv(), inherits = FALSE)\n#> [1] FALSE\n\n如果你看到的是 TRUE 而不是 FALSE，那说明你仍在使用基于脚本的工作流并获取函数。 以下是如何重新回到正轨：\n\n清空全局环境并重新启动 R。\n使用 library(devtools) 重新附加 devtools，然后用 load_all() 重新加载 regexcite。\n重新定义测试输入 x，并再次调用 strsplit1(x, split = \",\")。这应该可以工作！\n再次运行 exists(\"strsplit1\", where = globalenv(), inherits = FALSE)，你应该会看到 FALSE。\n\nload_all() 函数模拟了构建（building）、安装（installing）、附加（attaching） regexcite 包的过程。 随着您的软件包积累更多的功能，一些被导出（exported），一些不是，有些调用彼此，有些调用依赖于其他软件包的函数，在全局环境中定义函数进行测试驱动比起使用 load_all() 来说并不能给您一个更准确地感知软件包正在如何开发。 而且 load_all() 允许比实际构建、安装和附加软件包更快速地迭代。 请参见 Section 4.4 以获取有关 load_all() 的更多信息。\n回顾一下我们到目前为止所做的事情：\n\n我们编写了第一个函数，strsplit1()，将字符串拆分成字符向量（而不是包含字符向量的列表）。\n我们使用 load_all() 快速使该函数可供交互式使用，就像我们构建并安装了 regexcite，并通过 library(regexcite) 附加它一样。\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单提供了 load_all() 的快速调用。它位于 Build 窗格中，通过 More > Load All 或者键盘快捷键 Ctrl + Shift + L (WIndows & Linux) 或者 Cmd + Shift + L (macOS) 调用。\n\n\n\n1.8.1 Commit strsplit1()\n\n如果您正在使用 Git，请使用您喜欢的方法提交新的 R/strsplit1.R 文件。 我们在幕后也是这样做的，以下是提交前后相关的差异。\n\ndiff --git a/R/strsplit1.R b/R/strsplit1.R\nnew file mode 100644\nindex 0000000..29efb88\n--- /dev/null\n+++ b/R/strsplit1.R\n@@ -0,0 +1,3 @@\n+strsplit1 <- function(x, split) {\n+  strsplit(x, split = split)[[1]]\n+}\n\n从这一小节之后，我们每一步之后都会进行提交（commit）。 请记住，these commits 可在公共存储库中找到。"
  },
  {
    "objectID": "whole-game.html#check",
    "href": "whole-game.html#check",
    "title": "1  The Whole Game",
    "section": "\n1.9 check()\n",
    "text": "1.9 check()\n\n我们有经验可以证明 strsplit1() 是有效的。 但是，我们如何确保 regexcite 软件包的所有组成部分仍然有效？ 尽管这只是一个小改动，但检查一下还是很好的习惯。\n在 shell 中执行 R CMD check 是检查 R 软件包是否完全正常工作的黄金标准。 在不离开 R 会话的情况下，check() 是运行这个命令的便捷方法。\n请注意，check() 将生成相当多的输出，并针对交互式使用进行了优化。 我们在这里截取了一部分，并仅仅展示摘要。 本地运行 check() 的输出将有所不同。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 36.8s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n0 errors ✔ | 1 warning ✖ | 0 notes ✔\n\n阅读 check 的输出非常重要！ 尽可能早并经常性的解决出现的问题。 就像在 .R 和 .Rmd 文件上的增量开发一样，你越久不进行全面检查，找到并解决问题就会变得越困难。\n此时，我们预计有 1 warning（and 0 errors, 0 notes）：\nNon-standard license specification:\n  `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n  license\n我们很快就会解决这个问题，方法就是按照它所说的去做。 你可以在 Section 4.5 中了解更多关于 check() 的内容。\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单提供了 check() 的快速调用，它位于 Build 窗格中，通过 Check 或者键盘快捷键 Ctrl + Shift + E (WIndows & Linux) 或者 Cmd + Shift + E (MacOS) 调用。"
  },
  {
    "objectID": "whole-game.html#edit-description",
    "href": "whole-game.html#edit-description",
    "title": "1  The Whole Game",
    "section": "\n1.10 Edit DESCRIPTION\n",
    "text": "1.10 Edit DESCRIPTION\n\nDESCRIPTION 文件提供有关您的软件包的 metadata，并在 Chapter 9 中进行了全面介绍。 现在是查看 regexcite 当前 DESCRIPTION 的好时机。 您会发现它填充了样板内容，需要替换掉。\n要添加自己的 metadata，请进行以下编辑：\n\n将自己设置为 author。如果您没有 ORCID，则可以省略 comment = ... 部分。\n在 Title 和 Description 字段中编写一些描述性文本。\n\n\n\n\n\n\n\nRStudio\n\n\n\n在 RStudio 中可以使用 Ctrl + . 并键入 “DESCRIPTION” 来激活一个帮助程序，这样您可以轻松地打开该文件并编辑。 除了可以键入文件名外，还可以是函数名。 当一个包有很多文件时，这非常方便。\n\n\n当您完成后，DESCRIPTION 文件应该看起来像这样：\n\n\n\nPackage: regexcite\nTitle: Make Regular Expressions More Exciting\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"Jane\", \"Doe\", , \"jane@example.com\", role = c(\"aut\", \"cre\"))\nDescription: Convenience functions to make some common tasks with string\n    manipulation and regular expressions a bit easier.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.2"
  },
  {
    "objectID": "whole-game.html#use_mit_license",
    "href": "whole-game.html#use_mit_license",
    "title": "1  The Whole Game",
    "section": "\n1.11 use_mit_license()\n",
    "text": "1.11 use_mit_license()\n\n\nPick a License, Any License. – Jeff Atwood\n\n我们目前在 DESCRIPTION 的 License 字段中有一个占位符，它故意无效并建议解决方案。\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n要为包配置有效许可证（license），请调用 use_mit_license()。\n\nuse_mit_license()\n#> ✔ Adding 'MIT + file LICENSE' to License\n#> ✔ Writing 'LICENSE'\n#> ✔ Writing 'LICENSE.md'\n#> ✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\n这将正确配置 MIT license 的 License 字段，该许可证（license）承诺在 LICENSE 文件中命名版权持有人和年份。 打开新创建的 LICENSE 文件并确认它看起来像这样：\n\nYEAR: 2023\nCOPYRIGHT HOLDER: regexcite authors\n\n与其他许可证助手一样，use_mit_license() 函数还将完整的许可证副本放入 LICENSE.md 文件中，并将该文件添加到 .Rbuildignore 中。 最好的做法是使程序包的源代码中包含完整的许可证，例如在 GitHub 上，但 CRAN 不允许在软件包 tarball 中包含此文件。 您可以在 Chapter 12 了解更多有关许可证方面的信息。"
  },
  {
    "objectID": "whole-game.html#sec-whole-game-document",
    "href": "whole-game.html#sec-whole-game-document",
    "title": "1  The Whole Game",
    "section": "\n1.12 document()\n",
    "text": "1.12 document()\n\n如果我们能像其他 R 函数一样获得 strsplit1() 的帮助文档，那不是很好吗？ 这需要您的包有一个特殊的 R 文档文件 man/strsplit1.Rd，它使用类似于 LaTeX 的 R 特殊标记语言编写。 幸运的是，我们不一定要直接编写该文件。\n我们在源代码文件中的 strsplit1() 函数体上直接编写一个特别格式的注释，然后让名为 roxygen2 的软件包处理 man/strsplit1.Rd 的创建工作。 roxygen2 的使用和机制在 Chapter 16 中介绍。\n如果您使用 RStudio，请在源码编辑器中打开 R/strsplit1.R，并将光标放置在 strsplit1() 函数定义中的某处。 现在点击 Code > Insert roxygen skeleton。 函数上方应该会出现一个非常特殊的注释模板，每行以 #' 开头。 RStudio 只插入了模板框架，因此您需要对其进行编辑。\n如果您没有使用 RStudio，则自己创建该注释即可。 无论如何，都应修改它使其看起来像下面这样：\n\n#' Split a string\n#'\n#' @param x A character vector with one element.\n#' @param split What to split on.\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' strsplit1(x, split = \",\")\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n\n但我们还没有完成！ 我们仍然需要使用 document() 触发将这个新的 roxygen 注释转换为 man/strsplit1.Rd：\n\ndocument()\n#> ℹ Updating regexcite documentation\n#> Setting `RoxygenNote` to \"7.2.3\"\n#> ℹ Loading regexcite\n#> Writing 'NAMESPACE'\n#> Writing 'strsplit1.Rd'\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单提供了 document() 的快速调用。 它位于 Build 窗格中，通过 More > Document 或者键盘快捷键 Ctrl + Shift + D (WIndows & Linux) 或者 Cmd + Shift + D (MacOS) 调用。\n\n\n您现在应该能够像这样预览您的帮助文件：\n\n?strsplit1\n\n您将看到一条消息，如 “Rendering development documentation for ‘strsplit1’”，这提醒你基本上是在预览草稿文档。 也就是说，这份文档存在于你的软件包源代码中，但尚未出现在已安装的软件包中。 实际上，我们还没有安装 regexcite，但很快就会安装。 如果 ?strplit 对您不起作用，则可能需要先调用 load_all()，然后再重试。\n另请注意，在正式构建和安装软件包之前，您的程序包的文档不会被正确连接。 这样可以改善一些细微之处，例如帮助文档之间的链接和程序包索引的创建。\n\n1.12.1 NAMESPACE changes\n除了将 strsplit1() 的特殊注释转换为 man/strsplit1.Rd 之外，对 document() 的调用还会根据 roxygen 注释中找到的 @export 标签更新 NAMESPACE 文件。 打开 NAMESPACE 进行检查。 其内容应该是：\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(strsplit1)\n\nNAMESPACE 中的 export 指令是使得 strsplit1() 函数可以在通过 library(regexcite) 加载 regexcite 后对用户可用。 就像可以手动编写 .Rd 文件一样，您也可以自己明确地管理 NAMESPACE。 但我们选择将此委托给 devtools（和 roxygen2）。"
  },
  {
    "objectID": "whole-game.html#check-again",
    "href": "whole-game.html#check-again",
    "title": "1  The Whole Game",
    "section": "\n1.13 check() again",
    "text": "1.13 check() again\nregexcite 现在和以后都应该能够通过 R CMD check：0 errors, 0 warnings, 0 notes。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 30.5s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔"
  },
  {
    "objectID": "whole-game.html#install",
    "href": "whole-game.html#install",
    "title": "1  The Whole Game",
    "section": "\n1.14 install()\n",
    "text": "1.14 install()\n\n由于我们现在已经有了一个最小的完整可行的产品，让我们通过 install() 将 regexcite 包安装到您的库中：\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/1.study/R/R-4.2.0/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/1.study/R/R-4.2.0/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单和 Build 窗格提供了类似的功能，通过 Install and Restart 调用。 快捷键 Ctrl + Shift + B（Windows 和 Linux）或 Cmd + Shift + B（macOS）。\n\n\n安装完成后，我们可以像任何其他包一样添加和使用 regexcite。 让我们从头回顾一下我们的小例子。 这是重新启动 R 会话（R Session）并清理工作区的好时机。\n\nlibrary(regexcite)\n\nx <- \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nSuccess!"
  },
  {
    "objectID": "whole-game.html#use_testthat",
    "href": "whole-game.html#use_testthat",
    "title": "1  The Whole Game",
    "section": "\n1.15 use_testthat()\n",
    "text": "1.15 use_testthat()\n\n在一个示例中，我们已经对 strsplit1() 进行了简单测试。 我们可以通过一些单元测试（unit test）来形式化。 这意味着我们对于 strsplit1() 在各种输入数据下的正确结果得有一些具体的期望。\n首先，我们声明我们将使用 testthat 包中的 use_testthat() 来编写单元测试：\n\nuse_testthat()\n#> ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n#> ✔ Adding '3' to Config/testthat/edition\n#> ✔ Creating 'tests/testthat/'\n#> ✔ Writing 'tests/testthat.R'\n#> • Call `use_test()` to initialize a basic test file and open it for editing.\n\n这将为您的软件包初始化单元测试机制。 它会在 DESCRIPTION 中添加 Suggests: testthat，创建 tests/testthat/ 目录，并添加脚本 tests/testthat.R。 您可能会注意到 testthat 被添加了一个最低版本 3.0.0 和第二个 DESCRIPTION 字段 Config/testthat/edition: 3。 我们将在 Chapter 13 中更详细地讨论这些细节。\n但是，实际的测试仍然是由您来编写！\n函数 use_test() 打开或创建一个测试文件。 您可以提供文件名，或者如果正在 RStudio 中编辑相关源文件，文件名将自动生成。 对于你们很多人来说，如果 R/strsplit1.R 是 RStudio 中活动的文件，那么只需调用 use_test() 即可。 但由于本书是非交互式构建的，因此必须明确提供 basename：\n\nuse_test(\"strsplit1\")\n#> ✔ Writing 'tests/testthat/test-strsplit1.R'\n#> • Edit 'tests/testthat/test-strsplit1.R'\n\n这将创建文件 tests/testthat/test-strsplit1.R。 如果该文件已经存在，use_test() 函数只会打开它。 您会注意到新创建的文件中有一个示例测试代码 - 请删除该代码并用以下内容替换：\n\ntest_that(\"strsplit1() splits a string\", {\n  expect_equal(strsplit1(\"a,b,c\", split = \",\"), c(\"a\", \"b\", \"c\"))\n})\n\n这个测试验证了当分割字符串时，strsplit1() 是否能够给出预期结果。\n在编写自己的代码时，请交互式地运行此测试。 如果找不到 test_that() 或 strsplit1()，那么说明您可能需要调用 load_all()。\n今后，您的大多数测试将通过 test() 以批量和远程方式运行：\n\n\ntest()\n#> ℹ Testing regexcite\n#> ✔ | F W S  OK | Context\n#> \n#> ⠏ |         0 | strsplit1                                           \n#> ✔ |         1 | strsplit1\n#> \n#> ══ Results ═════════════════════════════════════════════════════════\n#> [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单提供了 test() 的快速调用。 它位于 Build 窗格中，通过 More > Test package, 或者键盘快捷键 Ctrl + Shift + T (WIndows & Linux) 或者 Cmd + Shift + T (MacOS) 调用。\n\n\n每当您使用 check() 检查程序包时，您的测试也会运行。 这样，您基本上就可以使用自己的一些特定于您的包的检查代码来增强标准检查。 最好使用 covr package 跟踪该测试所执行的源代码的比例。 更多详细信息请参见 Chapter 13。"
  },
  {
    "objectID": "whole-game.html#use_package",
    "href": "whole-game.html#use_package",
    "title": "1  The Whole Game",
    "section": "\n1.16 use_package()\n",
    "text": "1.16 use_package()\n\n在自己的包中，您不可避免地会想要使用另一个包中的函数。 我们需要使用特定于包的方法来声明我们需要的其他软件包（i.e. our dependencies），并在我们的软件包中使用这些软件包。 如果您计划将软件包提交到 CRAN，请注意，这甚至适用于您认为“始终可用”的软件包中的函数，例如 stats :: median() 或 utils :: head()。\n当使用 R 正则表达式函数时，常见问题是不确定是否请求 perl = TRUE 还是 perl = FALSE。 然后通常有但并非总是有其他参数来改变模式匹配方式，例如 fixed、ignore.case 和 invert 等等。 很难跟踪哪个函数使用哪个参数以及参数如何交互，因此很少有用户能够在不阅读文档的情况下掌握这些细节。\nstringr 包“提供了一组协调一致的功能，旨在使处理字符串尽可能简单”。 特别地，在每个地方都使用一个正则表达式系统（ICU regular expressions）并且在每个功能中都使用相同界面来控制匹配行为（例如大小写敏感性）。 有些人发现这更容易内化和编程实现。 假设您决定基于 stringr（and stringi）构建 regexcite 而不是 base R 的正则表达式函数。\n首先，使用 use_package() 声明您通常意图使用 stringr 命名空间中的一些功能：\n\nuse_package(\"stringr\")\n#> ✔ Adding 'stringr' to Imports field in DESCRIPTION\n#> • Refer to functions with `stringr::fun()`\n\n这会将 stringr 包添加到 DESCRIPTION 的 Imports 字段中。 这就是它所做的一切。\n让我们重新审视 strsplit1() 以使其更像 stringr。 这是对它的新看法1：\n\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\n请注意：\n\n我们将函数重命名为 str_split_one()，以表示它是 stringr::str_split() 的包装器。\n采用了 stringr::str_split() 中的参数名称。现在我们有 string 和 pattern（以及 n），而不是 x 和 split。\n引入一些参数检查和边缘情况处理。这与切换到 stringr 无关，并且在基于 strsplit() 构建的版本中同样有益。\n调用 stringr::str_split() 时使用 package::function() 形式。这指定我们要从 stringr 命名空间调用 str_split() 函数。 从另一个软件包调用函数有多种方法，本文介绍的方法在 Chapter 11 中完整解释。\n\n新定义的函数应该写在哪里？ 如果我们想继续遵循将 .R 文件命名为其定义功能的约定，则现在需要进行一些繁琐的文件操作。 因为这在实际生活中经常发生，所以我们有 rename_files() 函数，可以协调 R/ 下文件及其相关伴随文件夹 test/ 的重命名。\n\nrename_files(\"strsplit1\", \"str_split_one\")\n#> ✔ Moving 'R/strsplit1.R' to 'R/str_split_one.R'\n#> ✔ Moving 'tests/testthat/test-strsplit1.R' to 'tests/testthat/test-str_split_one.R'\n\n请记住：文件名工作纯粹是出于理想。 我们仍然需要更新这些文件的内容！\n这是 R/str_split_one.R 的更新内容。 除了更改函数定义外，我们还更新了 roxygen 头文件以反映新参数，并包括展示 stringr 功能的示例。\n\n#' Split a string\n#'\n#' @param string A character vector with, at most, one element.\n#' @inheritParams stringr::str_split\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' str_split_one(x, pattern = \",\")\n#' str_split_one(x, pattern = \",\", n = 2)\n#'\n#' y <- \"192.168.0.1\"\n#' str_split_one(y, pattern = stringr::fixed(\".\"))\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\n不要忘记更新测试文件！\n这里是 tests/testthat/test-str_split_one.R 的更新内容。 除了函数名称和参数的更改外，我们还添加了几个测试。\n\ntest_that(\"str_split_one() splits a string\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\"), c(\"a\", \"b\", \"c\"))\n})\n\ntest_that(\"str_split_one() errors if input length > 1\", {\n  expect_error(str_split_one(c(\"a,b\",\"c,d\"), \",\"))\n})\n\ntest_that(\"str_split_one() exposes features of stringr::str_split()\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\", n = 2), c(\"a\", \"b,c\"))\n  expect_equal(str_split_one(\"a.b\", stringr::fixed(\".\")), c(\"a\", \"b\"))\n})\n\n在我们测试新的 str_split_one() 函数之前，需要调用 document()。 为什么呢？记住，document() 有两个主要作用：\n\n将 roxygen 注释转换为适当的 R 文档。\n重新生成 NAMESPACE。\n\n第二个作用在这里尤其重要，因为我们将不再导出 strsplit1() 并且新导出 str_split_one()。 不要被关于 \"Objects listed as exports, but not present in namespace: strsplit1\" 的 warning 所困扰。 当你从命名空间中删除某些内容时，总是会发生这种情况。\n\ndocument()\n#> ℹ Updating regexcite documentation\n#> ℹ Loading regexcite\n#> Warning: Objects listed as exports, but not present in namespace:\n#> • strsplit1\n#> Writing 'NAMESPACE'\n#> Writing 'str_split_one.Rd'\n#> Deleting 'strsplit1.Rd'\n\n通过 load_all() 模拟包安装来试用新的 str_split_one() 函数：\n\nload_all()\n#> ℹ Loading regexcite\nstr_split_one(\"a, b, c\", pattern = \", \")\n#> [1] \"a\" \"b\" \"c\""
  },
  {
    "objectID": "whole-game.html#use_github",
    "href": "whole-game.html#use_github",
    "title": "1  The Whole Game",
    "section": "\n1.17 use_github()\n",
    "text": "1.17 use_github()\n\n您已经看到我们在 regexcite 开发过程中进行提交的记录。 您可以在 https://github.com/jennybc/regexcite 上查看一个指示性历史记录。 我们使用版本控制并决定公开开发过程，这意味着您可以检查每个开发阶段的 regexcite 源代码状态。 通过查看所谓的差异，您可以精确地了解每个 devtools 辅助函数如何修改构成 regexcite 包的源文件。\n如何将本地 regexcite 软件包和 Git 存储库连接到 GitHub 上的配套存储库？ 以下是三种方法：\n\n\nuse_github() 是我们一直以来推荐的帮助函数。 我们不会在此处演示它，因为它需要在您的主机端进行一些特殊的设置。 并且我们也不想每次构建此书时都拆除并重建公共 regexcite 软件包。\n首先设置 GitHub repo！ 听起来有些违反直觉，但将工作放入 GitHub 最简单的方法是从那里开始初始化，然后使用 RStudio 开始在同步本地副本中工作。 该方法在 Happy Git 的工作流 New project, GitHub first 和 Existing project, GitHub first 中有描述。\n命令行 Git 始终可用于事后添加远程存储库。 这在 Happy Git 的工作流 Existing project, GitHub last 中有描述。\n\n任何这些方法都将把您的本地 regexcite 项目连接到一个 GitHub repo（公共或私有），您可以使用内置于 RStudio 中的 Git 客户端进行 push 或 pull。 在 Chapter 20 中，我们详细介绍了为什么值得将版本控制（e.g., Git）和特别是托管的版本控制（e.g. GitHub）纳入软件包开发过程。"
  },
  {
    "objectID": "whole-game.html#use_readme_rmd",
    "href": "whole-game.html#use_readme_rmd",
    "title": "1  The Whole Game",
    "section": "\n1.18 use_readme_rmd()\n",
    "text": "1.18 use_readme_rmd()\n\n现在你的软件包已经上传到 GitHub 上了，README.md 文件变得非常重要。 它是软件包的主页和欢迎页面，至少在你决定给它一个网站（see Chapter 19），添加一个 vignette（see Chapter 17）或将其提交到 CRAN 之前（see Chapter 22）。\nuse_readme_rmd() 函数会初始化一个基本的、可执行的 README.Rmd 文件供您编辑：\n\nuse_readme_rmd()\n#> ✔ Writing 'README.Rmd'\n#> ✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n#> • Update 'README.Rmd' to include installation instructions.\n#> ✔ Writing '.git/hooks/pre-commit'\n\n除了创建 README.Rmd 之外，这还向 .Rbuildignore 添加了一些行，并创建了一个 Git pre-commit hook，以帮助您保持 README.Rmd 和 sync 中的 README.md 同步。\nREADME.Rmd 已经包含以下部分：\n\n描述软件包的目的。\n提供安装说明。如果在调用 use_readme_rmd() 时检测到 GitHub remote，则该部分将预先填充有关如何从 GitHub 安装的说明。\n展示一些使用方法。\n\n如何填写这个框架？ 可以自由地从 DESCRIPTION 和任何正式或非正式测试或示例中复制内容。 任何东西都比没有好。 这很有帮助，因为人们可能不会安装您的软件包并逐个查看帮助文件以了解如何使用它。\n我们喜欢使用 R Markdown 编写 README，这样它就可以显示实际用法。 同时加入实时代码也使得您的 README 不太可能过时，并与您的实际软件包保持同步。\n要进行自己的编辑，请打开 README.Rmd 进行编辑（如果尚未完成）。 确保其中显示了 str_split_one() 函数的某些用法示例。\n我们使用的 README.Rmd 在此处： README.Rmd，以下是其内容：\n\n---\noutput: github_document\n---\n\n<!-- README.md is generated from README.Rmd. Please edit that file -->\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n\n**NOTE: This is a toy package created for expository purposes, for the second edition of [R Packages](https://r-pkgs.org). It is not meant to actually be useful. If you want a package for factor handling, please see [stringr](https://stringr.tidyverse.org), [stringi](https://stringi.gagolewski.com/),\n[rex](https://cran.r-project.org/package=rex), and\n[rematch2](https://cran.r-project.org/package=rematch2).**\n\n# regexcite\n\n<!-- badges: start -->\n<!-- badges: end -->\n\nThe goal of regexcite is to make regular expressions more exciting!\nIt provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.\n\n## Installation\n\nYou can install the development version of regexcite from [GitHub](https://github.com/) with:\n      \n``` r\n# install.packages(\"devtools\")\ndevtools::install_github(\"jennybc/regexcite\")\n```\n\n## Usage\n\nA fairly common task when dealing with strings is the need to split a single string into many parts.\nThis is what `base::strplit()` and `stringr::str_split()` do.\n\n```{r}\n(x <- \"alfa,bravo,charlie,delta\")\nstrsplit(x, split = \",\")\nstringr::str_split(x, pattern = \",\")\n```\n\nNotice how the return value is a **list** of length one, where the first element holds the character vector of parts.\nOften the shape of this output is inconvenient, i.e. we want the un-listed version.\n\nThat's exactly what `regexcite::str_split_one()` does.\n\n```{r}\nlibrary(regexcite)\n\nstr_split_one(x, pattern = \",\")\n```\n\nUse `str_split_one()` when the input is known to be a single string.\nFor safety, it will error if its input has length greater than one.\n\n`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.\n\n```{r}\nstr_split_one(x, pattern = \",\", n = 2)\n\ny <- \"192.168.0.1\"\nstr_split_one(y, pattern = stringr::fixed(\".\"))\n```\n\n别忘了渲染它以生成 README.md！ pre-commit hook 应该在你尝试提交 README.Rmd 时提醒你，但不是 README.md，并且当 README.md 看起来过时时也会提醒。\n最好的方法是使用 build_readme() 来渲染 README.Rmd，因为它会确保使用您包的最新版本进行渲染，即安装当前源的临时副本。\n\nbuild_readme()\n#> ℹ Installing regexcite in temporary library\n#> ℹ Building\n#>   'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite/README.Rmd'\n\n您只需 visiting regexcite on GitHub 即可查看呈现的 README.md。\n最后，不要忘记进行最后一次提交（commit）。 如果您使用的是 GitHub，则还可以推送（push）。"
  },
  {
    "objectID": "whole-game.html#the-end-check-and-install",
    "href": "whole-game.html#the-end-check-and-install",
    "title": "1  The Whole Game",
    "section": "\n1.19 The end: check() and install()\n",
    "text": "1.19 The end: check() and install()\n\n让我们再次运行 check() 以确保一切正常。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 34.4s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nregexcite 应该没有 errors, warnings or notes。 现在是重新构建和安装它的最好时机。 庆祝一下！\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/1.study/R/R-4.2.0/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/1.study/R/R-4.2.0/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** tests\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n请随意访问 GitHub 上的 regexcite package，它正是在这里开发的。 提交历史记录反映了每个单独的步骤，因此可以使用 diff 来查看随着包的发展，哪些文件被添加和修改。 本书的其余部分将更详细地介绍您在这里看到的每一个步骤以及更多内容。"
  },
  {
    "objectID": "whole-game.html#review",
    "href": "whole-game.html#review",
    "title": "1  The Whole Game",
    "section": "\n1.20 Review",
    "text": "1.20 Review\n本章旨在让您了解典型的包开发工作流程，总结为 Figure 1.1 中的图表。 您在此处看到的所有内容都在本章中有所涉及，但 GitHub 操作除外，您将在 Section 20.2.1 中了解更多信息。\n\n\n\n\nFigure 1.1: The devtools package development workflow.\n\n\n\n\n下面是对您在本章中看到的关键函数的回顾，大致按照它们在开发过程中的角色进行组织。\n这些函数设置包的一部分，通常每个包调用一次：\n\ncreate_package()\nuse_git()\nuse_mit_license()\nuse_testthat()\nuse_github()\nuse_readme_rmd()\n\n当您添加函数和测试或采用依赖项时，您将定期调用这些函数：\n\nuse_r()\nuse_test()\nuse_package()\n\n在开发过程中，您将每天或每小时多次调用这些函数：\n\nload_all()\ndocument()\ntest()\ncheck()"
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n自 R Packages 第一版发布以来，支持此处描述的工作流程的包已经经历了广泛的开发。最初的 devtools、roxygen2 和 testthat 三重奏已扩展为包括由 devtools 的 “conscious uncoupling” 创建的包，如 Section 2.2 所述。这些软件包大多数源自 Hadley Wickham (HW)，因为它们源于 devtools。还有许多其他重要的贡献者，其中许多人现在担任维护者：\n\ndevtools: HW, Winston Chang, Jim Hester (maintainer, >= v1.13.5), Jennifer Bryan (maintainer >= v2.4.3)\nusethis: HW, Jennifer Bryan (maintainer >= v1.5.0), Malcolm Barrett\nroxygen2: HW (maintainer), Peter Danenburg, Manuel Eugster\n\ntestthat: HW (maintainer)\ndesc: Gábor Csárdi (maintainer), Kirill Müller, Jim Hester\n\npkgbuild: HW, Jim Hester, Gábor Csárdi (maintainer >= v1.2.1)\npkgload: HW, Jim Hester, Winston Chang, Lionel Henry (maintainer >= v1.2.4)\nrcmdcheck: Gábor Csárdi (maintainer)\nremotes: HW, Jim Hester, Gábor Csárdi (maintainer), Winston Chang, Martin Morgan, Dan Tenenbaum\n\nrevdepcheck: HW, Gábor Csárdi (maintainer)\nsessioninfo: HW, Gábor Csárdi (maintainer), Winston Chang, Robert Flight, Kirill Müller, Jim Hester\n\n\n这本书是 written and revised in the open，它确实是社区的努力：许多人阅读草稿，修复拼写错误，提出改进建议并贡献内容。如果没有这些贡献者，这本书就不会这么好，我们非常感谢他们的帮助。我们感谢 Posit 的同事，尤其是 tidyverse 团队，他们一直热衷于讨论包开发实践。本书得到了极大的改进，在我们出色的技术审稿团队的建议下：Malcolm Barrett、Laura DeCicco、Zhian Kamvar、Tom Mock 和 Maëlle Salmon。\n#> Warning: package 'tidyverse' was built under R version 4.2.3\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n#> Warning: package 'tibble' was built under R version 4.2.3\n#> Warning: package 'tidyr' was built under R version 4.2.3\n#> Warning: package 'readr' was built under R version 4.2.3\n#> Warning: package 'purrr' was built under R version 4.2.3\n#> Warning: package 'dplyr' was built under R version 4.2.3\n#> Warning: package 'stringr' was built under R version 4.2.2\n#> Warning: package 'forcats' was built under R version 4.2.3\n#> Warning: package 'lubridate' was built under R version 4.2.3\n#> ── Attaching core tidyverse packages ──────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n#> Rows: 410 Columns: 3\n#> ── Column specification ────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr (3): user, name, maybe_name\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nThanks to all contributors the the first and second editions (in alphabetical order by GitHub username):\n@aaelony, @aaronwolen (Aaron Wolen), @ablejec (Andrej Blejec), @adamcduncan (Adam Duncan), @adessy, @adrtod (Adrien Todeschini), @aghaynes (Alan Haynes), @agrueneberg (Alexander Grueneberg), @alejandrohagan (Alejandro Hagan), @alesantuz (Ale Santuz), @alexandrehsd (Alexandre Henrique), @alexholcombe (Alex O. Holcombe), @alexpghayes (alex hayes), @alforj (Justin Alford), @almartin82 (Andrew Martin), @aluxh (Alex Ho), @AmelZulji, @andreaphsz (Andrea Cantieni), @andrewdolman (Andrew Dolman), @andrewpbray (Andrew Bray), @AndrewsOR (John Andrews), @andycraig (Andrew Craig), @angela-li (Angela Li), @anjalisilva (Anjali Silva), @apomatix (Brad Friedman), @apreshill (Alison Presmanes Hill), @arashHaratian (Arash), @arilamstein (Ari Lamstein), @arneschillert (Arne Schillert), @arni-magnusson (Arni Magnusson), @asadow (Adam Sadowski), @ateucher (Andy Teucher), @avisser (Andy Visser), @ayormark (Adam Yormark), @azzaea (Azza Ahmed), @batpigandme (Mara Averick), @bclipp (Brian L), @beevabeeva, @behrman (Bill Behrman), @benmarwick (Ben Marwick), @BernhardKonrad (Bernhard Konrad), @bgreenwell (Brandon Greenwell), @Bisaloo (Hugo Gruson), @bklamer (Brett Klamer), @bm5tev3, @bms63 (Ben Straub), @bpbond (Ben Bond-Lamberty), @bquast (Bastiaan Quast), @Br-Johnson (Brett Johnson), @brews (Brewster Malevich), @brianrice2 (Brian Rice), @brry (Berry Boessenkool), @btruel, @calligross (Calli), @carldotac (Carl Lieberman), @carloscinelli (Carlos Cinelli), @CDCookJr, @cderv (Christophe Dervieux), @chambm (Matt Chambers), @charliejhadley (Charlie Joey Hadley), @chezou (Aki Ariga), @chsafouane (Safouane Chergui), @clente (Caio Lente), @cmarmstrong, @cooknl (CAPN), @CorradoLanera (Corrado Lanera), @craigcitro (Craig Citro), @crtahlin (Crt Ahlin), @daattali (Dean Attali), @danhalligan (Dan Halligan), @daroczig (Gergely Daróczi), @datarttu (Arttu Kosonen), @davidkane9 (David Kane), @DavisVaughan (Davis Vaughan), @deanbodenham, @dfalbel (Daniel Falbel), @dgrtwo (David Robinson), @dholstius (David Holstius), @DickStartz, @dkgaraujo (Douglas K. G. Araujo), @dlukes (David Lukes), @DOH-PXC5303 (Philip Crain), @dongzhuoer (Zhuoer Dong), @DougManuel (Doug Manuel), @dpprdan (Daniel Possenriede), @dracodoc (dracodoc), @drag05 (Dragos Bandur), @drvinceknight (Vince Knight), @dryzliang, @dyavorsky (Dan Yavorsky), @e-pet, @earino (E. Ariño de la Rubia), @echelleburns, @eeholmes (Eli Holmes), @eipi10 (Joel Schwartz), @ekbrown (Earl Brown), @EllaKaye (Ella Kaye), @EmilHvitfeldt (Emil Hvitfeldt), @eogoodwin, @erictleung (Eric Leung), @erikerhardt (Erik Erhardt), @espinielli (Enrico Spinielli), @ewan (Ewan Dunbar), @fbertran (Frederic Bertrand), @federicomarini (Federico Marini), @fenguoerbian (Chao Cheng), @fkohrt (Florian Kohrt), @florisvdh (Floris Vanderhaeghe), @floswald (Florian Oswald), @franrodalg (Francisco Rodríguez-Algarra), @franticspider (Simon Hickinbotham), @frycast (Daniel Vidali Fryer), @fsavje (Fredrik Sävje), @gajusmiknaitis, @gcpoole (Geoffrey Poole), @geanders (Brooke Anderson), @georoen (Jee Roen), @GerardTromp (Gerard Tromp), @GillesSanMartin (Gilles San Martin), @gmaubach (Georg Maubach), @gonzalezgouveia (Rafael Gonzalez Gouveia), @gregmacfarlane (Greg Macfarlane), @gregrs-uk (Greg), @grst (Gregor Sturm), @gsrohde (Scott Rohde), @guru809, @gustavdelius (Gustav W Delius), @haibin (Liu Haibin), @hanneoberman (Hanne Oberman), @harrismcgehee (Harris McGehee), @havenl (Haven Liu), @hcyvan (程一航), @hdraisma (Harmen), @hedderik (Hedderik van Rijn), @heists ((ꐦ°᷄д°)ა), @helske (Jouni Helske), @henningte (Henning Teickner), @HenrikBengtsson (Henrik Bengtsson), @heogden (Helen Ogden), @hfrick (Hannah Frick), @Holzhauer (Sascha Holzhauer), @howardbaek (Howard Baek), @howbuildingsfail (How Buildings Fail), @hq9000 (Sergey Grechin), @hrbrmstr (boB Rudis), @iangow (Ian Gow), @iargent, @idmn (Iaroslav Domin), @ijlyttle (Ian Lyttle), @imchoyoung (Choyoung Im), @InfiniteCuriosity (Russ Conte), @ionut-stefanb (Ionut Stefan-Birdea), @Ironholds (Os Keyes), @ismayc (Chester Ismay), @isomorphisms (i), @jackwasey (Jack Wasey), @jacobbien (Jacob Bien), @jadeynryan (Jadey Ryan), @jameelalsalam (Jameel Alsalam), @jameslairdsmith (James Laird-Smith), @janzzon (Stefan Jansson), @JayCeBB, @jcainey (Joe Cainey), @jdblischak (John Blischak), @jedwards24 (James Edwards), @jemus42 (Lukas Burk), @jenniferthompson (Jennifer Thompson), @jeremycg (Jeremy Gray), @jgarthur (Joey Arthur), @jimhester (Jim Hester), @jimr1603 (James Riley), @jjesusfilho (José de Jesus Filho), @jkeirstead (James Keirstead), @jmarca (James Marca), @jmarshallnz (Jonathan Marshall), @joethorley (Joe Thorley), @johnbaums (John), @jolars (Johan Larsson), @jonthegeek (Jon Harmon), @jowalski (John Kowalski), @jpinelo (Joao Pinelo Silva), @jrdnbradford (Jordan), @jthomasmock (Tom Mock), @julian-urbano (Julián Urbano), @jwpestrak, @jzadra (Jonathan Zadra), @jzhaoo (Joanna Zhao), @kaetschap (Sonja), @karthik (Karthik Ram), @KasperThystrup (Kasper Thystrup Karstensen), @KatherineCox, @katrinleinweber (Katrin Leinweber), @kbroman (Karl Broman), @kekecib (Ibrahim Kekec), @KellenBrosnahan, @kendonB (Kendon Bell), @kevinushey (Kevin Ushey), @kikapp (Kristopher Kapphahn), @KirkDSL, @KJByron (Karen J. Byron), @klmr (Konrad Rudolph), @KoderKow (Kyle Harris), @kokbent (Ben Toh), @kongdd (Dongdong Kong), @krlmlr (Kirill Müller), @kwenzig (Knut Wenzig), @kwstat (Kevin Wright), @kylelundstedt (Kyle G. Lundstedt), @lancelote (Pavel Karateev), @lbergelson (Louis Bergelson), @LechMadeyski (Lech Madeyski), @Lenostatos (Leon), @lindbrook, @lionel- (Lionel Henry), @LluisRamon (Lluís Ramon), @lorenzwalthert (Lorenz Walthert), @lwjohnst86 (Luke W Johnston), @maelle (Maëlle Salmon), @maiermarco, @maislind (David M), @majr-red (Matthew Roberts), @malcolmbarrett (Malcolm Barrett), @malexan (Alexander Matrunich), @manuelreif (Manuel Reif), @MarceloRTonon (Marcelo Tonon), @mariacuellar (Maria Cuellar), @markdly (Mark Dulhunty), @Marlin-Na (Marlin), @martin-mfg, @matanhakim (Matan Hakim), @matdoering, @matinang (Matina Angelopoulou), @mattflor (Matthias Flor), @maurolepore (Mauro Lepore), @maxheld83 (Max Held), @mayankvanani (Mayank Vanani), @mbjones (Matt Jones), @mccarthy-m-g (Michael McCarthy), @mdequeljoe (Matthew de Queljoe), @mdsumner (Michael Sumner), @michaelboerman (Michael Boerman), @MichaelChirico (Michael Chirico), @michaelmikebuckley (Michael Buckley), @michaelweylandt (Michael Weylandt), @miguelmorin, @MikeJohnPage, @mikelnrd (Michael Leonard), @mikelove (Mike Love), @mikemc (Michael McLaren), @MilesMcBain (Miles McBain), @mjkanji (Muhammad Jarir Kanji), @mkuehn10 (Michael Kuehn), @mllg (Michel Lang), @mohamed-180 (Mohamed El-Desokey), @moodymudskipper (Antoine Fabri), @Moohan (James McMahon), @MrAE (Jesse Leigh Patsolic), @mrcaseb, @ms609 (Martin R. Smith), @mskyttner (Markus Skyttner), @MWilson92 (Matthew Wilson), @myoung3, @nachti (Gerhard Nachtmann), @nanxstats (Nan Xiao), @nareal (Nelson Areal), @nattalides, @ncarchedi (Nick Carchedi), @ndphillips (Nathaniel Phillips), @nick-youngblut (Nick Youngblut), @njtierney (Nicholas Tierney), @nsheff (Nathan Sheffield), @osorensen (Øystein Sørensen), @PabRod (Pablo Rodríguez-Sánchez), @paternogbc (Gustavo Brant Paterno), @paulrougieux (Paul Rougieux), @pdwaggoner (Philip Waggoner), @pearsonca (Carl A. B. Pearson), @perryjer1 (Jeremiah), @petermeissner (Peter Meissner), @petersonR (Ryan Peterson), @petzi53 (Peter Baumgartner), @PhilipPallmann (Philip Pallmann), @philliplab (Phillip Labuschagne), @phonixor (Gerrit-Jan Schutten), @pkimes (Patrick Kimes), @pnovoa (Pavel Novoa), @ppanko (Pavel Panko), @pritesh-shrivastava (Pritesh Shrivastava), @PrzeChoj (PrzeChoj), @PursuitOfDataScience (Y. Yu), @pwaeckerle, @raerickson (Richard Erickson), @ramiromagno (Ramiro Magno), @ras44, @rbirkelbach (Robert Birkelbach), @rcorty (Robert W. Corty), @rdiaz02 (Ramon Diaz-Uriarte), @realAkhmed (Akhmed Umyarov), @reikookamoto (Reiko Okamoto), @renkun-ken (Kun Ren), @retowyss (Reto Wyss), @revodavid (David Smith), @rgknight (Ryan Knight), @rhgof (Richard), @rmar073, @rmflight (Robert M Flight), @rmsharp (R. Mark Sharp), @rnuske (Robert Nuske), @robertzk (Robert Krzyzanowski), @Robinlovelace (Robin Lovelace), @robiRagan (Robi Ragan), @Robsteranium (Robin Gower), @romanzenka (Roman Zenka), @royfrancis (Roy Francis), @rpruim (Randall Pruim), @rrunner, @rsangole (Rahul), @ryanatanner (Ryan), @salim-b (Salim B), @SamEdwardes (Sam Edwardes), @SangdonLim (Sangdon Lim), @sathishsrinivasank (Sathish), @sbgraves237, @schifferl (Lucas Schiffer), @scw (Shaun Walbridge), @sdarodrigues (Sabrina Rodrigues), @sebffischer (Sebastian Fischer), @serghiou (Stylianos Serghiou), @setoyama60jp, @sfirke (Sam Firke), @shannonpileggi (Shannon Pileggi), @Shelmith-Kariuki (Shel), @SheridanLGrant (Sheridan Grant), @shntnu (Shantanu Singh), @sibusiso16 (S’busiso Mkhondwane), @simdadim (Simen Buodd), @SimonPBiggs (SPB), @simonthelwall (Simon Thelwall), @SimonYansenZhao (Simon He Zhao), @singmann (Henrik Singmann), @Skenvy (Nathan Levett), @Smudgerville (Richard M. Smith), @sn248 (Satyaprakash Nayak), @sowla (Praer (Suthira) Owlarn), @srushe (Stephen Rushe), @statnmap (Sébastien Rochette), @steenharsted (Steen Harsted), @stefaneng (Stefan Eng), @stefanherzog (Stefan Herzog), @stephen-frank (Stephen Frank), @stephenll (Stephen Lienhard), @stephenturner (Stephen Turner), @stevenprimeaux (Steven Primeaux), @stevensbr, @stewid (Stefan Widgren), @sunbeomk (Sunbeom Kwon), @superdesolator (Po Su), @syclik (Daniel Lee), @symbolrush (Adrian Stämpfli-Schmid), @taekyunk (Taekyun Kim), @talgalili (Tal Galili), @tanho63 (Tan Ho), @tbrugz (Telmo Brugnara), @thisisnic (Nic Crane), @TimHesterberg (Tim Hesterberg), @titaniumtroop (Nathan), @tjebo, @tklebel (Thomas Klebel), @tmstauss (Tanner Stauss), @tonybreyal (Tony Breyal), @tonyfischetti (Tony Fischetti), @TonyLadson (Tony Ladson), @trickytank (Rick Tankard), @TroyVan, @uribo (Shinya Uryu), @urmils, @valeonte, @vgonzenbach (Virgilio Gonzenbach), @vladpetyuk (Vlad Petyuk), @vnijs (Vincent Nijs), @vspinu (Vitalie Spinu), @wcarlsen (Willi Carlsen), @wch (Winston Chang), @wenjie2wang (Wenjie Wang), @werkstattcodes, @wiaidp, @wibeasley (Will Beasley), @wilkinson (Sean Wilkinson), @williamlief (Lief Esbenshade), @winterschlaefer (Christof Winter), @wlamnz (William Lam), @wrathematics (Drew Schmidt), @XiangyunHuang (Xiangyun Huang), @xiaochi-liu (Xiaochi), @XiaoqiLu (Xiaoqi Lu), @xiaosongz (Xiaosong Zhang), @yihui (Yihui Xie), @ynsec37, @yonicd, @ysdgroot, @yui-knk (Yuichiro Kaneko), @Zedseayou (Calum You), @zeehio (Sergio Oller), @zekiakyol (Zeki Akyol), @zenggyu (Guangyu Zeng), @zhaoy, @zhilongjia (Zhilong), @zhixunwang, @zkamvar (Zhian N. Kamvar), @zouter (Wouter Saelens)."
  },
  {
    "objectID": "preface.html#conventions",
    "href": "preface.html#conventions",
    "title": "Preface",
    "section": "Conventions",
    "text": "Conventions\n在本书中，我们用 fun() 来引用函数，用 var 来引用变量和函数参数，用 path/ 来引用路径。\n较大的代码块混合输入和输出。输出带有注释，因此如果您有本书的电子版本，例如 https://r-pkgs.org，您可以轻松地将示例复制并粘贴到 R 中。输出注释看起来像 #> 以将其与常规注释区分开。"
  },
  {
    "objectID": "preface.html#colophon",
    "href": "preface.html#colophon",
    "title": "Preface",
    "section": "Colophon",
    "text": "Colophon\n本书是使用 RStudio 中的 Quarto 编写的。该 website 由 Netlify 托管，并在每次 GitHub 操作提交后自动更新。完整的源代码可以从 GitHub 获取。\n本书的这个版本是用以下内容构建的：\n\nlibrary(devtools)\n#> Warning: package 'devtools' was built under R version 4.2.3\n#> Loading required package: usethis\n#> Warning: package 'usethis' was built under R version 4.2.3\nlibrary(roxygen2)\n#> Warning: package 'roxygen2' was built under R version 4.2.3\nlibrary(testthat)\n#> Warning: package 'testthat' was built under R version 4.2.3\n#> \n#> Attaching package: 'testthat'\n#> The following object is masked from 'package:devtools':\n#> \n#>     test_file\n#> The following object is masked from 'package:dplyr':\n#> \n#>     matches\n#> The following object is masked from 'package:purrr':\n#> \n#>     is_null\n#> The following objects are masked from 'package:readr':\n#> \n#>     edition_get, local_edition\n#> The following object is masked from 'package:tidyr':\n#> \n#>     matches\ndevtools::session_info()\n#> ─ Session info ───────────────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.2.0 (2022-04-22 ucrt)\n#>  os       Windows 10 x64 (build 22621)\n#>  system   x86_64, mingw32\n#>  ui       RTerm\n#>  language (EN)\n#>  collate  Chinese (Simplified)_China.utf8\n#>  ctype    Chinese (Simplified)_China.utf8\n#>  tz       Asia/Taipei\n#>  date     2023-06-30\n#>  pandoc   2.19.2 @ D:/1.study/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  bit           4.0.5   2022-11-15 [1] CRAN (R 4.2.3)\n#>  bit64         4.0.5   2020-08-30 [1] CRAN (R 4.2.1)\n#>  brio          1.1.3   2021-11-30 [1] CRAN (R 4.2.0)\n#>  cachem        1.0.8   2023-05-01 [1] CRAN (R 4.2.3)\n#>  callr         3.7.3   2022-11-02 [1] CRAN (R 4.2.2)\n#>  cli           3.6.1   2023-03-23 [1] CRAN (R 4.2.3)\n#>  colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.2.3)\n#>  crayon        1.5.2   2022-09-29 [1] CRAN (R 4.2.1)\n#>  devtools    * 2.4.5   2022-10-11 [1] CRAN (R 4.2.3)\n#>  digest        0.6.29  2021-12-01 [1] CRAN (R 4.2.0)\n#>  dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.2.3)\n#>  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.2.0)\n#>  evaluate      0.21    2023-05-05 [1] CRAN (R 4.2.3)\n#>  fansi         1.0.4   2023-01-22 [1] CRAN (R 4.2.3)\n#>  fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.2.3)\n#>  forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.2.3)\n#>  fs            1.6.2   2023-04-25 [1] CRAN (R 4.2.3)\n#>  generics      0.1.3   2022-07-05 [1] CRAN (R 4.2.0)\n#>  ggplot2     * 3.4.2   2023-04-03 [1] CRAN (R 4.2.3)\n#>  glue          1.6.2   2022-02-24 [1] CRAN (R 4.2.0)\n#>  gtable        0.3.3   2023-03-21 [1] CRAN (R 4.2.3)\n#>  hms           1.1.3   2023-03-21 [1] CRAN (R 4.2.3)\n#>  htmltools     0.5.4   2022-12-07 [1] CRAN (R 4.2.2)\n#>  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.2.3)\n#>  httpuv        1.6.11  2023-05-11 [1] CRAN (R 4.2.3)\n#>  jsonlite      1.8.5   2023-06-05 [1] CRAN (R 4.2.3)\n#>  knitr         1.43    2023-05-25 [1] CRAN (R 4.2.3)\n#>  later         1.3.1   2023-05-02 [1] CRAN (R 4.2.3)\n#>  lifecycle     1.0.3   2022-10-07 [1] CRAN (R 4.2.1)\n#>  lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.2.3)\n#>  magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n#>  memoise       2.0.1   2021-11-26 [1] CRAN (R 4.2.0)\n#>  mime          0.12    2021-09-28 [1] CRAN (R 4.2.0)\n#>  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.2.0)\n#>  munsell       0.5.0   2018-06-12 [1] CRAN (R 4.2.2)\n#>  pillar        1.9.0   2023-03-22 [1] CRAN (R 4.2.3)\n#>  pkgbuild      1.4.0   2022-11-27 [1] CRAN (R 4.2.2)\n#>  pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.2.0)\n#>  pkgload       1.3.2   2022-11-16 [1] CRAN (R 4.2.2)\n#>  prettyunits   1.1.1   2020-01-24 [1] CRAN (R 4.2.0)\n#>  processx      3.8.1   2023-04-18 [1] CRAN (R 4.2.3)\n#>  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.2.3)\n#>  promises      1.2.0.1 2021-02-11 [1] CRAN (R 4.2.0)\n#>  ps            1.7.5   2023-04-18 [1] CRAN (R 4.2.3)\n#>  purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.2.3)\n#>  R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.0)\n#>  Rcpp          1.0.10  2023-01-22 [1] CRAN (R 4.2.3)\n#>  readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.2.3)\n#>  remotes       2.4.2   2021-11-30 [1] CRAN (R 4.2.0)\n#>  rlang         1.1.1   2023-04-28 [1] CRAN (R 4.2.3)\n#>  rmarkdown     2.22    2023-06-01 [1] CRAN (R 4.2.3)\n#>  roxygen2    * 7.2.3   2022-12-08 [1] CRAN (R 4.2.3)\n#>  rstudioapi    0.14    2022-08-22 [1] CRAN (R 4.2.1)\n#>  scales        1.2.1   2022-08-20 [1] CRAN (R 4.2.1)\n#>  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n#>  shiny         1.7.4   2022-12-15 [1] CRAN (R 4.2.2)\n#>  stringi       1.7.12  2023-01-11 [1] CRAN (R 4.2.2)\n#>  stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.2.2)\n#>  testthat    * 3.1.8   2023-05-04 [1] CRAN (R 4.2.3)\n#>  tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.2.3)\n#>  tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.2.3)\n#>  tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.2.1)\n#>  tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.2.3)\n#>  timechange    0.2.0   2023-01-11 [1] CRAN (R 4.2.3)\n#>  tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.2.3)\n#>  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.2.1)\n#>  usethis     * 2.2.0   2023-06-06 [1] CRAN (R 4.2.3)\n#>  utf8          1.2.3   2023-01-31 [1] CRAN (R 4.2.3)\n#>  vctrs         0.6.2   2023-04-19 [1] CRAN (R 4.2.3)\n#>  vroom         1.6.3   2023-04-28 [1] CRAN (R 4.2.3)\n#>  withr         2.5.0   2022-03-03 [1] CRAN (R 4.2.0)\n#>  xfun          0.39    2023-04-20 [1] CRAN (R 4.2.3)\n#>  xml2          1.3.4   2023-04-27 [1] CRAN (R 4.2.3)\n#>  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.2.0)\n#> \n#>  [1] D:/1.study/R/R-4.2.0/library\n#> \n#> ──────────────────────────────────────────────────────────────────\n\n\n\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive Pretty Printing of R Code. http://styler.r-lib.org."
  },
  {
    "objectID": "introduction.html#sec-intro-phil",
    "href": "introduction.html#sec-intro-phil",
    "title": "Introduction",
    "section": "Philosophy",
    "text": "Philosophy\n这本书支持了我们的程序包开发理念：任何能够自动化的东西都应该自动化。 尽量减少手动操作。 用函数完成尽可能多的事情。 这样是希望您将时间用于思考您想要包做什么工作，而不是包结构的各种细节。\n这种开发理念主要是通过 devtools 包来实现的，这个程序包是让通用开发任务自动化的 R 函数套件中的代表。 devtools 在 2018 年 10 月发布了 2.0.0 版本，这标志着其内部结构重组为一系列功能更具针对性的程序包，而它则更像是一个元程序包（meta-package）。 usethis 程序包是您最有可能与之交互的子程序包；我们将在 Section 2.2 解释 devtools 与 usethis 之间的关系。\n像往常一样，devtools 程序包的目的是让程序包的开发尽可能的轻松便利。 它囊括了第一作者 Hadley Wickham 这些年来作为一名多产的独立开发者的最佳实践经验。 最近，他在 Posit（以前称为 RStudio）组建了一个开发团队，他们共同管理着数百个开源 R 包，包括那些被称为 the tidyverse 的包。 这个团队的影响力使得我们能够在一个巨大的规模上探索所有可能出现的错误与问题。 幸运的是，它还让我们有机会与专家和友善的同事一起反思成功与失败。 我们尝试找到一些能够使包的维护者和使用者更快乐地工作生活的做法。 而正是在 devtools meta-package 里，您将看到这些方法是如何具体实现的。\ndevtools 与 RStudio 联系紧密、携手共进，而后者正是我们认为对大多数 R 用户而言最佳的开发环境。 目前最流行的 RStudio 替代品是启用了 R extension 的 Visual Studio Code (VS Code)。 这可能是一个有益而强大的环境，但是它确实需要更多的工作来设置和定制1。\n\n\n\n\n\n\nRStudio\n\n\n\n在整本书中，我们在像这样的特殊格式部分中强调了 RStudio 可以加快您的包开发工作流程的具体方法。\n\n\ndevtools 和 RStudio 一起，让您无需关注包是怎样建立的这种低级细节。 但是当您开始开发更多的程序包时，我们强烈建议你去了解这些细节。 有关软件包开发细节的最好的官方资源，始终是官方的 writing R extensions。 然而，如果您不熟悉包的基础知识，是很难理解这本手册的。 它也很详尽，涵盖了所有可能的包的组件，而不是像本书一样专注于那些最常见和最有用的组件。 一旦你掌握了 R 包的基础知识，并且想深入了解更多的知识，那么官方的 writing R extensions 将是一个很有用的资源。"
  },
  {
    "objectID": "introduction.html#intro-outline",
    "href": "introduction.html#intro-outline",
    "title": "Introduction",
    "section": "In this book",
    "text": "In this book\n本书的第一部分是为您提供开始包开发之旅所需的所有工具，我们强烈建议您按顺序阅读。 我们从 Chapter 1 开始，介绍了一个小软件包的完整开发过程。 这是为了在我们深入研究 R 包的关键组件之前，描绘开发的大图景并提出对一个工作流程的建议。 然后，在 Chapter 2 中，您将学习如何为包开发准备好你的系统，在 Chapter 3 中，您将了解包的基本结构以及它在不同状态下的变化。 接下来，在 Chapter 4 中，我们将介绍软件包开发人员反复提出的核心工作流程。 本书的第一部分以另一个案例研究（Chapter 5）结尾，这次重点介绍如何将 script 转换为 package，并讨论在此过程中您将面临的挑战。\n本书的其余部分旨在根据需要阅读。 随着开发过程中出现的各种主题，在章节之间进行选择。\n首先，我们介绍关键的包组件：Chapter 6 讨论代码所在的位置以及如何组织代码，Chapter 7 向您展示如何在包中包含数据，Chapter 8 介绍一些需要在某处讨论的不太重要的文件和目录。\n接下来，我们将从 Chapter 9 中的 DESCRIPTION 开始深入研究 package metadata。 然后我们将深入研究 dependencies。 在 Chapter 10 中，我们将介绍 dependencies 的成本和好处，并提供一些有关包命名空间（package namespaces）和搜索路径（search path）的技术背景。 在 Chapter 11 中，我们关注实际问题，例如如何在包的不同部分中使用不同类型的 dependencies。 这也是我们讨论导出函数（exporting functions）的地方，这使得其他包和项目可以依赖于您的包。 我们将在 Chapter 12 中讨论许可（licensing）来结束这一部分。\n为了确保您的包按设计工作（并在您进行更改时继续工作），测试代码至关重要，因此接下来的三章将介绍测试的艺术和科学。 Chapter 13 将带您开始使用 testthat 包进行测试的基础知识。 Chapter 14 教您如何以最有效的方式设计和组织测试。 然后我们在 Chapter 15 中完成了测试的介绍，该章教您应对具有挑战性的情况的高级技能。\n如果您希望其他人（包括未来的您！）了解如何使用包中的功能，您需要记录它们。 Chapter 16 让您开始使用 roxygen2 来记录包中的函数。 仅当您知道要查找哪些函数时，函数文档才有用，因此接下来在 Chapter 17 中我们将讨论小插曲（vignettes），它可以帮助您将包作为一个整体进行记录。 我们将在 Chapter 18 中讨论其他重要的 Markdown 文件（例如 README.md 和 NEWS.md），并在 Chapter 19 中使用 pkgdown 创建包网站来完成文档。\n本书最后回顾了开发实践，例如使用版本控制和持续集成的好处（Chapter 20）。 我们通过讨论包的生命周期（Chapter 21）来总结，包括在 CRAN 上发布它（Chapter 22）。\n有很多东西需要学习，但不要感到不知所措。 从一些有用功能的最小一部分开始（例如，只是一个 R/ 目录！），并随着时间的推移逐步建立并完善它。 套用禅师 Shunryu Suzuki 的话：“Each package is perfect the way it is — and it can use a little improvement”。"
  },
  {
    "objectID": "introduction.html#whats-not-here",
    "href": "introduction.html#whats-not-here",
    "title": "Introduction",
    "section": "What’s not here",
    "text": "What’s not here\n还有一些特定的实践在这里很少或根本没有处理，仅仅是因为我们没有足够地使用它们来获得任何特殊的洞察力。 这是否意味着我们积极劝阻这些做法？ 可能不会，因为我们试图明确说明我们认为您应该避免的做法。 因此，如果此处未涵盖某些内容，则仅意味着构建了数百个频繁使用的 R 包，而没有对该技术产生有意义的依赖。 这种观察应该会激励您评估您的开发需求与我们的真正不重叠的可能性有多大。 但有时答案是明确的“是”，在这种情况下，您只需要咨询其他资源即可。\n\n\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2."
  },
  {
    "objectID": "setup.html#setup-prep",
    "href": "setup.html#setup-prep",
    "title": "2  System setup",
    "section": "\n2.1 Prepare your system",
    "text": "2.1 Prepare your system\n首先，请确保您已经安装了最新版本的 R（至少 4.2.0，这是本书使用的版本），然后再运行以下代码来获取您将使用到的程序包：\n\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))\n\n请确保您已经安装了最新版本的 RStudio 集成开发环境（IDE）。 新版本会定期发布，因此我们建议经常更新以获得最新和最强大的功能。\n在此处下载当前版本的 RStudio Desktop：https://posit.co/download/rstudio-desktop/。 大多数读者可以使用 RStudio Desktop 的免费开源版本。"
  },
  {
    "objectID": "setup.html#sec-setup-usage",
    "href": "setup.html#sec-setup-usage",
    "title": "2  System setup",
    "section": "\n2.2 devtools, usethis, and you",
    "text": "2.2 devtools, usethis, and you\n\n“I am large, I contain multitudes.”\n— Walt Whitman, Song of Myself\n\n如 Section 1 所述，devtools 是一个 ‘meta-package’，涵盖并公开维护在几个较小的软件包中的功能1。 例如，devtools 可能提供一个包装函数以设置用户友好的默认值、引入有用的交互行为或将多个子软件包的功能组合起来。 在某些情况下，它只是从另一个软件包重新导出函数，使得当加载 devtools 时很容易使用该函数。\n我们推荐的使用 devtools 及其组成包的方法是什么？ 着取决于您的意图：\n\n如果您正在交互式地使用这些函数来帮助您开发自己的软件包，则应将 devtools 视为提供程序。 通过 library(devtools) 加载它，并无限制地调用函数（e.g., load_all()）。\n如果您正在编写代码并使用来自于 devtools 和相关工具中的函数，则不应依赖于 devtools，而应通过主要归属于这些函数所在位置上面对应相应软件包进行访问。\n\n在形如 pkg::fcn() 的限定调用中，devtool 应该很少出现在 pkg 的角色。 相反，pkg 应该是定义了 fcn() 的包。 例如，如果您在包中创建一个需要查询用户 R 会话状态的函数，请在包中使用 sessioninfo::session_info() 而不是 devtools::session_info()。\n\n\n如果您发现了 bugs，请尝试在函数主要归属的软件包上报告它们。 devtools::fcn() 的帮助通常会说明 devtools 是否正在从另一个软件包重新导出函数。\n\nusethis 包是一个可能被更多人知道并可以直接使用的组成包。 现在，它包含对 R 项目中的文件和文件夹执行操作的函数，尤其是对于同时也是 R 程序包的任何项目而言。 devtools 可以轻松地以交互方式访问 usethis 函数，因为当您调用 library(devtools) 时，也会附加 usethis 。 然后你可以在 usethis 中使用任何函数而无需限定，例如，只需调用 use_testthat()。 如果您选择指定命名空间，例如以更具编程性的方式工作时，请确保使用 usethis 限定调用，例如 usethis::use_testthat()。\n\n2.2.1 Personal startup configuration\n您可以像这样加载 devtools：\n\nlibrary(devtools)\n\n但是随着在每个 R 会话（R Session）中反复添加 devtools，它就变得令人烦恼了。 因此，我们强烈建议将 devtools 附加到您的 .Rprofile 启动文件中，如下所示：\n\nif (interactive()) {\n  suppressMessages(require(devtools))\n}\n\n为了方便起见，use_devtools() 函数会在您需要时创建 .Rprofile 文件，将其打开并进行编辑，然后在剪切板和屏幕上放置必要的代码行。\n\n\n\n\n\n\nWarning\n\n\n\n一般来说，在 .Rprofile 中添加程序包是一个坏主意，因为它邀请您通过显式调用 library(foo) 创建不反映所有依赖关系的 R 脚本。 但是 devtools 是一个工作流程包，它简化了程序包的开发流程，因此不太可能融入到任何分析脚本中。 请注意，我们仍然注意只在交互式会话中添加。\n\n\n例如，在从头（de novo）创建 R 包时，usethis 参考了某些选项。 这允许您指定程序包维护者或首选许可证等个人默认设置。 下面是 .Rprofile 中可能包含的代码片段的示例：\n\noptions(\n  \"Authors@R\" = utils::person(\n    \"Jane\", \"Doe\",\n    email = \"jane@example.com\",\n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"0000-1111-2222-3333\")\n  ),\n  License = \"MIT + file LICENSE\"\n)\n\n以下代码显示了如何安装开发版本的 devtools 和 usethis。 有时，本书可能会描述 devtools 和相关包的开发版本中的新功能，但尚未发布。\n\ndevtools::install_github(\"r-lib/devtools\")\ndevtools::install_github(\"r-lib/usethis\")\n\n# or, alternatively\npak::pak(\"r-lib/devtools\")\npak::pak(\"r-lib/usethis\")"
  },
  {
    "objectID": "setup.html#setup-tools",
    "href": "setup.html#setup-tools",
    "title": "2  System setup",
    "section": "\n2.3 R build toolchain",
    "text": "2.3 R build toolchain\n要能够完全从源代码构建 R 程序包，还需要一个编译器和其他一些命令行工具。 这可能不是必须的，除非您想构建包含 C 或 C++ 代码的程序包。 特别是如果您正在使用 RStudio，您可以暂时把它放在一边。 一旦您尝试执行需要您设置开发环境的操作，IDE 将向您发出警报并提供支持。 请继续阅读以获取有关自己操作的建议。\n\n2.3.1 Windows\n在 Windows 上，从源代码构建程序包所需要的工具集叫做 RTools。\nRTools 不是 R 程序包，它不能通过 install.packages() 安装。 而是通过从 https://cran.r-project.org/bin/windows/Rtools/ 下载并运行安装程序来安装。\n在 RTools 的安装过程中，您可能会看到一个窗口，它询问您 “Select Additional Tasks”。\n\n不要选中 “Edit the system PATH”。devtools 和 Rstudio 应该在需要时自动将 RTools 放入 PATH。\n选中 “Save version information to registry”。它应该是默认选中的。\n\n2.3.2 macOS\n您需要安装 Xcode 命令行工具，这需要您 register as an Apple developer（不用担心，它是免费的）。\n然后，在 shell 中执行以下操作：\nxcode-select --install\n或者，您可以安装当前版本的完整 Xcode from the Mac App Store。 其中包括大量您不需要的内容，但它提供了 App Store 便利性的优势。\n\n2.3.3 Linux\n确保您不仅安装了 R，还安装了 R 开发工具。 例如，在 Ubuntu（and Debian）上，您需要使用以下命令安装 r-base-dev 软件包：\nsudo apt install r-base-dev\n在 Fedora 和 RedHat 上，当您使用 sudo dnf install R 安装 R 时，将自动安装开发工具（称为 R-core-devel）。"
  },
  {
    "objectID": "setup.html#verify-system-prep",
    "href": "setup.html#verify-system-prep",
    "title": "2  System setup",
    "section": "\n2.4 Verify system prep",
    "text": "2.4 Verify system prep\n您可以使用 devtools::dev_sitrep() 请求 “(package) development situation report”：\n\ndevtools::dev_sitrep()\n#> ── R ───────────────────────────────────────────────────────────────────────\n#> • version: 4.1.2\n#> • path: '/Library/Frameworks/R.framework/Versions/4.1/Resources/'\n#> ── RStudio ─────────────────────────────────────────────────────────────────\n#> • version: 2022.2.0.443\n#> ── devtools ────────────────────────────────────────────────────────────────\n#> • version: 2.4.3.9000\n#> • devtools or its dependencies out of date:\n#>   'gitcreds', 'gh'\n#>   Update them with `devtools::update_packages(\"devtools\")`\n#> ── dev package ─────────────────────────────────────────────────────────────\n#> • package: 'rpkgs'\n#> • path: '/Users/jenny/rrr/r-pkgs/'\n#> • rpkgs dependencies out of date:\n#>   'gitcreds', 'generics', 'tidyselect', 'dplyr', 'tidyr', 'broom', 'gh'\n#>  Update them with `devtools::install_dev_deps()`\n\n如果这表明某些工具或包丢失或已过时，我们鼓励您更新它们。"
  },
  {
    "objectID": "structure.html#sec-package-states",
    "href": "structure.html#sec-package-states",
    "title": "3  Package structure and state",
    "section": "\n3.1 Package states",
    "text": "3.1 Package states\n当你创建或修改一个包时，需要在它的源代码（“source code”）或源文件（“source files”）上进行。 您能够以源代码（source）的形式与正在开发的程序包进行交互。 这不是您在日常使用中最熟悉的包形式。 如果您了解 R 程序包可能处于的五种状态，那么程序包开发的工作流将变得更有意义：\n\n源代码（source）\n捆绑的（bundled）\n二进制文件（binary）\n已安装的（installed）\n载入内存中的（in-memory）\n\n您已经知道一些将程序包转入这些状态的函数。 例如，install.packages() 可以将包从源码（source）、捆绑（bundled）或二进制（binary）状态移动到已安装（installed）状态。 devtools::install_github() 获取 GitHub 上的源码（source）包并将其移至已安装（installed）状态。 library() 函数的作用是：将已安装的程序包加载到内存中，以便可以马上直接使用。"
  },
  {
    "objectID": "structure.html#sec-source-package",
    "href": "structure.html#sec-source-package",
    "title": "3  Package structure and state",
    "section": "\n3.2 Source package",
    "text": "3.2 Source package\n一个源码（source）程序包就是一个有着特定结构的文件目录。 它包含特定的组件，例如一个 DESCRIPTION 文件、包含 .R 文件的 R/ 目录等。 本书余下的大部分章节都致力于详细说明这些组成部分。\n如果您刚刚接触 R 程序包的开发，那么您可能从未见过源码（source）形式的程序包！ 您的计算机上可能甚至没有任何源码程序包。 以源码形式查看程序包的最简单的方法是在 web 上浏览其代码。\n许多 R 程序包是在 GitHub（或者 GitLab 以及类似的平台）上的公开库中开发的。 最好的方案是访问程序包的 CRAN 主页，例如：\n\nforcats: https://cran.r-project.org/package=forcats\n\nreadxl: https://cran.r-project.org/package=readxl\n\n\n并且其中一个网页链接（URLs）链接到公共托管服务上的存储库（repository），例如：\n\nforcats: https://github.com/tidyverse/forcats\n\nreadxl: https://github.com/tidyverse/readxl\n\n\n即使程序包是在公共存储库中开发的，一些维护人员还是忘记了列出这个网页链接（URL），但是您仍然可以通过搜索来发现它。\n即使程序包不是在公共平台上开发的，也可以在 unofficial, read-only mirror maintained by R-hub 中访问其源代码。 示例：\n\nMASS: https://github.com/cran/MASS\n\ncar: https://github.com/cran/car\n\n\n请注意，在 cran GitHub 组织内探索包的源码和历史记录与探索包的真正开发场所不同，因为此源码及其演变只是从包的 CRAN 版本进行逆向工程。 它提供了对程序包及其开发历史的审查视图，但根据定义，源代码及其历史包含了所有程序包开发的必需的内容。"
  },
  {
    "objectID": "structure.html#sec-bundled-package",
    "href": "structure.html#sec-bundled-package",
    "title": "3  Package structure and state",
    "section": "\n3.3 Bundled package",
    "text": "3.3 Bundled package\n捆绑的（bundled）程序包是被压缩成单个文件的程序包。 按照惯例（该惯例来自 Linux），R 中的捆绑程序包使用 .tar.gz 扩展名，并且有时被称为源码压缩包（“source tarballs”）。 这意味着多个文件已经被打包为一个文件（.tar）并使用 gzip（.gz）进行压缩。 虽然捆绑程序包本身并不那么有用，但它是源码包和已安装包之间平台无关的、便于传输的中间媒介。\n在从本地开发的程序包中生成捆绑程序包这种罕见的情况下，请使用 devtools::build()。 在幕后，它会调用 pkgbuild::build() 并最终调用 R CMD build，这些会在 Writing R Extensions 的 Building package tarballs 部分中进一步阐述。\n这应该会提醒您，捆绑程序包或源码压缩包不仅仅是对源文件进行 tar 打包存档，然后使用 gzip 压缩的结果。 按照惯例，在 R 世界中，在制作 .tar.gz 文件时还要执行一些操作。 这就是我们选择将其称为捆绑（bundle）程序包的原因。\n每个 CRAN 包都可以通过其登陆页面的 “Package source” 字段以捆绑（bundled）形式提供。 继续我们上面的示例，您可以下载 forcats_0.4.0.tar.gz 和 readxl_1.3.1.tar.gz 的捆绑包（或者任何当前的版本）。 您可以在 shell（而不是 R 控制台）中进行解压缩：\ntar xvf forcats_0.4.0.tar.gz\n如果您解压缩一个捆绑包，您将看到它看起来几乎与源码包相同。 Figure 3.1 显示了名为 zzzpackage 的虚构包的源码（source）、捆绑（bundled）、二进制（binary）形式的文件。 我们特意制作了这个示例，以包含本书中涵盖的大部分包部分。 并非每个包都包含此处看到的每个文件，此图也不包含可能出现在包中的每个可能文件。\n\n\n\n\nFigure 3.1: Package forms: source vs. bundled vs. binary.\n\n\n\n\n源码（source）包和未压缩的捆绑（bundle）包之间的主要区别为：\n\n已经生成了 Vignettes，因此以已渲染的输出（如 HTML）出现在 inst/doc/ 目录下，并且 Vignette 索引出现在 build/ 目录中。\n本地源码包可能包含用于在开发期间节省时间的临时文件，如 src/ 中的编译文件。 这些文件从来没有在捆绑包中找到过。\n.Rbuildignore 中列出的任何文件都不包含在捆绑包中。 这些文件通常有助于您的开发过程，但应该从分发式的产品中排除。\n\n\n3.3.1 .Rbuildignore\n\n您不需要非常频繁地考虑 .tar.gz 文件形式的程序包的确切结构，但您确实需要了解 .Rbuildignore 文件。 它决定了源码包中的哪些文件可以进入后面的工作流。\n.Rbuildignore 的每一行都是与 Perl 兼容的正则表达式，不考虑大小写，它与源码包中每个文件的路径匹配1。 如果与正则表达式匹配，则排除该文件或目录。 注意，有一些默认排除项由 R 本身执行，主要与经典的版本控制系统和编辑器（如 SVN、Git 和 Emacs）有关。\n我们通常使用 usethis::use_build_ignore() 函数修改 .Rbuildignore，它负责处理容易忘记的细节，例如正则表达式锚定和转义。 要排除特定文件或目录（最常见的使用示例），您必须锚定（anchor）正则表达式。 例如，要排除名为 “notes” 的目录，.Rbuildignore 条目必须是 ^notes$，而未锚定的正则表达式 notes 将匹配任何包含 “notes” 的文件名，例如 R/notes.R、man/important-notes.R、data/endnotes.Rdata 等。 我们发现 use_build_ignore() 可以帮助我们一次性获得更多的 .Rbuildignore 条目。\n.Rbuildignore 是解决让您更便利地开发的操作与 CRAN 提交和分发的要求之间一些紧张关系的一种方法 (Chapter 22)。 即使您不打算在 CRAN 上发布，遵循这些约定能让您最好地使用 R 的内置工具来检查和安装程序包。 你应该 .Rbuildignore 的文件分为两个广泛的、半重叠的类别：\n\n帮助您以编程方式生成程序包内容的文件。例如：\n\n使用 README.Rmd 生成信息丰富的最新 README.md（Section 18.1）。\n存储 .R 脚本以创建和更新内部或导出数据（Section 7.1.1）。\n\n\n驱动程序包开发、检查和产生文档的文件，不在 CRAN 的范围内。例如：\n\n与 RStudio IDE 相关的文件（Section 4.2）。\n使用 pkgdown package 生成网站（Chapter 19）。\n与持续集成/部署相关的配置文件（Section 20.2）。\n\n\n\n以下是 tidyverse 中程序包的 .Rbuildignore 文件中典型条目的非完整列表：\n^.*\\.Rproj$         # Designates the directory as an RStudio Project\n^\\.Rproj\\.user$     # Used by RStudio for temporary files\n^README\\.Rmd$       # An Rmd file used to generate README.md\n^LICENSE\\.md$       # Full text of the license\n^cran-comments\\.md$ # Comments for CRAN submission\n^data-raw$          # Code used to create data included in the package\n^pkgdown$           # Resources used for the package website\n^_pkgdown\\.yml$     # Configuration info for the package website\n^\\.github$          # GitHub Actions workflows\n请注意，上面的注释不能出现在实际的 .Rbuildignore 文件中；此处包含这些注释只是为了演示。\n我们会在需要的时候提到何时需要向 .Rbuildignore 中添加排除项。 请记住 usethis::use_build_ignore() 是管理此文件的一种有吸引力的方法。 此外，许多使用此功能添加应在 .Rbuildignore 中列出的文件会自动处理此问题。 例如，use_read_rmd() 将 “^README\\.Rmd$” 添加到 .Rbuildignore。"
  },
  {
    "objectID": "structure.html#sec-structure-binary",
    "href": "structure.html#sec-structure-binary",
    "title": "3  Package structure and state",
    "section": "\n3.4 Binary package",
    "text": "3.4 Binary package\n如果要将程序包分发给没有程序包开发工具的 R 用户，则需要提供二进制（binary）包。 二进制包的主要制造者和分发者是 CRAN，而不是个人维护者。 但是，即使您将分发包的责任委托给 CRAN，维护者了解二进制包的性质仍然很重要。\n与捆绑包一样，二进制包是单个文件。 与捆绑包不同，二进制包是特定于平台的，有两种基本风格：Windows 和 macOS。 （Linux 用户通常需要拥有从 .tar.gz 文件安装所需的工具，尽管像 Posit Public Package Manager 这样的资源的出现让 Linux 用户可以像他们在 Windows 和 macOS 上的同事一样访问二进制包。）\nmacOS 的二进制包存储为 .tgz，而 Windows 二进制包以 .zip 结尾。 如果需要制作二进制包，请在相关操作系统上使用 devtools::build(binary = TRUE)。 在幕后，这会调用 pkgbuild::build(binary = TRUE) 并最终调用 R CMD INSTALL --build，这在 Writing R Extensions 的 Building binary packages 部分中有进一步描述。 如果你选择在 CRAN 上发布你的包（Chapter 22），你以捆绑形式提交你的包，然后 CRAN 创建并分发包二进制文件。\n不论是 macOS 或 Windows，还是 R 的当前、先前和（可能的）开发版本，CRAN 通常都能以二进制包形式提供。 继续我们上面的例子，您能够下载二进制包，例如：\n\nforcats for macOS: forcats_0.4.0.tgz\n\nreadxl for Windows: readxl_1.3.1.zip\n\n\n事实上，这是您在调用 isntall.packages() 时通常进行的部分幕后操作。\n如果解压缩二进制包，您将看到它的内部结构与源码包或捆绑包有很大不同。 Figure 3.1 包含了二者的比较。 以下是一些最显著的区别：\n\n在 R/ 目录中没有 .R 文件，而是有三个文件以有效的文件格式存储着解析的函数。 这基本上是加载所有 R 代码，然后用 save() 保存函数的结果。 （在这个过程中，这会添加一些额外的 metadata，使得过程尽可能地快）。\nMeta/ 目录中包含许多 .rds 文件。 这些文件包含有关包的缓存 metadata，如帮助文件所涵盖的主题和 DESCRIPTION 文件的解析版本。 （您可以使用 readRDS() 查看这些文件中的内容）。 这些文件通过缓存代价高昂的计算使程序包更快地加载。\n实际的帮助内容出现在 help/ 和 html/（不再出现在 man/）中。\n如果 src/ 目录中有任何代码，那么现在将有一个 libs/ 目录，其中包含经过编译的代码。\n如果 data/ 中有任何对象，则它们现在已转换为更具效率的形式。\ninst/ 的内容被移动到顶层目录。 例如，vignette 文件现在位于 doc/ 中。\n一些文件和文件夹已被删除，如 README.md、build/、tests/ 和 vignettes/。"
  },
  {
    "objectID": "structure.html#sec-installed-package",
    "href": "structure.html#sec-installed-package",
    "title": "3  Package structure and state",
    "section": "\n3.5 Installed package",
    "text": "3.5 Installed package\n已安装的（installed）包是已解压缩到程序包库中的二进制包（described in Section 3.7）。 Figure 3.2 说明了安装程序包的多种方法，以及将软件包从一种状态转换为另一种状态的一些其他函数。 这个图表很复杂！在理想情况下，安装包需要将一组简单的步骤串在一起：source -> bundle, bundle -> binary, binary -> installed。 在现实世界中，这个过程并不是这么简单，因为通常有（更快的）快捷方式可用。\n\n\n\n\nFigure 3.2: Many methods for converting between package states.\n\n\n\n\n内置命令行工具 R CMD INSTALL 支持所有程序包的安装。 它可以从源码文件、捆绑包、或二进制包安装程序包。 有关详细信息，请参阅 R Installation and Administration 的 Installing packages 部分。 与 devtools::build() 一样，devtools 提供了一个包装函数 devtools::install()，使该工具在 R 会话（R Session）中可用。\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 可以帮助您安装开发中的包，通过 Build 窗格中的 Install 和 More 下拉菜单以及 Build 菜单中的 Install Package。\n\n\n可以理解，大多数用户喜欢 R 会话（R Session）的舒适性，因此直接从 CRAN 安装软件包。 内置函数 install.packages() 满足了这一需要。 它可以以各种形式下载程序包并安装它，还可以选择程序包依赖项的安装。\n然而，从 R 会话中安装 R 包的便利性是有代价的。 如您所料，重新安装已在当前会话中使用的包可能有点棘手。 这实际上大部分时间都有效，但有时却无效，尤其是在 Windows 上安装带有编译代码的 R 包时。 由于文件句柄在 Windows 上的锁定方式，尝试安装正在使用的包的新版本可能会导致安装损坏，其中包的 R 代码已更新，但其编译代码尚未更新。 排除故障时，Windows 用户应努力在干净的 R 会话中安装包，并加载尽可能少的包。\npak 包 (https://pak.r-lib.org/) 相对较新（在撰写本文时），它提供了一个有前途的替代 install.packages() 以及其他更专业的功能，例如 devtools::install_github()。 现在全面推荐使用 pak 来满足您的所有软件包安装需求还为时过早，但我们肯定在我们的个人工作流程中越来越多地使用它。 pak 的旗舰功能之一是它很好地解决了上述 “locked DLL” 问题，即在 Windows 上使用编译代码更新包。 随着您对包开发的深入，您会发现自己正在执行一组全新的任务，例如从开发中的分支安装依赖项或仔细检查包依赖项树。 pak 为这个任务和许多其他相关任务提供了一个丰富的工具包。 我们预计 pak 将很快成为我们关于如何安装软件包（以及更多）的官方推荐。\n然而，与此同时，我们描述了现状。 devtools 长期以来一直提供一系列 install_*() 函数来解决一些超出 install.packages() 范围的需求，或者使现有功能更容易访问。 这些功能实际上是在 remotes package 中维护的，并由 devtools 重新导出。 （鉴于我们上面所说的，remotes 很可能会在本质上被取代，取而代之的是 pak，但我们还没有到那一步。）\n\nlibrary(remotes)\n\nfuns <- as.character(lsf.str(\"package:remotes\"))\ngrep(\"^install_.+\", funs, value = TRUE)\n#>  [1] \"install_bioc\"      \"install_bitbucket\" \"install_cran\"     \n#>  [4] \"install_deps\"      \"install_dev\"       \"install_git\"      \n#>  [7] \"install_github\"    \"install_gitlab\"    \"install_local\"    \n#> [10] \"install_remote\"    \"install_svn\"       \"install_url\"      \n#> [13] \"install_version\"\n\ninstall_github() 是这些函数中最有用的一个，也显示在 Figure 3.2 中。 它是一系列功能的最佳示例，可以从非 CRAN 的远程位置下载包，并执行安装包所需的任何操作。 其余的 devtools/remotes install_*() 函数旨在使基本工具在技术上更简单或更明确一些，例如 install_version()，它能够安装特定版本的 CRAN 包。\n与 .Rbuildignore 类似，如 Section 3.3.1 所述，.Rinstignore 允许您将捆绑包中的文件保留在已安装包之外。 然而，与 .Rbuildignore 相反，这个功能相当模糊，而且很少需要这样做。"
  },
  {
    "objectID": "structure.html#in-memory-package",
    "href": "structure.html#in-memory-package",
    "title": "3  Package structure and state",
    "section": "\n3.6 In-memory package",
    "text": "3.6 In-memory package\n我们终于讲述到了一个每个使用 R 的人都熟悉的命令。\n\nlibrary(usethis)\n\n假设已经安装了 usethis，这个语句将使得里面的所有函数可用，即现在我们可以执行以下操作：\n\ncreate_package(\"/path/to/my/coolpackage\")\n\n这样，usethis 包已加载到内存中，并且实际上也已附加到搜索路径。 在编写脚本时，加载和附加程序包之间的区别并不重要，但在编写程序包时非常重要。 您将在 Section 10.4 中了解更多关于差异及其重要性的信息。\nlibrary() 并不是迭代调整和测试正在开发的程序包的好方法，因为它只适用于已安装的包。 在 Section 4.4 中，您将了解 devtools::load_all() 如何通过允许您将源码包直接加载到内存中来加速开发过程。"
  },
  {
    "objectID": "structure.html#sec-library",
    "href": "structure.html#sec-library",
    "title": "3  Package structure and state",
    "section": "\n3.7 Package libraries",
    "text": "3.7 Package libraries\n我们刚刚讨论了 library() 函数，它的名字源于它的作用。 当你调用 library(somepackage) 时，R 会在当前 libraries 中查找一个叫做 “somepackage” 的已安装包，如果成功了，R 将让 somepackage 变得可以使用。\n在 R 中，一个 library 就是一个包含了已安装程序包的目录，有点像图书库。 不幸的是，在 R 的世界，您将会经常遇到 “library” 和 “package” 的混淆用法。 例如，dplyr 是一个 package，但是通常有人将其称为一个 library。 造成这种混乱的原因有几个。 首先，R 的术语可以说是与更广泛的编程约定背道而驰的，“library” 的通常含义更接近于我们所说的 “package”。 library() 函数本身的名称可能会强化这一错误的关联。 最后，这种词汇错误通常是无害的，因此 R 用户很容易养成错误的习惯，而指出这个错误的人看起来像是令人无法忍受的学究。 但底线是：\n\n我们使用 library() 函数加载一个 package2。\n\n当您参与包开发时，两者之间的区别是重要且有用的。\n您的计算机上可以有多个 libraries。 事实上，你们中的很多人已经这样做了，尤其是在 Windows 上。 可以使用 .libPaths() 查看当前处于活动状态的 libraries。 在 Windows 上看起来如下：\n\n# on Windows\n.libPaths()\n#> [1] \"C:/Users/jenny/Documents/R/win-library/4.2\"\n#> [2] \"C:/Program Files/R/R-4.2.2/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#> [[1]]\n#>   [1] \"abc\"           \"anytime\"       \"askpass\"       \"assertthat\"   \n#>  ...\n#> [145] \"zeallot\"      \n#> \n#> [[2]]\n#>  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#>  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#>  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#> [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#> [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#> [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#> [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#> [29] \"translations\" \"utils\"\n\n在 macOS 上看起来类似（但您的结果可能会有所不同）:\n\n# on macOS\n.libPaths()\n#> [1] \"/Users/jenny/Library/R/arm64/4.2/library\"\n#> [2] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#> [[1]]\n#>    [1] \"abc\"                  \"abc.data\"             \"abind\"                \n#>  ...\n#> [1033] \"Zelig\"                \"zip\"                  \"zoo\"                 \n#> \n#> [[2]]\n#>  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#>  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#>  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#> [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#> [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#> [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#> [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#> [29] \"translations\" \"utils\"\n\n在这两种情况下，我们可以看到两个活动库，它们的查询顺序如下：\n\n用户库\n系统级或全局库\n\n这样的设置是 Windows 上的经典设置，但通常是 macOS 和 Linux 上需要选择的设置3。 在这样的设置之下，从 CRAN（或其他地方）安装的或本地开发的附加程序包保存在用户库中。 和上面一样，macOS 系统被用作主要的开发机器，这里有很多软件包（~1000），而 Windows 系统只是偶尔使用，而且要简朴得多。 R 附带的基本和推荐程序包的核心集位于系统级库中，这一点在 macOS 和 Windows 上是相同的。 这种分离对许多开发人员很有吸引力，例如，在不干扰 base R 的安装的情况下使得清理附加包变得很容易。\n如果您在 macOS 或 Linux 上只看到一个库，并不需要紧急更改任何内容。 但下次升级 R 时，请考虑创建一个用户级库。 默认情况下，R 查找存储在环境变量 R_LIBS_USER 中的路径下的用户库，在 macOS 上默认为 ~/Library/R/x.y/library，在 Linux 上默认为 ~/R/m-library/x.y（其中 m 是 CPU 架构的简明描述，x.y 是 R 版本）。 您可以使用 Sys.getenv(\"R_LIBS_USER\") 查看此路径。 默认情况下这些目录不存在，必须通过创建目录来启用它们。 安装新版本的 R 时，在安装任何附加包之前，请使用 dir.create(Sys.getenv(\"R_LIBS_USER\"), recursive = TRUE) 在默认位置创建用户库。 现在您将拥有上面看到的库设置。 或者，您可以在其他地方设置用户库，并通过在 .Renviron 中设置 R_LIBS_USER 环境变量来告诉 R。 编辑 .Renviron 文件的最简单方法是使用 usethis::edit_r_environ()，如果文件不存在，它将创建该文件，并打开它进行编辑。\n这些库的文件路径也清楚地表明它们与特定版本的 R（在编写本文时是 4.2.x）相关联，这也是经典的。 这反映并强化了这样一个事实：当您将 R 从 4.1 更新到 4.2，即一个在次要（minor）版本上的更改时，您需要重新安装附加程序包。 对于在补丁（patch）版本上的更改，例如从 R 4.2.1 到 4.2.2，通常不需要重新安装附加程序包。\n随着 R 的使用变得越来越复杂，开始更加有意地管理程序包库是十分平常的。 例如，像 renv（及其前身 packrat）这样的工具可以使管理项目特定库的过程自动化。 这对于使数据产品具有可复制性、可移植性和相互隔离性非常重要。 程序包开发人员可能会在库的搜索路径前添加一个临时库，其中包含一组特定版本的程序包，以便在不影响其他日常工作的情况下探索前后兼容性问题。 反向依赖性检查（Reverse dependency checks）是另一个显式管理库的搜索路径的例子。\n以下是按范围和持久性顺序控制哪些库处于活动状态的主要杠杆：\nHere are the main levers that control which libraries are active, in order of scope and persistence:\n\n环境变量，如 R_LIBS 和 R_LIBS_USER，它们在启动时被查询。\n使用一个或多个文件路径调用 .libPaths()。\n通过 withr::with_libpaths() 使用临时更改的库搜索路径执行小型的代码段。\n单个函数的参数，比如 install.packages(lib =) 和 library(lib.loc =)。\n\n最后，需要注意的是，library() 永远不应该在程序包中使用。 程序包和脚本依赖于不同的机制来声明它们的依赖性，这是您需要在您的心理模型和习惯中做出的最大调整之一。 我们将在 Section 9.6 和 Chapter 11 全面探讨这个话题。"
  }
]