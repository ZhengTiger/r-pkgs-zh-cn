[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Packages (2e)",
    "section": "",
    "text": "Welcome!\nWelcome to R packages by Hadley Wickham and Jennifer Bryan. Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data. In this book you’ll learn how to turn your code into packages that others can easily download and use. Writing a package can seem overwhelming at first. So start with the basics and improve it over time. It doesn’t matter if your first version isn’t perfect as long as the next version is better.\nThis is the online version of the 2nd edition of the book."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-evolution",
    "href": "lifecycle.html#sec-lifecycle-evolution",
    "title": "21  Lifecycle",
    "section": "\n21.1 Package evolution",
    "text": "21.1 Package evolution\nFirst we should establish a working definition of what it means for your package to change. Technically, you could say that the package has changed every time any file in its source changes. This level of pedantry isn’t terribly useful, though. The smallest increment of change that’s meaningful is probably a Git commit. This represents a specific state of the source package that can be talked about, installed from, compared to, subjected to R CMD check, reverted to, and so on. This level of granularity is really only of interest to developers. But the package states accessible via the Git history are genuinely useful for the maintainer, so if you needed any encouragement to be more intentional with your commits, let this be it.\nThe primary signal of meaningful change is to increment the package version number and release it, for some definition of release, such as releasing on CRAN (Chapter 22). Recall that this important piece of metadata lives in the Version field of the DESCRIPTION file:\nPackage: usethis\nTitle: Automate Package and Project Setup\nVersion: 2.1.6\n...\nIf you visit the CRAN landing page for usethis, you can access its history via Downloads > Old sources > usethis archive. That links to a folder of package bundles (Section 3.3), reflecting usethis’s source for each version released on CRAN, presented in Table 21.1:\n\n#> Warning: package 'tidyverse' was built under R version 4.2.3\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n#> Warning: package 'tibble' was built under R version 4.2.3\n#> Warning: package 'tidyr' was built under R version 4.2.3\n#> Warning: package 'readr' was built under R version 4.2.3\n#> Warning: package 'purrr' was built under R version 4.2.3\n#> Warning: package 'dplyr' was built under R version 4.2.3\n#> Warning: package 'stringr' was built under R version 4.2.2\n#> Warning: package 'forcats' was built under R version 4.2.3\n#> Warning: package 'lubridate' was built under R version 4.2.3\n#> Warning: package 'pkgsearch' was built under R version 4.2.3\n\n\n\nTable 21.1: Releases of the usethis package.\n\nVersion\nDate\n\n\n\n1.0.0\n2017-10-22 17:36:29 UTC\n\n\n1.1.0\n2017-11-17 22:52:07 UTC\n\n\n1.2.0\n2018-01-19 18:23:54 UTC\n\n\n1.3.0\n2018-02-24 21:53:51 UTC\n\n\n1.4.0\n2018-08-14 12:10:02 UTC\n\n\n1.5.0\n2019-04-07 10:50:44 UTC\n\n\n1.5.1\n2019-07-04 11:00:05 UTC\n\n\n1.6.0\n2020-04-09 04:50:02 UTC\n\n\n1.6.1\n2020-04-29 05:50:02 UTC\n\n\n1.6.3\n2020-09-17 17:00:03 UTC\n\n\n2.0.0\n2020-12-10 09:00:02 UTC\n\n\n2.0.1\n2021-02-10 10:40:06 UTC\n\n\n2.1.0\n2021-10-16 23:30:02 UTC\n\n\n2.1.2\n2021-10-25 07:30:02 UTC\n\n\n2.1.3\n2021-10-27 15:00:02 UTC\n\n\n2.1.5\n2021-12-09 23:00:02 UTC\n\n\n2.1.6\n2022-05-25 20:50:02 UTC\n\n\n2.2.0\n2023-06-06 09:30:02 UTC\n\n\n\n\n\n\nThis is the type of package evolution we’re going to address in this chapter. In Section 21.2, we’ll delve into the world of software version numbers, which is a richer topic than you might expect. R also has some specific rules and tools around package version numbers. Finally, we’ll explain the conventions we use for the version numbers of tidyverse packages (Section 21.3).\nBut first, this is a good time to revisit a resource we first pointed out in Section 3.2, when introducing the different states of an R package. Recall that the (unofficial) cran organization on GitHub provides a read-only history of all CRAN packages. For example, you can get a different view of usethis’s released versions at https://github.com/cran/usethis/.\nThe archive provided by CRAN itself allows you to download older versions of usethis as .tar.gz files, which is useful if you truly want to get your hands on the source of an older version. However, if you just want to quickly check something about a version or compare two versions of usethis, the read-only GitHub mirror is much more useful. Each commit in this repo’s history represents a CRAN release, which makes it easy to see exactly what changed: https://github.com/cran/usethis/commits/HEAD. Furthermore, you can browse the state of all the package’s source files at any specific version, such as usethis’s initial release at version 1.0.01.\nThis information is technically available from the repository where usethis is actually developed (https://github.com/r-lib/usethis). But you have to work much harder to zoom out to the level of CRAN releases, amid the clutter of the small incremental steps in which development actually unfolds. These three different views of usethis’s evolution are all useful for different purposes:\n\nhttps://cran.r-project.org/src/contrib/Archive/usethis/: the official CRAN package bundles.\nhttps://github.com/cran/usethis/commits/HEAD: the unofficial read-only CRAN mirror, obtained by unpacking CRAN’s bundles.\nhttps://github.com/r-lib/usethis/commits/HEAD: the official development home for usethis."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number",
    "href": "lifecycle.html#sec-lifecycle-version-number",
    "title": "21  Lifecycle",
    "section": "\n21.2 Package version number",
    "text": "21.2 Package version number\nFormally, an R package version is a sequence of at least two integers separated by either . or -. For example, 1.0 and 0.9.1-10 are valid versions, but 1 and 1.0-devel are not. Base R offers the utils::package_version()2 function to parse a package version string into a proper S3 class by the same name. This class makes it easier to do things like compare versions.\n\npackage_version(c(\"1.0\", \"0.9.1-10\"))\n#> [1] '1.0'      '0.9.1.10'\nclass(package_version(\"1.0\"))\n#> [1] \"package_version\" \"numeric_version\"\n\n# these versions are not allowed for an R package\npackage_version(\"1\")\n#> Error: invalid version specification '1'\npackage_version(\"1.0-devel\")\n#> Error: invalid version specification '1.0-devel'\n\n# comparing package versions\npackage_version(\"1.9\") == package_version(\"1.9.0\")\n#> [1] TRUE\npackage_version(\"1.9\") < package_version(\"1.9.2\")\n#> [1] TRUE\npackage_version(c(\"1.9\", \"1.9.2\")) < package_version(\"1.10\")\n#> [1] TRUE TRUE\n\nThe last examples above make it clear that R considers version 1.9 to be equal to 1.9.0 and to be less than 1.9.2. And both 1.9 and 1.9.2 are less than 1.10, which you should think of as version “one point ten”, not “one point one zero”.\nIf you’re skeptical that the package_version class is really necessary, check out this example:\n\n\"2.0\" > \"10.0\"\n#> [1] TRUE\npackage_version(\"2.0\") > package_version(\"10.0\")\n#> [1] FALSE\n\nThe string 2.0 is considered to be greater than the string 10.0, because the character 2 comes after the character 1. By parsing version strings into proper package_version objects, we get the correct comparison, i.e. that version 2.0 is less than version 10.0.\nR offers this support for working with package versions, because it’s necessary, for example, to determine whether package dependencies are satisfied (Section 9.6.1). Under-the-hood, this tooling is used to enforce minimum versions recorded like this in DESCRIPTION:\nImports:\n    dplyr (>= 1.0.0),\n    tidyr (>= 1.1.0)\nIn your own code, if you need to determine which version of a package is installed, use utils::packageVersion()3:\n\npackageVersion(\"usethis\")\n#> [1] '2.2.0'\nstr(packageVersion(\"usethis\"))\n#> Classes 'package_version', 'numeric_version'  hidden list of 1\n#>  $ : int [1:3] 2 2 0\n\npackageVersion(\"usethis\") > package_version(\"10.0\")\n#> [1] FALSE\npackageVersion(\"usethis\") > \"10.0\"\n#> [1] FALSE\n\nThe return value of packageVersion() has the package_version class and is therefore ready for comparison to other version numbers. Note the last example where we seem to be comparing a version number to a string. How can we get the correct result without explicitly converting 10.0 to a package version? It turns out this conversion is automatic as long as one of the comparators has the package_version class."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "href": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "title": "21  Lifecycle",
    "section": "\n21.3 Tidyverse package version conventions",
    "text": "21.3 Tidyverse package version conventions\nR considers 0.9.1-10 to be a valid package version, but you’ll never see a version number like that for a tidyverse package. Here is our recommended framework for managing the package version number:\n\nAlways use . as the separator, never -.\nA released version number consists of three numbers, <major>.<minor>.<patch>. For version number 1.9.2, 1 is the major number, 9 is the minor number, and 2 is the patch number. Never use versions like 1.0. Always spell out the three components, 1.0.0.\n\nAn in-development package has a fourth component: the development version. This should start at 9000. The number 9000 is arbitrary, but provides a clear signal that there’s something different about this version number. There are two reasons for this practice: First, the presence of a fourth component makes it easy to tell if you’re dealing with a released or in-development version. Also, the use of the fourth place means that you’re not limited to what the next released version will be. 0.0.1, 0.1.0, and 1.0.0 are all greater than 0.0.0.9000.\nIncrement the development version, e.g. from 9000 to 9001, if you’ve added an important feature and you (or others) need to be able to detect or require the presence of this feature. For example, this can happen when two packages are developing in tandem. This is generally the only reason that we bother to increment the development version. This makes in-development versions special and, in some sense, degenerate. Since we don’t increment the development component with each Git commit, the same package version number is associated with many different states of the package source, in between releases.\n\n\nThe advice above is inspired in part by Semantic Versioning and by the X.Org versioning schemes. Read them if you’d like to understand more about the standards of versioning used by many open source projects. But we should underscore that our practices are inspired by these schemes and are somewhat less regimented. Finally, know that other maintainers follow different philosophies on how to manage the package version number."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "title": "21  Lifecycle",
    "section": "\n21.4 Backward compatibility and breaking change",
    "text": "21.4 Backward compatibility and breaking change\nThe version number of your package is always increasing, but it’s more than just an incrementing counter – the way the number changes with each release can convey information about the nature of the changes. The transition from 0.3.1 to 0.3.2, which is a patch release, has a very different vibe from the transition from 0.3.2 to 1.0.0, which is a major release. A package version number can also convey information about where the package is in its lifecycle. For example, the version 1.0.0 often signals that the public interface of a package is considered stable.\nHow do you decide which type of release to make, i.e. which component(s) of the version should you increment? A key concept is whether the associated changes are backward compatible, meaning that pre-existing code will still “work” with the new version. We put “work” in quotes, because this designation is open to a certain amount of interpretation. A hardliner might take this to mean “the code works in exactly the same way, in all contexts, for all inputs”. A more pragmatic interpretation is that “the code still works, but could produce a different result in some edge cases”. A change that is not backward compatible is often described as a breaking change. Here we’re going to talk about how to assess whether a change is breaking. In Section 21.6 we’ll talk about how to decide if a breaking change is worth it.\nIn practice, backward compatibility is not a clear-cut distinction. It is typical to assess the impact of a change from a few angles:\n\nDegree of change in behaviour. The most extreme is to make something that used to be possible into an error, i.e. impossible.\nHow the changes fit into the design of the package. A change to low-level infrastructure, such as a utility that gets called in all user-facing functions, is more fraught than a change that only affects one parameter of a single function.\nHow much existing usage is affected. This is a combination of how many of your users will perceive the change and how many existing users there are to begin with.\n\nHere are some concrete examples of breaking change:\n\nRemoving a function\nRemoving an argument\nNarrowing the set of valid inputs to a function\n\nConversely, these are usually not considered breaking:\n\nAdding a function. Caveat: there’s a small chance this could introduce a conflict in user code.\nAdding an argument. Caveat: this could be breaking for some usage, e.g. if a user is relying on position-based argument matching. This also requires some care in a function that accepts ….\nIncreasing the set of valid inputs.\nChanging the text of a print method or error. Caveat: This can be breaking if other packages depend on yours in fragile ways, such as building logic or a test that relies on an error message from your package.\nFixing a bug. Caveat: It really can happen that users write code that “depends” on a bug. Sometimes such code was flawed from the beginning, but the problem went undetected until you fixed your bug. Other times this surfaces code that uses your package in an unexpected way, i.e. it’s not necessarily wrong, but neither is it right.\n\nIf reasoning about code was a reliable way to assess how it will work in real life, the world wouldn’t have so much buggy software. The best way to gauge the consequences of a change in your package is to try it and see what happens. In addition to running your own tests, you can also run the tests of your reverse dependencies and see if your proposed change breaks anything. The tidyverse team has a fairly extensive set of tools for running so-called reverse dependency checks (Section 22.5), where we run R CMD check on all the packages that depend on ours. Sometimes we use this infrastructure to study the impact of a potential change, i.e. reverse dependency checks can be used to guide development, not only as a last-minute, pre-release check. This leads to yet another, deeply pragmatic definition of a breaking change:\n\nA change is breaking if it causes a CRAN package that was previously passing R CMD check to now fail AND the package’s original usage and behavior is correct.\n\nThis is obviously a narrow and incomplete definition of breaking change, but at least it’s relatively easy to get solid data.\nHopefully we’ve made the point that backward compatibility is not always a clearcut distinction. But hopefully we’ve also provided plenty of concrete criteria to consider when thinking about whether a change could break someone else’s code."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-release-type",
    "href": "lifecycle.html#sec-lifecycle-release-type",
    "title": "21  Lifecycle",
    "section": "\n21.5 Major vs minor vs patch release",
    "text": "21.5 Major vs minor vs patch release\nRecall that a version number will have one of these forms, if you’re following the conventions described in Section 21.3:\n<major>.<minor>.<patch>        # released version\n<major>.<minor>.<patch>.<dev>  # in-development version\nIf the current package version is 0.8.1.9000, here’s our advice on how to pick the version number for the next release:\n\nIncrement patch, e.g. 0.8.2 for a patch release: you’ve fixed bugs, but you haven’t added any significant new features and there are no breaking changes. For example, if we discover a show-stopping bug shortly after a release, we would make a quick patch release with the fix. Most releases will have a patch number of 0.\nIncrement minor, e.g. 0.9.0, for a minor release. A minor release can include bug fixes, new features, and changes that are backward compatible4. This is the most common type of release. It’s perfectly fine to have so many minor releases that you need to use two (or even three!) digits, e.g. 1.17.0.\nIncrement major, e.g. 1.0.0, for a major release. This is the most appropriate time to make changes that are not backward compatible and that are likely to affect many users. The 1.0.0 release has special significance and typically indicates that your package is feature complete with a stable API.\n\nThe trickiest decision you are likely to face is whether a change is “breaking” enough to deserve a major release. For example, if you make an API-incompatible change to a rarely-used part of your code, it may not make sense to increase the major number. But if you fix a bug that many people depend on (it happens!), it will feel like a breaking change to those folks. It’s conceivable that such a bug fix could merit a major release.\nWe’re mostly dwelling on breaking change, but let’s not forget that sometimes you also add exciting new features to your package. From a marketing perspective, you probably want to save these for a major release, because your users are more likely to learn about the new goodies, from reading a blog post or NEWS.\nHere are a few tidyverse blog posts that have accompanied different types of package releases:\n\nMajor release: dplyr 1.0.0, purrr 1.0.0, pkgdown 2.0.0, readr 2.0.0\nMinor release: stringr 1.5.0, ggplot2 3.4.0\nPatch release: These are usually not considered worthy of a blog post.\n\n\n21.5.1 Package version mechanics\nYour package should start with version number 0.0.0.9000. usethis::create_package() starts with this version, by default.\nFrom that point on, you can use usethis::use_version() to increment the package version. When called interactively, with no argument, it presents a helpful menu:\n\nusethis::use_version()\n#> Current version is 0.1.\n#> What should the new version be? (0 to exit) \n#> \n#> 1: major --> 1.0\n#> 2: minor --> 0.2\n#> 3: patch --> 0.1.1\n#> 4:   dev --> 0.1.0.9000\n#> \n#> Selection: \n\nIn addition to incrementing Version in DESCRIPTION (Chapter 9), use_version() also adds a new heading in NEWS.md (Section 18.2)."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "title": "21  Lifecycle",
    "section": "\n21.6 Pros and cons of breaking change",
    "text": "21.6 Pros and cons of breaking change\nThe big difference between major and minor releases is whether or not the code is backward compatible. In the general software world, the idea is that a major release signals to users that it may contain breaking changes and they should only upgrade when they have the capacity to deal with any issues that emerge.\nReality is a bit different in the R community, because of the way most users manage package installation. If we’re being honest, most R users don’t manage package versions in a very intentional way. Given the way update.packages() and install.packages() work, it’s quite easy to upgrade a package to a new major version without really meaning to, especially for dependencies of the target package. This, in turn, can lead to unexpected exposure to breaking changes in code that previously worked. This unpleasantness has implications both for users and for maintainers.\nIf it’s important to protect a data product against change in its R package dependencies, we recommend the use of a project-specific package library. In particular, we like to implement this approach using the renv package. This supports a lifestyle where a user’s default package library is managed in the usual, somewhat haphazard way. But any project that has a specific, higher requirement for reproducibility is managed with renv. This keeps package updates triggered by work in project A from breaking the code in project B and also helps with collaboration and deployment.\nWe suspect that package-specific libraries and tools like renv are currently under-utilized in the R world. That is, lots of R users still use just one package library. Therefore, package maintainers still need to exercise considerable caution and care when they introduce breaking changes, regardless of what’s happening with the version number. In Section 21.7, we describe how tidyverse packages approach this, supported by tools in the lifecycle package.\nAs with dependencies (Section 10.1), we find that extremism isn’t a very productive stance. Extreme resistance to breaking change puts a significant drag on ongoing development and maintenance. Backward compatible code tends to be harder to work with because of the need to maintain multiple paths to support functionality from previous versions. The harder you strive to maintain backward compatibility, the harder it is to develop new features or fix old mistakes. This, in turn, can discourage adoption by new users and can make it harder to recruit new contributors. On the other hand, if you constantly make breaking changes, users will become very frustrated with your package and will decide they’re better off without it. Find a happy medium. Be concerned about backward compatibility, but don’t let it paralyze you.\nThe importance of backward compatibility is directly proportional to the number of people using your package: you are trading your time and pain for that of your users. There are good reasons to make backward incompatible changes. Once you’ve decided it’s necessary, your main priority is to use a humane process that is respectful of your users."
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-stages-and-package",
    "href": "lifecycle.html#sec-lifecycle-stages-and-package",
    "title": "21  Lifecycle",
    "section": "\n21.7 Lifecycle stages and supporting tools",
    "text": "21.7 Lifecycle stages and supporting tools\nThe tidyverse team’s approach to package evolution has become more structured and deliberate over the years. The associated tooling and documentation lives in the lifecycle package (lifecycle.r-lib.org). The approach relies on two major components:\n\nLifecycle stages, which can be applied at different levels, i.e. to an individual argument or function or to an entire package.\nConventions and functions to use when transitioning a function from one lifecycle stage to another. The deprecation process is the one that demands the most care.\n\nWe won’t duplicate too much of the lifecycle documentation here. Instead, we highlight the general principles of lifecycle management and present specific examples of successful lifecycle “moves”.\n\n21.7.1 Lifecycle stages and badges\n\n\n\n\nFigure 21.1: The four primary stages of the tidyverse lifecycle: stable, deprecated, superseded, and experimental.\n\n\n\n\nThe four lifecycle stages are:\n\nStable. This is the default stage and signals that users should feel comfortable relying on a function or package. Breaking changes should be rare and should happen gradually, giving users sufficient time and guidance to adapt their usage.\nExperimental. This is appropriate when a function is first introduced and the maintainer reserves the right to change it without much of a deprecation process. This is the implied stage for any package with a major version of 0, i.e. that hasn’t had a 1.0.0 release yet.\nDeprecated. This applies to functionality that is slated for removal. Initially, it still works, but triggers a deprecation warning with information about preferred alternatives. After a suitable amount of time and with an appropriate version change, such functions are typically removed.\nSuperseded. This is a softer version of deprecated, where legacy functionality is preserved as if in a time capsule. Superseded functions receive only minimal maintenance, such as critical bug fixes.\n\nYou can get much more detail in vignette(\"stages\", package = \"lifecycle\").\nThe lifecycle stage is often communicated through a badge. If you’d like to use lifecycle badges, call usethis::use_lifecycle() to do some one-time setup:\n\nusethis::use_lifecycle()\n#> ✔ Adding 'lifecycle' to Imports field in DESCRIPTION\n#> • Refer to functions with `lifecycle::fun()`\n#> ✔ Adding '@importFrom lifecycle deprecated' to 'R/somepackage-package.R'\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Creating 'man/figures/'\n#> ✔ Copied SVG badges to 'man/figures/'\n#> • Add badges in documentation topics by inserting one of:\n#>   #' `r lifecycle::badge('experimental')`\n#>   #' `r lifecycle::badge('superseded')`\n#>   #' `r lifecycle::badge('deprecated')`\n\nThis leaves you in a position to use lifecycle badges in help topics and to use lifecycle functions, as described in the remainder of this section.\nFor a function, include the badge in its @description block. Here’s how we indicate that dplyr::top_n() is superseded:\n\n#' Select top (or bottom) n rows (by value)\n#'\n#' @description\n#' `r lifecycle::badge(\"superseded\")`\n#' `top_n()` has been superseded in favour of ...\n\nFor a function argument, include the badge in the @param tag. Here’s how the deprecation of readr::write_file(path =) is documented:\n\n#' @param path `r lifecycle::badge(\"deprecated\")` Use the `file` argument\n#'   instead.\n\nCall usethis::use_lifecycle_badge() if you want to use a badge in README to indicate the lifecycle of an entire package (Section 18.1).\nIf the lifecycle of a package is stable, it’s not really necessary to use a badge, since that is the assumed default stage. Similarly, we typically only use a badge for a function if its stage differs from that of the associated package and likewise for an argument and the associated function.\n\n21.7.2 Deprecating a function\nIf you’re going to remove or make significant changes to a function, it’s usually best to do so in phases. Deprecation is a general term for the situation where something is explicitly discouraged, but it has not yet been removed. Various deprecation scenarios are explored in vignette(\"communicate\", package = \"lifecycle\"); we’re just going to cover the main idea here.\nThe lifecycle::deprecate_warn() function can be used inside a function to inform your user that they’re using a deprecated feature and, ideally, to let them know about the preferred alternative. In this example, the plus3() function is being replaced by add3():\n\n# new function\nadd3 <- function(x, y, z) {\n  x + y + z\n}\n\n# old function\nplus3 <- function(x, y, z) {\n  lifecycle::deprecate_warn(\"1.0.0\", \"plus3()\", \"add3()\")\n  add3(x, y, z)\n}\n\nplus3(1, 2, 3)\n#> Warning: `plus3()` was deprecated in somepackage 1.0.0.\n#> ℹ Please use `add3()` instead.\n#> [1] 6\n\nAt this point, a user who calls plus3() sees a warning explaining that the function has a new name, but we go ahead and call add3() with their inputs. Pre-existing code still “works”. In some future major release, plus3() could be removed entirely.\nlifecycle::deprecate_warn() and friends have a few features that are worth highlighting:\n\nThe warning message is built up from inputs like when, what, with, and details, which gives deprecation warnings a predictable form across different functions, packages, and time. The intent is to reduce the cognitive load for users who may already be somewhat stressed.\nBy default, a specific warning is only issued once every 8 hours, in an effort to cause just the right amount of aggravation. The goal is to be just annoying enough to motivate the user to update their code before the function or argument goes away, but not so annoying that they fling their computer into the sea. Near the end of the deprecation process, the always argument can be set to TRUE to warn on every call.\nIf you use lifecycle::deprecate_soft() (instead of deprecate_warn()), a warning is only issued if the person reading it is the one who can actually do something about it, i.e. update the offending code. If a user calls a deprecated function indirectly, i.e. because they are using a package that’s using a deprecated function, by default that user doesn’t get a warning. (But the maintainer of the guilty package will see these warnings in their test results.)\n\nHere’s a hypothetical schedule for removing a function fun():\n\nPackage version 1.5.0: fun() exists. The lifecycle stage of the package is stable, as indicated by its post-1.0.0 version number and, perhaps, a package-level badge. The lifecycle stage of fun() is also stable, by extension, since it hasn’t been specifically marked as experimental.\n\nPackage version 1.6.0: The deprecation process of fun() begins. We insert a badge in its help topic:\n\n#' @description\n#' `r lifecycle::badge(\"deprecated\")`\n\nIn the body of fun(), we add a call to lifecycle::deprecate_warn() to inform users about the situation. Otherwise, fun() still works as it always has.\n\nPackage version 1.7.0 or 2.0.0: fun() is removed. Whether this happens in a minor or major release will depend on the context, i.e. how widely used this package and function are.\n\nIf you’re using base R only, the .Deprecated() and .Defunct() functions are the closest substitutes for lifecycle::deprecate_warn() and friends.\n\n21.7.3 Deprecating an argument\nlifecycle::deprecate_warn() is also useful when deprecating an argument. In this case, it’s also handy to use lifecycle::deprecated() as the default value for the deprecated argument. Here we continue an example from above, i.e. the switch from path to file in readr::write_file():\n\nwrite_file <- function(x,\n                       file,\n                       append = FALSE,\n                       path = deprecated()) {\n  if (is_present(path)) {\n    lifecycle::deprecate_warn(\"1.4.0\", \"write_file(path)\", \"write_file(file)\")\n    file <- path\n  }\n  ...\n}\n\nHere’s what a user sees if they use the deprecated argument:\n\nreadr::write_file(\"hi\", path = tempfile(\"lifecycle-demo-\"))\n#> Warning: The `path` argument of `write_file()` is deprecated as of readr\n#> 1.4.0.\n#> ℹ Please use the `file` argument instead.\n\nThe use of deprecated() as the default accomplishes two things. First, if the user reads the documentation, this is a strong signal that an argument is deprecated. But deprecated() also has benefits for the package maintainer. Inside the affected function, you can use lifecycle::is_present() to determine if the user has specified the deprecated argument and proceed accordingly, as shown above.\nIf you’re using base R only, the missing() function has substantial overlap with lifecycle::is_present(), although it can be trickier to finesse issues around default values.\n\n21.7.4 Deprecation helpers\nSometimes a deprecation affects code in multiple places and it’s clunky to inline the full logic everywhere. In this case, you might create an internal helper to centralize the deprecation logic.\nThis happened in googledrive, when we changed how to control the package’s verbosity. The original design let the user specify this in every single function, via the verbose = TRUE/FALSE argument. Later, we decided it made more sense to use a global option to control verbosity at the package level. This is a case of (eventually) removing an argument, but it affects practically every single function in the package. Here’s what a typical function looks like after starting the deprecation process:\n\ndrive_publish <- function(file, ..., verbose = deprecated()) {\n  warn_for_verbose(verbose)\n  # rest of the function ...\n}\n\nNote the use of verbose = deprecated(). Here’s a slightly simplified version of warn_for_verbose():\n\nwarn_for_verbose <- function(verbose = TRUE,\n                             env = rlang::caller_env(),\n                             user_env = rlang::caller_env(2)) {\n  # This function is not meant to be called directly, so don't worry about its\n  # default of `verbose = TRUE`.\n  # In authentic, indirect usage of this helper, this picks up on whether\n  # `verbose` was present in the **user's** call to the calling function.\n  if (!lifecycle::is_present(verbose) || isTRUE(verbose)) {\n    return(invisible())\n  }\n\n  lifecycle::deprecate_warn(\n    when = \"2.0.0\",\n    what = I(\"The `verbose` argument\"),\n    details = c(\n      \"Set `options(googledrive_quiet = TRUE)` to suppress all googledrive messages.\",\n      \"For finer control, use `local_drive_quiet()` or `with_drive_quiet()`.\",\n      \"googledrive's `verbose` argument will be removed in the future.\"\n    ),\n    user_env = user_env\n  )\n  # only set the option during authentic, indirect usage\n  if (!identical(env, global_env())) {\n    local_drive_quiet(env = env)\n  }\n  invisible()\n}\n\nThe user calls a function, such as drive_publish(), which then calls warn_for_verbose(). If the user leaves verbose unspecified or if they request verbose = TRUE (default behavior), warn_for_verbose() does nothing. But if they explicitly ask for verbose = FALSE, we throw a warning with advice on the preferred way to suppress googledrive’s messaging. We also go ahead and honor their wishes for the time being, via the call to googledrive::local_drive_quiet(). In the next major release, the verbose argument can be removed everywhere and this helper can be deleted.\n\n21.7.5 Dealing with change in a dependency\nWhat if you want to use functionality in a new version of another package? Or the less happy version: what if changes in another package are going to break your package? There are a few possible scenarios, depending on whether the other package has been released and the experience you want for your users. We’ll start with the simple, happier case of using features newly available in a dependency.\nIf the other package has already been released, you could bump the minimum version you declare for it in DESCRIPTION and use the new functionality unconditionally. This also means that users who update your package will be forced to update the other package, which you should at least contemplate. Note, also, that this only works for a dependency in Imports. While it’s a good idea to record a minimum version for a suggested package, it’s not generally enforced the same as for Imports.\nIf you don’t want to require your users to update this other package, you could make your package work with both new and old versions. This means you’ll check its version at run-time and proceed accordingly. Here is a sketch of how that might look in the context of an existing or new function:\n\nyour_existing_function <- function(..., cool_new_feature = FALSE) {\n  if (isTRUE(cool_new_feature) && packageVersion(\"otherpkg\") < \"1.0.0\") {\n    message(\"otherpkg >= 1.0.0 is needed for cool_new_feature\")\n    cool_new_feature <- FALSE\n  }\n  # the rest of the function\n}\n\nyour_new_function <- function(...) {\n  if (packageVersion(\"otherpkg\") < \"1.0.0\") {\n    stop(\"otherpkg >= 1.0.0 needed for this function.\")\n  }\n  # the rest of the function\n}\n\nAlternatively, this would also be a great place to use rlang::is_installed() and rlang::check_installed() with the version argument (see examples of usage in Section 11.5.1).\nThis approach can also be adapted if you’re responding to not-yet-released changes that are coming soon in one of your dependencies. It’s helpful to have a version of your package that works both before and after the change. This allows you to release your package at any time, even before the other package. Sometimes you can refactor your code to make it work with either version of the other package, in which case you don’t need to condition on the other package’s version at all. But sometimes you might really need different code for the two versions. Consider this example:\n\nyour_function <- function(...) {\n  if (packageVersion(\"otherpkg\") >= \"1.3.9000\") {\n    otherpkg::their_new_function()\n  } else {\n    otherpkg::their_old_function()\n  }\n  # the rest of the function\n}\n\nThe hypothetical minimum version of 1.3.9000 suggests a case where the development version of otherpkg already has the change you’re responding to, which is a new function in this case. Assuming their_new_function() doesn’t exist in the latest release of otherpkg, you’ll get a note from R CMD check stating that their_new_function() doesn’t exist in otherpkg’s namespace. If you’re submitting such a version to CRAN, you can explain that you’re doing this for the sake of backward and forward compatibility with otherpkg and they are likely to be satisfied.\n\n21.7.6 Superseding a function\nThe last lifecycle stage that we’ll talk about is superseded. This is appropriate when you feel like a function is no longer the preferred solution to a problem, but it has enough usage and history that you don’t want to initiate the process of removing it. Good examples of this are tidyr::spread() and tidyr::gather(). Those functions have been superseded by tidyr::pivot_wider() and tidyr::pivot_longer(). But some users still prefer the older functions and it’s likely that they’ve been used a lot in projects that are not under active development. Thus spread() and gather() are marked as superseded, they don’t receive any new innovations, but they aren’t at risk of removal.\nA related phenomenon is when you want to change some aspect of a package, but you also want to give existing users a way to opt-in to the legacy behaviour. The idea is to provide users a band-aid they can apply to get old code working quickly, until they have the bandwidth to do a more thorough update (which might not ever happen, in some cases). Here are some examples where legacy behaviour was preserved for users who opt-in:\n\nIn tidyr 1.0.0, the interface of tidyr::nest() and tidyr::unnest() changed. Most authentic usage can be translated to the new syntax, which tidyr does automatically, along with conveying the preferred modern syntax via a warning. But the old interface remains available via tidyr::nest_legacy() and tidyr::unnest_legacy(), which were marked superseded upon creation.\ndplyr 1.1.0 takes advantage of a much faster algorithm for computing groups. But this speedier method also sorts the groups with respect to the C locale, whereas previously the system locale was used. The global option dplyr.legacy_locale allows a user to explicitly request the legacy behaviour.5\nThe tidyverse packages have been standardizing on a common approach to name repair, which is implemented in vctrs::vec_as_names(). The vctrs package also offers vctrs::vec_as_names_legacy(), which makes it easier to get names repaired with older strategies previously used in packages like tibble, tidyr, and readxl.\nreadr 2.0.0 introduced a so-called second edition, marking the switch to a backend provided by the vroom package. Functions like readr::with_edition(1, ...) and readr::local_edition(1) make it easier for a user to request first edition behaviour for a specific bit of code or for a specific script."
  },
  {
    "objectID": "release.html#decide-the-release-type",
    "href": "release.html#decide-the-release-type",
    "title": "22  Releasing to CRAN",
    "section": "\n22.1 Decide the release type",
    "text": "22.1 Decide the release type\nWhen you call use_release_issue(), you’ll be asked which type of release you intend to make.\n\n> use_release_issue()\n✔ Setting active project to '/Users/jenny/rrr/usethis'\nCurrent version is 2.1.6.9000.\nWhat should the release version be? (0 to exit) \n\n1: major --> 3.0.0\n2: minor --> 2.2.0\n3: patch --> 2.1.7\n\nSelection: \n\nThe immediate question feels quite mechanical: which component of the version number do you want to increment? But remember that we discussed the substantive differences in release types in Section 21.5.\nIn our workflow, this planned version number is recorded in the GitHub issue that holds the release checklist, but we don’t actually increment the version in DESCRIPTION until later in the process (Section 22.7). However, it’s important to declare the release type up front, because the process (and, therefore, the checklist) looks different for, e.g., a patch release versus a major release."
  },
  {
    "objectID": "release.html#sec-release-initial",
    "href": "release.html#sec-release-initial",
    "title": "22  Releasing to CRAN",
    "section": "\n22.2 Initial CRAN release: Special considerations",
    "text": "22.2 Initial CRAN release: Special considerations\nEvery new package receives a higher level of scrutiny from CRAN. In addition to the usual automated checks, new packages are also reviewed by a human, which inevitably introduces a certain amount of subjectivity and randomness. There are many packages on CRAN that would not be accepted in their current form, if submitted today as a completely new package. This isn’t meant to discourage you. But you should be aware that, just because you see some practice in an established package (or even in base R), that doesn’t mean you can do the same in your new package.\nLuckily, the community maintains lists of common “gotchas” for new packages. If your package is not yet on CRAN, the checklist begins with a special section that reflects this recent collective wisdom. Attending to these checklist items has dramatically improved our team’s success rate for initial submissions.\nFirst release\n\n\nusethis::use_news_md()\n\n\nusethis::use_cran_comments()\n\n\nUpdate (aspirational) install instructions in README\n\n\nProofread Title: and Description:\n\n\nCheck that all exported functions have @returns and @examples\n\n\nCheck that Authors@R: includes a copyright holder (role ‘cph’)\n\nCheck licensing of included files\n\nReview https://github.com/DavisVaughan/extrachecks\n\n\nIf you don’t already have a NEWS.md file, you are encouraged to create one now with usethis::use_news_md(). You’ll want this file eventually and this anticipates the fact that the description of your eventual GitHub release (Section 22.9) is drawn from NEWS.md.\nusethis::use_cran_comments() initiates a file to hold submission comments for your package. It’s very barebones at first, e.g.:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* This is a new release.\nIn subsequent releases, this file becomes less pointless; for example, it is where we report the results of reverse dependency checks. This is not a place to wax on with long explanations about your submission. In general, you should eliminate the need for such explanations, especially for an initial submission.\nWe highly recommend that your package have a README file (Section 18.1). If it does, this is a good time to check the installation instructions provided there. You may need to switch from instructions to install it from GitHub, in favor of installing from CRAN, in anticipation of your package’s acceptance.\nThe Title and Description fields of DESCRIPTION are real hotspots for nitpicking during CRAN’s human review. Carefully review the advice given in Section 9.2. Also check that Authors@R includes a copyright holder, indicated by the ‘cph’ role. The two most common scenarios are that you add ‘cph’ to your other roles (probably ‘cre’ and ‘aut’) or that you add your employer to Authors@R: with the ‘cph’ and, perhaps, ‘fnd’ role. (When you credit a funder via the ‘fnd’ role, they are acknowledged in the footer of your pkgdown website.) This is also a good time to ensure that the maintainer’s e-mail address is appropriate. This is the only way that CRAN can correspond with you. If there are problems and they can’t get in touch with you, they will remove your package from CRAN. Make sure this email address is likely to be around for a while and that it’s not heavily filtered.\nDouble check that each of your exported functions documents its return value (with the @returns tag, Section 16.4) and has an @examples section (Section 16.5). If you have examples that cannot be run on CRAN, you absolutely must use the techniques in Section 16.5.4 to express the relevant pre-conditions properly. Do not take shortcuts, such as having no examples, commenting out your examples, or putting all of your examples inside \\dontrun{}.\nIf you have embedded third party code in your package, check that you are correctly abiding by and declaring its license (Section 12.4).\nFinally, take advantage of any list of ad hoc checks that other package developers have recently experienced with CRAN. At the time of writing, https://github.com/DavisVaughan/extrachecks is a good place to find such first-hand reports. Reading such a list and preemptively modifying your package can often make the difference between a smooth acceptance and a frustrating process requiring multiple attempts.\n\n22.2.1 CRAN policies\nWe alert you to specific CRAN policies throughout this book and, especially, through this chapter. However, this is something of a moving target, so it pays off to make some effort to keep yourself informed about future changes to CRAN policy.\nThe official home of CRAN policy is https://cran.r-project.org/web/packages/policies.html. However, it’s not very practical to read this document, e.g., once a week and simply hope that you’ll notice any changes. The GitHub repository eddelbuettel/crp monitors the CRAN Repository Policy by tracking the evolution of the underlying files in the source of the CRAN website. Therefore the commit history of that repository makes policy changes much easier to navigate. You may also want to follow the CRAN Policy Watch Mastodon account, which toots whenever a change is detected.2\nThe R-package-devel mailing list is another good resource for learning more about package development. You could subscribe to it to keep tabs on what other maintainers are talking about. Even if you don’t subscribe, it can be useful to search this list, when you’re researching a specific topic."
  },
  {
    "objectID": "release.html#keeping-up-with-change",
    "href": "release.html#keeping-up-with-change",
    "title": "22  Releasing to CRAN",
    "section": "\n22.3 Keeping up with change",
    "text": "22.3 Keeping up with change\nNow we move into the main checklist items for a minor or major release of a package that is already on CRAN. Many of these items also appear in the checklist for a patch or initial release.\n\n\nCheck current CRAN check results\n\nCheck if any deprecation processes should be advanced, as described in Gradual deprecation\n\n\nPolish NEWS\n\n\nurlchecker::url_check()\n\n\ndevtools::build_readme()\n\n\nThese first few items confirm that your package is keeping up with its surroundings and with itself. The first item, “Check current CRAN check results”, will be a hyperlink to the CRAN check results for the version of the package that is currently on CRAN. If there are any WARNINGs or ERRORs or NOTEs there, you should investigate and determine what’s going on. Occasionally there can be an intermittent hiccup at CRAN, but generally speaking, any result other than “OK” is something you should address with the release you are preparing. You may discover your package is in a dysfunctional state due to changes in base R, CRAN policies, CRAN tooling, or packages you depend on.\nIf you are in the process of deprecating a function or an argument, a minor or major release is a good time to consider moving that process along as described in Section 21.7. This is also a good time to look at all the NEWS bullets that have accumulated since the last release (“Polish NEWS”). Even if you’ve been diligent about jotting down all the news-worthy changes, chances are these bullets will benefit from some re-organization and editing for consistency and clarity (Section 18.2).\nAnother very important check is to run urlchecker::url_check(). CRAN’s URL checks are described at https://cran.r-project.org/web/packages/URL_checks.html and are implemented by code that ships with R itself. However, these checks are not exposed in a very usable way. The urlchecker package was created to address this and exposes CRAN’s URL-checking logic in the url_check() function. The main problems that surface tend to be URLs that don’t work anymore or URLs that use redirection. Obviously, you should update or remove any URL that no longer exists. Redirection, however, is trickier. If the status code is “301 Moved Permanently”, CRAN’s view is that your package should use the redirected URL. The problem is that many folks don’t follow RFC7231 to the letter and use this sort of redirect even when they have a different intent, i.e. their intent is to provide a stable, user-friendly URL that then redirects to something less user-friendly or more volatile. If a legitimate URL you want to use runs afoul of CRAN’s checks, you’ll have to choose between a couple of less-than-appealing options. You could try to explain the situation to CRAN, but this requires human review, and thus is not recommended. Or you can convert such URLs into non-hyperlinked, verbatim text. Note also that even though urlchecker is using the same code as CRAN, your local results may still differ from CRAN’s, due to differences in other ambient conditions, such as environment variables and system capabilities.\nIf you have a README.Rmd file, you will also want to re-build the static README.md file with the current version of your package. The best function to use for this is devtools::build_readme(), because it is guaranteed to render README.Rmd against the current source code of your package."
  },
  {
    "objectID": "release.html#double-r-cmd-checking",
    "href": "release.html#double-r-cmd-checking",
    "title": "22  Releasing to CRAN",
    "section": "\n22.4 Double R CMD checking",
    "text": "22.4 Double R CMD checking\nNext come a couple of items related to R CMD check. Remember that this should not be the first time you’ve run R CMD check since the previous release! Hopefully, you are running R CMD check often during local development and are using a continuous integration service, like GitHub Actions. This is meant to be a last-minute, final reminder to double-check that all is still well:\n\ndevtools::check(remote = TRUE, manual = TRUE). This happens on your primary development machine, presumably with the current version of R, and with some extra checks that are usually turned off to make day-to-day development faster.\ndevtools::check_win_devel(). This sends your package off to be checked with CRAN’s win-builder service, against the latest development version of R (a.k.a. r-devel). You should receive an e-mail within about 30 minutes with a link to the check results. It’s a good idea to check your package with r-devel, because base R and R CMD check are constantly evolving. Checking with r-devel is required by CRAN policy and it will be done as part of CRAN’s incoming checks. There is no point in skipping this step and hoping for the best.\n\nNote that the brevity of this list implicitly reflects that tidyverse packages are checked after every push via GitHub Actions, across multiple operating systems and versions of R (including the development version), and that most of the tidyverse team develops primarily on macOS. CRAN expects you to “make all reasonable efforts” to get your package working across all of the major R platforms and packages that don’t work on at least two will typically not be accepted.\nThe next subsection (Section 22.4.1) is optional reading with more details on the all the platforms that CRAN cares about and how you can access them. If your ongoing checks are more limited than ours, you may want to make up for that with more extensive pre-submission checks. You may also need this knowledge to troubleshoot a concrete problem that surfaces in CRAN’s checks, either for an incoming submission or for a package that’s already on CRAN.\nWhen running R CMD check for a CRAN submission, you have to address any problems that show up:\n\nYou must fix all ERRORs and WARNINGs. A package that contains any errors or warnings will not be accepted by CRAN.\nEliminate as many NOTEs as possible. Each NOTE requires human oversight, which creates friction for both you and CRAN. If there are notes that you do not believe are important, it is almost always easier to fix them (even if the fix is a bit of a hack) than to persuade CRAN that they’re OK. See our online-only guide to R CMD check for details on how to fix individual problems.\n\nIf you can’t eliminate a NOTE, list it in cran-comments.md and explain why you think it is spurious. We discuss this file further in Section 22.6.\nNote that there will always be one NOTE when you first submit your package. This reminds CRAN that this is a new submission and that they’ll need to do some extra checks. You can’t eliminate this NOTE, so just mention in cran-comments.md that this is your first submission.\n\n\n\n22.4.1 CRAN check flavors and related services\nCRAN runs R CMD check on all contributed packages upon submission and on a regular basis, on multiple platforms or what they call “flavors”. You can see CRAN’s current check flavors here: https://cran.r-project.org/web/checks/check_flavors.html. There are various combinations of:\n\nOperating system and CPU: Windows, macOS (x86_64, arm64), Linux (various distributions)\nR version: r-devel, r-release, r-oldrel\nC, C++, FORTRAN compilers\nLocale, in the sense of the LC_CTYPE environment variable (this is about which human language is in use and character encoding)\n\nCRAN’s check flavors almost certainly include platforms other than your preferred development environment(s), so you will eventually need to make an explicit effort to check and, perhaps, troubleshoot your package on these other flavors.\nIt would be impractical for individual package developers to personally maintain all of these testing platforms. Instead, we turn to various community- and CRAN-maintained resources for this. Here is a selection, in order of how central they are to our current practices:\n\nGitHub Actions (GHA) is our primary means of testing packages on multiple flavors, as covered in Section 20.2.1.\n\nR-hub builder (R-hub). This is a service supported by the R Consortium where package developers can submit their package for checks that replicate various CRAN check flavors.\nYou can use R-hub via a web interface (https://builder.r-hub.io) or, as we recommend, through the rhub R package.\nrhub::check_for_cran() is a good option for a typical CRAN package and is morally similar to the GHA workflow configured by usethis::use_github_action(\"check-standard\"). However, unlike GHA, R-hub currently does not cover macOS, only Windows and Linux.\nrhub also helps you access some of the more exotic check flavors and offers specialized checks relevant to packages with compiled code, such as rhub::check_with_sanitizers().\n\n\nmacOS builder is a service maintained by the CRAN personnel who build the macOS binaries for CRAN packages. This is a relatively new addition to the list and checks packages with “the same setup and available packages as the CRAN M1 build machine”.\nYou can submit your package using the web interface (https://mac.r-project.org/macbuilder/submit.html) or with devtools::check_mac_release()."
  },
  {
    "objectID": "release.html#sec-release-revdep-checks",
    "href": "release.html#sec-release-revdep-checks",
    "title": "22  Releasing to CRAN",
    "section": "\n22.5 Reverse dependency checks",
    "text": "22.5 Reverse dependency checks\n\n\nrevdepcheck::revdep_check(num_workers = 4)\n\n\nThis innocuous checklist item can actually represent a considerable amount of effort. At a high-level, checking your reverse dependencies (“revdeps”) breaks down into:\n\nForm a list of your reverse dependencies. These are CRAN packages that list your package in their Depends, Imports, Suggests or LinkingTo fields.\nRun R CMD check on each one.\nMake sure you haven’t broken someone else’s package with the planned changes in your package.\n\nEach of these steps can require considerable work and judgment. So, if you have no reverse dependencies, you should rejoice that you can skip this step. If you only have a couple of reverse dependencies, you can probably do this “by hand”, i.e. download each package’s source and run R CMD check.\nHere we explain ways to do reverse dependency checks at scale, which is the problem we face. Some of the packages maintained by our team have thousands of reverse dependencies and even some of the lower-level packages have hundreds. We have to approach this in an automated fashion and this section will be most useful to other maintainers in the same boat.\nAll of our reverse dependency tooling is concentrated in the revdepcheck package (https://revdepcheck.r-lib.org/). Note that, at least at the time of writing, the revdepcheck package is not on CRAN. You can install it from Github via devtools::install_github(\"r-lib/revdepcheck\") or pak::pak(\"r-lib/revdepcheck\").\nDo this when you’re ready to do revdep checks for the first time:\n\nusethis::use_revdep()\n\nThis does some one-time setup in your package’s .gitignore and .Rbuildignore files. Revdep checking will create some rather large folders below revdep/, so you definitely want to configure these ignore files. You will also see this reminder to actually perform revdep checks like so, as the checklist item suggests:\n\nrevdepcheck::revdep_check(num_workers = 4)\n\nThis runs ⁠R CMD check⁠ on all of your reverse dependencies, with our recommendation to use 4 parallel workers to speed things along. The output looks something like this:\n> revdepcheck::revdep_check(num_workers = 4)\n── INIT ───────────────────────────────────── Computing revdeps ──\n── INSTALL ───────────────────────────────────────── 2 versions ──\nInstalling CRAN version of cellranger\nalso installing the dependencies 'cli', 'glue', 'utf8', 'fansi', 'lifecycle', 'magrittr', 'pillar', 'pkgconfig', 'rlang', 'vctrs', 'rematch', 'tibble'\n\nInstalling DEV version of cellranger\nInstalling 13 packages: rlang, lifecycle, glue, cli, vctrs, utf8, fansi, pkgconfig, pillar, magrittr, tibble, rematch2, rematch\n── CHECK ─────────────────────────────────────────── 8 packages ──\n✔ AOV1R 0.1.0                     ── E: 0     | W: 0     | N: 0\n✔ mschart 0.4.0                   ── E: 0     | W: 0     | N: 0\n✔ googlesheets4 1.0.1             ── E: 0     | W: 0     | N: 1\n✔ readODS 1.8.0                   ── E: 0     | W: 0     | N: 0\n✔ readxl 1.4.2                    ── E: 0     | W: 0     | N: 0\n✔ readxlsb 0.1.6                  ── E: 0     | W: 0     | N: 0\n✔ unpivotr 0.6.3                  ── E: 0     | W: 0     | N: 0\n✔ tidyxl 1.0.8                    ── E: 0     | W: 0     | N: 0                  \nOK: 8                                                                                 \nBROKEN: 0\nTotal time: 6 min\n── REPORT ────────────────────────────────────────────────────────\nWriting summary to 'revdep/README.md'\nWriting problems to 'revdep/problems.md'\nWriting failures to 'revdep/failures.md'\nWriting CRAN report to 'revdep/cran.md'\nTo minimize false positives, revdep_check() runs ⁠R CMD check⁠ twice per revdep: once with the released version of your package currently on CRAN and again with the local development version, i.e. with your release candidate. Why two checks? Because sometimes the revdep is already failing R CMD check and it would be incorrect to blame your planned release for the breakage. revdep_check() reports the packages that can’t be checked and, most importantly, those where there are so-called “changes to the worse”, i.e. where your release candidate is associated with new problems. Note also that revdep_check() always works with a temporary, self-contained package library, i.e. it won’t modify your default user or system library.\n\n\n\n\n\n\ntidyverse team\n\n\n\nWe actually use a different function for our reverse dependency checks: revdepcheck::cloud_check(). This runs the checks in the cloud, massively in parallel, making it possible to run revdep checks for packages like testthat (with >10,000 revdeps) in just a few hours!\ncloud_check() has been a gamechanger for us, allowing us to run revdep checks more often. For example, we even do this now when assessing the impact of a potential change to a package (Section 21.4), instead of only right before a release.\nAt the time of writing, cloud_check() is only available for package maintainers at Posit, but we hope to offer this service for the broader R community in the future.\n\n\nIn addition to some interactive messages, the revdep check results are written to the revdep/ folder:\n\n\nrevdep/README.md: This is a high-level summary aimed at maintainers. The filename and Markdown format are very intentional, in order to create a nice landing page for the revdep/ folder on GitHub.\n\nrevdep/problems.md: This lists the revdeps that appear to be broken by your release candidate.\n\nrevdep/failures.md: This lists the revdeps that could not be checked, usually because of an installation failure, either of the revdep itself or one of its dependencies.\n\nrevdep/cran.md: This is a high-level summary aimed at CRAN. You should copy and paste this into cran-comments.md (Section 22.6).\nOther files and folders, such as checks.noindex, data.sqlite, and library.noindex. These are for revdepcheck’s internal use and we won’t discuss them further.\n\nThe easiest way to get a feel for these different files is to look around at the latest revdep results for some tidyverse packages, such as dplyr or tidyr.\nThe revdep check results – local, cloud, or CRAN – are not perfect, because this is not a simple task. There are various reasons why a result might be missing, incorrect, or contradictory in different runs.\n\nFalse positives: sometimes revdepcheck reports a package has been broken, but things are actually fine (or, at least, no worse than before). This most commonly happens because of flaky tests that fail randomly (Section 15.4.1), such as HTTP requests. This can also happen because the instance runs out of disk space or other resources, so the first check using the CRAN version succeeds and the second check using the dev version fails. Sometimes it’s obvious that the problem is not related to your package.\nFalse negatives: sometimes a package has been broken, but you don’t detect that. For us, this usually happens when cloud_check() can’t check a revdep because it can’t be installed, typically because of a missing system requirement (e.g. Java). These are separately reported as “failed to test” but are still included in problems.md, because this could still be direct breakage caused by your package. For example, if you remove an exported function that’s used by another package, installation will fail.\n\nGenerally these differences are less of a worry now that CRAN’s own revdep checks are well automated, so new failures typically don’t involve a human.\n\n22.5.1 Revdeps and breaking changes\nIf the revdep check reveals breakages, you need to examine each failure and determine if it’s:\n\nA false positive.\nA non-breaking change, i.e. a failure caused by off-label usage of your package.\nA bug in your package that you need to fix.\nA deliberate breaking change.\n\nIf your update will break another package (regardless of why), you need to inform the maintainer, so they hear it first from you, rather than CRAN. The nicest way to do this is with a patch that updates their package to play nicely with yours, perhaps in the form of a pull request. This can be a decent amount of work and is certainly not feasible for all maintainers. But working through a few of these can be a good way to confront the pain that breaking change causes and to reconsider whether the benefits outweigh the costs. In most cases, a change that affects revdeps is likely to also break less visible code that lives outside of CRAN packages, such as scripts, reports, and Shiny apps.\nIf you decide to proceed, functions such as revdepcheck::revdep_maintainers() and revdepcheck::revdep_email() can help you notify revdep maintainers en masse. Make sure the email includes a link to documentation that describes the most common breaking changes and how to fix them. You should let the maintainers know when you plan to submit to CRAN (we recommend giving at least two weeks notice), so they can submit their updated version before that. When your release date rolls around, re-run your checks to see how many problems have been resolved. Explain any remaining failures in cran-comments.md as demonstrated in Section 22.6. The two most common cases are that you are unable to check a package because you aren’t able to install it locally or a legitimate change in the API which the maintainer hasn’t addressed yet. As long as you have given sufficient advanced notice, CRAN will accept your update, even if it breaks some other packages.\n\n\n\n\n\n\ntidyverse team\n\n\n\nLately the tidyverse team is trying to meet revdep maintainers more than halfway in terms of dealing with breaking changes. For example, in GitHub issue tidyverse/dplyr#6262, the dplyr maintainers tracked hundreds of pull requests in the build-up to the release of dplyr v1.1.0. As the PRs are created, it’s helpful to add links to those as well. As the revdep maintainers merge the PRs, they can be checked off as resolved. If some PRs are still in-flight when the announced submission date rolls around, the situation can be summarized in cran-comments.md, as was true in the case of dplyr v1.1.0."
  },
  {
    "objectID": "release.html#sec-release-cran-comments",
    "href": "release.html#sec-release-cran-comments",
    "title": "22  Releasing to CRAN",
    "section": "\n22.6 Update comments for CRAN",
    "text": "22.6 Update comments for CRAN\n\n\nUpdate cran-comments.md\n\n\nWe use the cran-comments.md file to record comments about a submission, mainly just the results from R CMD check and revdep checks. If you are making a specific change at CRAN’s request, possibly under a deadline, that would also make sense to mention. We like to track this file in Git, so we can see how it changes over time. It should also be listed in .Rbuildignore, since it should not appear in your package bundle. When you’re ready to submit, devtools::submit_cran() (Section 22.7) incorporates the contents of cran-comments.md when it uploads your submission.\nThe target audience for these comments is the CRAN personnel, although there is no guarantee that they will read the comments (or when in the submission process they read them). For example, if your package breaks other packages, you will likely receive an automated email about that, even if you’ve explained that in the comments. Sometimes a human at CRAN then reads the comments, is satisfied, and accepts your package anyway, without further action from you. At other times, your package may be stuck in the queue until you copy cran-comments.md and paste it into an email exchange to move things along. In either case, it’s worth keeping these comments in their own, version-controlled file.\nHere is a fairly typical cran-comments.md from a recent release of forcats. Note that the R CMD check results are clean, i.e. there is nothing that needs to be explained or justified, and there is a concise summary of the revdep process.\n## R CMD check results\n\n0 errors | 0 warnings | 0 notes\n\n## revdepcheck results\n\nWe checked 231 reverse dependencies (228 from CRAN + 3 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.\n\nWe saw 2 new problems:\n\n* epikit\n* stevemisc\n\nBoth maintainers were notified on Jan 12 (~2 week ago) and supplied with patches.\n\nWe failed to check 3 packages\n\n* genekitr     (NA)\n* OlinkAnalyze (NA)\n* SCpubr       (NA)\nThis layout is designed to be easy to skim, and easy to match up to the R CMD check results seen by CRAN maintainers. It includes two sections:\n\n\nCheck results: We always state that there were no errors or warnings (and we make sure that’s true!). Ideally we can also say there were no notes. But if not, any NOTEs are presented in a bulleted list. For each NOTE, we include the message from R CMD check and a brief description of why we think it’s OK.\nHere is how a NOTE is explained for the nycflights13 data package:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* Checking installed package size:\n  installed size is  6.9Mb\n  sub-directories of 1Mb or more:\n    data   6.9Mb\n\n  This is a data package that will be rarely updated.\n\nReverse dependencies: If there are revdeps, this is where we paste the contents of revdep/cran.md (Section 22.5). If there are no revdeps, we recommend that you keep this section, but say something like: “There are currently no downstream dependencies for this package”."
  },
  {
    "objectID": "release.html#sec-release-process",
    "href": "release.html#sec-release-process",
    "title": "22  Releasing to CRAN",
    "section": "\n22.7 The submission process",
    "text": "22.7 The submission process\n\n\nusethis::use_version('minor') (or ‘patch’ or ‘major’)\n\ndevtools::submit_cran()\n\n\nApprove email\n\nWhen you’re truly ready to submit, it’s time to actually bump the version number in DESCRIPTION. This checklist item will reflect the type of release declared at the start of this process (patch, minor, or major), in the initial call to use_release_issue().\nWe recommend that you submit your package to CRAN by calling devtools::submit_cran(). This convenience function wraps up a few steps:\n\nCreates the package bundle (Section 3.3) with pkgbuild::build(manual = TRUE), which ultimately calls R CMD build.\nPosts the resulting *.tar.gz file to CRAN’s official submission form (https://cran.r-project.org/submit.html), populating your name and email from DESCRIPTION and your submission comments from cran-comments.md.\nConfirms that the submission was successful and reminds you to check your email for the confirmation link.\nWrites submission details to a local CRAN-SUBMISSION file, which records the package version, SHA, and time of submission. This information is used later by usethis::use_github_release() to create a GitHub release once your package has been accepted. CRAN-SUBMISSION will be added to .Rbuildignore. We generally do not gitignore this file, but neither do we commit it. It’s an ephemeral note that exists during the interval between submission and (hopefully) acceptance.\n\nAfter a successful upload, you should receive an email from CRAN within a few minutes. This email notifies you, as maintainer, of the submission and provides a confirmation link. Part of what this does is confirm that the maintainer’s email address is correct. At the confirmation link, you are required to re-confirm that you’ve followed CRAN’s policies and that you want to submit the package. If you fail to complete this step, your package is not actually submitted to CRAN!\nOnce your package enters CRAN’s system it is automatically checked on Windows and Linux, probably against both the released and development versions of R. You will get another email with links to these check results, usually within a matter of hours. An initial submission (Section 22.2) will receive additional scrutiny from CRAN personnel. The process is potentially fully automated when updating a package that is already on CRAN. If a package update passes its initial checks, CRAN will then run reverse dependency checks."
  },
  {
    "objectID": "release.html#failure-modes",
    "href": "release.html#failure-modes",
    "title": "22  Releasing to CRAN",
    "section": "\n22.8 Failure modes",
    "text": "22.8 Failure modes\nThere are at least three ways for your CRAN submission to fail:\n\nIt does not pass R CMD check. This is an automated result.\nHuman review finds the package to be in violation of CRAN policies. This applies mostly to initial submissions, but sometimes CRAN personnel decides to engage in ad hoc review of updates to existing packages that fail any automated checks.\nReverse dependency checks suggest there are “changes to the worse”. This is an automated result.\n\nFailures are frustrating and the feedback may be curt and may feel downright insulting. Take comfort in the fact that this a widely shared experience across the R community. It happens to us on a regular basis. Don’t rush to respond, especially if you are feeling defensive.\nWait until you are able to focus your attention on the technical issues that have been raised. Read any check results or emails carefully and investigate the findings. Unless you feel extremely strongly that discussion is merited, don’t respond to the e-mail. Instead:\n\nFix the identified problems and make recommended changes. Re-run devtools::check() on any relevant platforms to make sure you didn’t accidentally introduce any new problems.\nIncrease the patch version of your package. Yes, this means that there might be gaps in your released version numbers. This is not a big deal.\n\nAdd a “Resubmission” section at the top of cran-comments.md. This should clearly identify that the package is a resubmission, and list the changes that you made.\n## Resubmission\nThis is a resubmission. In this version I have:\n\n* Converted the DESCRIPTION title to title case.\n\n* More clearly identified the copyright holders in the DESCRIPTION\n  and LICENSE files.\n\nIf necessary, update the check results and revdep sections.\nRun devtools::submit_cran() to re-submit the package.\n\nIf your analysis indicates that the initial failure was a false positive, reply to CRAN’s email with a concise explanation. For us, this scenario mostly comes up with respect to revdep checks. It’s extremely rare for us to see failure for CRAN’s initial R CMD check runs and, when it happens, it’s often legitimate. On the other hand, for packages with a large number of revdeps, it’s inevitable that a subset of these packages have some flaky tests or brittle examples. Therefore it’s quite common to see revdep failures that have nothing to do with the proposed package update. In this case, it is appropriate to send a reply email to CRAN explaining why you think these are false positives."
  },
  {
    "objectID": "release.html#sec-release-post-acceptance",
    "href": "release.html#sec-release-post-acceptance",
    "title": "22  Releasing to CRAN",
    "section": "\n22.9 Celebrating success",
    "text": "22.9 Celebrating success\nNow we move into the happiest section of the check list.\n\n\nAccepted 🎉\n\ngit push\n\n\nusethis::use_github_release()\n\n\nusethis::use_dev_version()\n\n\ngit push\n\n\nFinish blog post, share on social media, etc.\n\nAdd link to blog post in pkgdown news menu\n\nCRAN will notify you by email once your package is accepted. This is when we first push to GitHub with the new version number, i.e. we wait until it’s certain that this version will actually be released on CRAN. Next we create a GitHub release corresponding to this CRAN release, using usethis::use_github_release(). A GitHub release is basically a glorified Git tag. The only aspect of GitHub releases that we regularly take advantage of is the release notes. usethis::use_github_release() creates release notes from the NEWS bullets relevant to the current release. Note that usethis::use_github_release() depends crucially on the CRAN-SUBMISSION file that was written by devtools::submit_cran(): that’s how it knows which SHA to tag. After the successful creation of the GitHub release, use_github_release() deletes this temporary file.\nNow we prepare for the next release by incrementing the version number yet again, this time to a development version using usethis::use_dev_version(). It makes sense to immediately push this state to GitHub so that, for example, any new branches or pull requests clearly have a development version as their base.\nAfter the package has been accepted by CRAN, binaries are built for macOS and Windows. It will also be checked across the panel of CRAN check flavors. These processes unfold over a few days, post-acceptance, and sometimes they uncover errors that weren’t detected by the less comprehensive incoming checks. It’s a good idea to visit your package’s CRAN landing page a few days after release and just make sure that all still seems to be well. Figure 22.1 highlights where these results are linked from a CRAN landing page.\n\n\n\n\n\nFigure 22.1: Link to CRAN check results.\n\n\n\n\nIf there is a problem, prepare a patch release to address it and submit using the same process as before. If this means you are making a second submission less than a week after the previous, explain the situation in cran-comments.md. Getting a package established on CRAN can take a couple of rounds, although the guidance in this chapter is intended to maximize the chance of success on the first try. Future releases, initiated from your end, should be spaced at least one or two months apart, according to CRAN policy.\nOnce your package’s binaries are built and it has passed checks across CRAN’s flavors, it’s time for the fun part: publicizing your package. This takes different forms, depending on the type of release. If this is your initial release (or, at least, the first release for which you really want to attract users), it’s especially important to spread the word. No one will use your helpful new package if they don’t know that it exists. There are a number of places to announce your package, such as Twitter, Mastodon, LinkedIn, Slack communities, etc. Make sure to use any relevant tags, such as the #rstats hashtag. If you have a blog, it’s a great idea to write a post about your release.\nWhen introducing a package, the vibe should be fairly similar to writing your README or a “Getting Started” vignette. Make sure to describe what the package does, so that people who haven’t used it before can understand why they should even care. For existing packages, we tend to write blog posts for minor and major releases, but not for a patch release. In all cases, we find that these blog posts are most effective when they include lots of examples, i.e. “show, don’t tell”. For package updates, remember that the existence of a comprehensive NEWS file frees you from the need to list every last change in your blog post. Instead, you can focus on the most important changes and link to the full release notes, for those who want the gory details.\nIf you do blog about your package, it’s good to capture this as yet another piece of documentation in your pkgdown website. A typical pkgdown site has a “News” item in the top navbar, linking to a “Changelog” which is built from NEWS.md. This drop-down menu is a common place to insert links to any blog posts about the package. You can accomplish this by having YAML like this in your _pkgdown.yml configuration file:\nnews:\n  releases:\n  - text: \"Renaming the default branch (usethis >= 2.1.2)\"\n    href: https://www.tidyverse.org/blog/2021/10/renaming-default-branch/\n  - text: \"usethis 2.0.0\"\n    href: https://www.tidyverse.org/blog/2020/12/usethis-2-0-0/\n  - text: \"usethis 1.6.0\"\n    href: https://www.tidyverse.org/blog/2020/04/usethis-1-6-0/\nCongratulations! You have released your first package to CRAN and made it to the end of the book!"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "23  References",
    "section": "",
    "text": "Bryan, Jennifer. 2018. “Excuse Me, Do You Have a Moment to Talk\nabout Version Control?” The American Statistician 72\n(1): 20–27. https://doi.org/10.1080/00031305.2017.1399928.\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a.\n“Packaging Data Analytical Work Reproducibly Using r (and\nFriends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r\n(and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive\nPretty Printing of R Code. http://styler.r-lib.org.\n\n\nSilge, Julia, John C. Nash, and Spencer Graves. 2018. “Navigating the R Package Universe.”\nThe R Journal 10 (2): 558–63. https://doi.org/10.32614/RJ-2018-058."
  },
  {
    "objectID": "R-CMD-check.html#check-metadata",
    "href": "R-CMD-check.html#check-metadata",
    "title": "Appendix A — R CMD check",
    "section": "A.1 Check metadata",
    "text": "A.1 Check metadata\nR CMD check always starts by describing your current environment.\n\nUsing log directory ‘/some/tmp/path/googledrive.Rcheck’\nUsing R version 4.2.2 (2022-10-31)\nUsing platform: x86_64-apple-darwin17.0 (64-bit)\nUsing session charset: UTF-8\n\nNext the DESCRIPTION file is parsed and the package version and encoding is printed.\n\n\nChecking for file ‘googledrive/DESCRIPTION’\nThis is package ‘googledrive’ version ‘2.1.0.9000’\nPackage encoding: UTF-8"
  },
  {
    "objectID": "R-CMD-check.html#package-structure",
    "href": "R-CMD-check.html#package-structure",
    "title": "Appendix A — R CMD check",
    "section": "A.2 Package structure",
    "text": "A.2 Package structure\n\n\nChecking package directory. The directory you’re checking must exist - devtools::check() protects you against this problem.\n\n\n\nChecking if this is a source package. You must check a source package, not a binary or installed package. This should never fail if you use devtools::check().\n\n\n\nChecking for executable files. You must not have executable files in your package: they’re not portable, they’re not open source, and they are a security risk. Delete any executable files from your package. (If you’re not submitting to CRAN, you can silence this warning by listing each executable file in the BinaryFiles field in your DESCRIPTION.)\n\n\n\nChecking for hidden files and directories. On Linux and macOS, files with a name starting with . are hidden by default, and you’ve probably included them in your package by mistake. Either delete them, or if they are important, use .Rbuildignore to remove them from the package bundle. R automatically removes some common directories like .git and .svn.\n\n\n\nChecking for portable file names. R packages must work on Windows, Linux and macOS, so you can only use file names that work on all platforms. The easiest way to do this is to stick to letters, numbers, underscores and dashes. Avoid non-English letters and spaces. Fix this check by renaming the listed files.\n\n\n\nChecking for sufficient/correct file permissions. If you can’t read a file, you can’t check it. This check detects the unlikely occurrence that you have files in the package that you don’t have permission to read. Fix this problem by fixing the file permissions.\n\n\n\nChecking whether package ‘XYZ’ can be installed. R CMD check runs R CMD INSTALL to make sure that it’s possible to install your package. If this fails, you should run devtools::install() or the equivalent from RStudio’s menus and debug any problems before continuing.\n\n\n\nChecking installed package size. It’s easy to accidentally include large files that blow up the size of your package. This check ensures that the whole package is less than 5 MB and each subdirectory is less than 1 MB. If you see this message, check that you haven’t accidentally included a large file.\nIf submitting to CRAN, you’ll need to justify the size of your package. First, make sure the package is as small as it possibly can be: try recompressing the data, Section 7.1.1; and minimising vignettes, Chapter 17. If it’s still too large, consider moving data into its own package.\n\n\n\nChecking top-level files. Only specified files and directories are allowed at the top level of the package (e.g. DESCRIPTION, R/, src/). To include other files, you have two choices:\n\nIf they don’t need to be installed (i.e. they’re only used for development tasks), add them to .Rbuildignore with usethis::use_build_ignore().\nIf they need to be installed: move them into inst/. They’ll be moved back to the top-level package directory when installed. Learn more in Section 8.2.\n\n\n\n\nChecking package subdirectories.\n\nDon’t include any empty directories. These are usually removed automatically by R CMD build so you shouldn’t see this error. If you do, just delete the empty directory.\nThe case of files and directories is important. All sub-directories should be lower-case, except for R/. A citation file, if present, should be in inst/CITATION. Rename as needed.\nThe contents of inst/ shouldn’t clash with top-level contents of the package, such as data/ or R/. If they do, rename your files/directories. Learn more in Section 8.2.\n\n\n\n\nChecking for left-over files. Remove any files listed here. They’ve been included in your package by accident."
  },
  {
    "objectID": "R-CMD-check.html#description",
    "href": "R-CMD-check.html#description",
    "title": "Appendix A — R CMD check",
    "section": "A.3 DESCRIPTION",
    "text": "A.3 DESCRIPTION\n\n\nChecking DESCRIPTION meta-information.\n\nThe DESCRIPTION must be valid. You are unlikely to see this error, because devtools::load_all() runs the same check each time you re-load the package.\nIf you use any non-ASCII characters in the DESCRIPTION, you must also specify an encoding. There are only three encodings that work on all platforms: latin1, latin2 and UTF-8. We strongly recommend UTF-8: Encoding: UTF-8. Learn more in Section 7.1.3.\nThe License must refer to either a known license (a complete list can be found at https://svn.r-project.org/R/trunk/share/licenses/license.db), or it must use file LICENSE and that file must exist. Errors here are most likely to be typos. Learn more in Chapter 12.\nYou should either provide Authors@R or Authors and Maintainer. You’ll get an error if you’ve specified both, which you can fix by removing the one you didn’t want. Learn more in Section 9.3.\n\n\n\n\nChecking package dependencies.\n\nAll packages listed in Depends, Imports and LinkingTo must be installed, and their version requirements must be met, otherwise your package can’t be checked.\nPackages listed in Suggests must be installed, unless you’ve set the environment variable _R_CHECK_FORCE_SUGGESTS_ to a false value (e.g. with check(force_suggests = FALSE)). This is useful if some of the suggested packages are not available on all platforms.\nAn easy way to install any missing or outdated dependencies is to run devtools::install_deps(dependencies = TRUE). See also pak::local_install_deps() and pak::local_install_dev_deps().\nR packages can not have a cycle of dependencies: i.e. if package A requires B, then B can not require A (otherwise which one would you load first?). If you see this error, you’ll need to rethink the design of your package. One easy fix is to move the conflicting package from Imports or Depends to Suggests.\nAny packages used in the NAMESPACE must be listed in one of Imports (most commonly) or Depends (only in special cases).\nEvery package listed in Depends must also be imported in the NAMESPACE or accessed with pkg::foo(). If you don’t do this, your package will work when attached to the search path (with library(mypackage)) but will not work when only loaded (e.g. mypackage::foo())\n\n\n\n\nChecking CRAN incoming feasibility. These checks only apply if you’re submitting to CRAN.\n\nIf you’re submitting a new package, you can’t use the same name as an existing package. You’ll need to come up with a new name.\nIf you’re submitting an update, the version number must be higher than the current CRAN version. Update the Version field in DESCRIPTION.\nIf the maintainer of the package has changed (even if it’s just a change in email address), the new maintainer should submit to CRAN, and the old maintainer will receive an email prompting them to confirm the change.\nYou must use a standard open source license, as listed in https://svn.r-project.org/R/trunk/share/licenses/license.db. You can not use a custom license as CRAN does not have the legal resources to review custom agreements.\nThe Title and Description must be free from spelling mistakes. The title of the package must be in title case. Neither title nor description should include either the name of your package or the word “package”. Reword your title and description as needed.\nIf you’re submitting a new package, you’ll always get a NOTE. This reminds the CRAN maintainers to do some extra manual checks.\nAvoid submitting multiple versions of the same package in a short period of time. CRAN prefers at most one submission per month. If you need to fix a major bug, be apologetic."
  },
  {
    "objectID": "R-CMD-check.html#namespace",
    "href": "R-CMD-check.html#namespace",
    "title": "Appendix A — R CMD check",
    "section": "A.4 Namespace",
    "text": "A.4 Namespace\n\n\nChecking if there is a namespace. You must have a NAMESPACE file. This is handled for your automatically by the devtools workflow.\n\n\n\nChecking package namespace information. The NAMESPACE should be parseable by parseNamespaceFile() and valid. If this check fails, it’s a bug in roxygen2.\n\n\n\nChecking whether the package can be loaded with stated dependencies. Runs library(pkg) with R_DEFAULT_PACKAGES=NULL, so the search path is empty (i.e. stats, graphics, grDevices, utils, datasets and methods are not attached like usual). Failure here typically indicates that you’re missing a dependency on one of those packages.\n\n\n\nChecking whether the namespace can be loaded with stated dependencies. Runs loadNamespace(pkg) with R_DEFAULT_PACKAGES=NULL. Failure usually indicates a problem with the namespace."
  },
  {
    "objectID": "R-CMD-check.html#r-code",
    "href": "R-CMD-check.html#r-code",
    "title": "Appendix A — R CMD check",
    "section": "A.5 R code",
    "text": "A.5 R code\n\n\nChecking R files for non-ASCII characters. For maximum portability (i.e. so people can use your package on Windows) you should avoid using non-ASCII characters in R files. It’s ok to use them in comments, but object names shouldn’t use them, and in strings you should use unicode escapes. See the CRAN-specific notes in ?sec-code for more details.\n\n\n\nChecking R files for syntax errors. Obviously your R code must be valid. You’re unlikely to see this error if you’ve been regularly using devtools::load_all().\n\n\n\nChecking dependencies in R code. Errors here often indicate that you’ve forgotten to declare a needed package in the DESCRIPTION. Remember that you should never use require() or library() inside a package - see Section 9.6, Chapter 10, and Chapter 11 for more details on best practices.\nAlternatively, you may have accidentally used ::: to access an exported function from a package. Switch to :: instead.\n\n\n\nChecking S3 generic/method consistency. S3 methods must have a compatible function signature with their generic. This means that the method must have the same arguments as its generic, with one exception: if the generic includes ... the method can have additional arguments.\nA common cause of this error is defining print methods, because the print() generic contains...:\n\n# BAD\nprint.my_class <- function(x) cat(\"Hi\")\n\n# GOOD\nprint.my_class <- function(x, ...) cat(\"Hi\")\n\n# Also ok\nprint.my_class <- function(x, ..., my_arg = TRUE) cat(\"Hi\")\n\n\n\n\nChecking replacement functions. Replacement functions (e.g. functions that are called like foo(x) <- y), must have value as the last argument.\n\n\n\nChecking R code for possible problems. This is a compound check for a wide range of problems:\n\nCalls to library.dynam() (and library.dynam.unload()) should look like library.dynam(\"name\"), not library.dynam(\"name.dll\"). Remove the extension to fix this error.\nPut library.dynam() in .onLoad(), not .onAttach(); put packageStartupMessage() in .onAttach(), not .onLoad(). Put library.dynam.unload() in .onUnload(). If you use any of these functions, make sure they’re in the right place.\nDon’t use unlockBinding() or assignInNamespace() to modify objects that don’t belong to you.\ncodetools::checkUsagePackage() is called to check that your functions don’t use variables that don’t exist. This sometimes raises false positives with functions that use non-standard evaluation (NSE), like subset() or with(). Generally, we think you should avoid NSE in package functions, and hence avoid this NOTE, but if you can not, see ?globalVariables for how to suppress this NOTE.\nYou are not allowed to use .Internal() in a package. Either call the R wrapper function, or write your own C function. (If you copy and paste the C function from base R, make sure to maintain the copyright notice, use a GPL-2 compatible license, and list R-core in the Authors@R field.)\nSimilarly you are not allowed to use ::: to access non-exported functions from other packages. Either ask the package maintainer to export the function you need, or write your own version of it using exported functions. Alternatively, if the licenses are compatible you can copy and paste the exported function into your own package. If you do this, remember to update Authors@R.\nDon’t use assign() to modify objects in the global environment. If you need to maintain state across function calls, create your own environment, as described in Section 7.4.\nDon’t use attach() in your code. Instead refer to variables explicitly.\nDon’t use data() without specifying the envir argument. Otherwise the data will be loaded in the global environment.\nDon’t use deprecated or defunct functions. Update your code to use the latest versions.\nYou must use TRUE and FALSE in your code (and examples), not T and F.\n\n\n\n\nChecking whether the package can be loaded. R loads your package with library(). Failure here typically indicates a problem with .onLoad() or .onAttach().\n\n\n\nChecking whether the package can be unloaded cleanly. Loads with library() and then detach()es. If this fails, check .onUnload() and .onDetach().\n\n\n\nChecking whether the namespace can be unloaded cleanly. Runs loadNamespace(\"pkg\"); unloadNamespace(\"pkg\"). Check .onUnload() for problems.\n\n\n\nChecking loading without being on the library search path. Calls library(x, lib.loc = ...). Failure here indicates that you are making a false assumption in .onLoad() or .onAttach()."
  },
  {
    "objectID": "R-CMD-check.html#data",
    "href": "R-CMD-check.html#data",
    "title": "Appendix A — R CMD check",
    "section": "A.6 Data",
    "text": "A.6 Data\n\n\nChecking contents of ‘data’ directory.\n\nThe data directory can only contain file types described in Section 7.1.\nData files can contain non-ASCII characters only if the encoding is correctly set. This usually shouldn’t be a problem if you’re saving .Rdata files. If you do see this error, look at the Encoding() of each column in the data frame, and ensure none are “unknown”. (You’ll typically need to fix this somewhere in the import process). Learn more in Section 7.1.3.\nIf you’ve compressed a data file with bzip2 or xz you need to declare at least Depends: R (>= 2.10) in your DESCRIPTION.\nIf you’ve used a sub-optimal compression algorithm for your data, re-compress with the suggested algorithm."
  },
  {
    "objectID": "R-CMD-check.html#documentation",
    "href": "R-CMD-check.html#documentation",
    "title": "Appendix A — R CMD check",
    "section": "A.7 Documentation",
    "text": "A.7 Documentation\nIf you’re grappling with documentation problems specifically, you may be able to iterate more quickly by using devtools::check_man(), which attempts to run only the relevant subset of checks. It also automatically calls devtools::document() for you.\n\n\nChecking Rd files. This checks that all man/*.Rd files use the correct Rd syntax. If this fails, it indicates a bug in roxygen2.\n\n\n\nChecking Rd metadata. Names and aliases must be unique across all documentation files in a package. If you encounter this problem you’ve accidentally used the same @name or @aliases in multiple places; make sure they’re unique.\n\n\n\nChecking Rd line widths. Lines in Rd files must be less than 90 characters wide. This is unlikely to occur if you wrap your R code, and hence roxygen comments, to 80 characters. For very long URLs, use a link-shortening service like bit.ly.\n\n\n\nChecking Rd cross-references. Errors here usually represent typos.\n\n\n\nChecking for missing documentation entries. All exported objects must be documented. See ?tools::undoc for more details.\n\n\n\nChecking for code/documentation mismatches. This check ensures that the documentation matches the code. This should never fail because you’re using roxygen2 which automatically keeps them in sync and check() should usually re-document() your package. In any case, the solution is often to re-run devtools::document().\n\n\n\nChecking Rd \\usage sections. All arguments must be documented, and all @params must document an existing argument. You may have forgotten to document an argument, forgotten to remove the documentation for an argument that you’ve removed, or misspelled an argument name.\nS3 and S4 methods need to use special \\S3method{} and \\S4method{} markup in the Rd file. Roxygen2 will generate this for you automatically.\n\n\n\nChecking Rd contents. This checks for auto-generated content made by package.skeleton(). Since you’re not using package.skeleton() you should never have a problem here.\n\n\n\nChecking for unstated dependencies in examples. If you use a package only for an example, make sure it’s listed in the Suggests field. Learn more about how to use different types of dependencies in your examples in Chapter 11.\n\n\n\nChecking examples. Every documentation example must run without errors, and must not take too long. See Section 16.5 for details.\n\n\n\nChecking PDF version of manual. Occasionally you’ll get an error when building the PDF manual. This is usually because the pdf is built by latex and you’ve forgotten to escape something. Debugging this is painful - your best bet is to look up the latex logs and combined tex file and work back from there to .Rd files then back to a roxygen comment. Any such failure is potentially a bug in roxygen2, so open an issue."
  },
  {
    "objectID": "R-CMD-check.html#demos",
    "href": "R-CMD-check.html#demos",
    "title": "Appendix A — R CMD check",
    "section": "A.8 Demos",
    "text": "A.8 Demos\n\n\nChecking index information. If you’ve written demos, each demo must be listed in demo/00Index. The file should look like:\ndemo-name-without-extension  Demo description\nanother-demo-name            Another description"
  },
  {
    "objectID": "R-CMD-check.html#compiled-code",
    "href": "R-CMD-check.html#compiled-code",
    "title": "Appendix A — R CMD check",
    "section": "A.9 Compiled code",
    "text": "A.9 Compiled code\n\n\nChecking foreign function calls. .Call(), .C(), .Fortran(), .External() must always be called either with a NativeSymbolInfo object (as created with @useDynLib) or use the .package argument. See ?tools::checkFF for more details.\n\n\n\nChecking line endings in C/C++/Fortran sources/headers. Always use LF as a line ending.\n\n\n\nChecking line endings in Makefiles. As above.\n\n\n\nChecking for portable use of $(BLAS_LIBS) and $(LAPACK_LIBS). Errors here indicate an issue with your use of BLAS and LAPACK.\n\n\n\nChecking compiled code. Checks that you’re not using any C functions that you shouldn’t."
  },
  {
    "objectID": "R-CMD-check.html#tests",
    "href": "R-CMD-check.html#tests",
    "title": "Appendix A — R CMD check",
    "section": "A.10 Tests",
    "text": "A.10 Tests\n\n\nChecking for unstated dependencies in tests. Every package used by tests must be included in the dependencies.\n\n\n\nChecking tests. Each file in tests/ is run. If you’ve followed the instructions in Chapter 13 you’ll have at least one file: testthat.R. The output from R CMD check is not usually that helpful, so you may need to look at the log file package.Rcheck/tests/testthat.Rout. Fix any failing tests by iterating with devtools::test().\nOccasionally you may have a problem where the tests pass when run interactively with devtools::test(), but fail when in R CMD check. This usually indicates that you’ve made a faulty assumption about the testing environment, and it’s often hard to figure it out."
  },
  {
    "objectID": "R-CMD-check.html#vignettes",
    "href": "R-CMD-check.html#vignettes",
    "title": "Appendix A — R CMD check",
    "section": "A.11 Vignettes",
    "text": "A.11 Vignettes\nThis is a tricky enough topic that it also receives substantial coverage in the main body of the book; see Section 17.5.\n\n\nChecking ‘build’ directory. build/ is used to track vignette builds. It’s hard to imagine how this check could fail unless you’ve accidentally .Rbuildignored the build/ directory.\n\n\n\nChecking installed files from ‘inst/doc’. Don’t put files in inst/doc - keep your vignettes and the files they need in vignettes/.\n\n\n\nChecking files in ‘vignettes’. Problems here are usually straightforward - you’ve included files that are already included in R (like jss.cls, jss.bst, or Sweave.sty), or you have leftover latex compilation files. Delete these files.\n\n\n\nChecking for sizes of PDF files under ‘inst/doc’. If you’re making PDF vignettes, you can make them as small as possible by running tools::compactPDF().\n\n\n\nChecking for unstated dependencies in vignettes. As with tests, every package that you use in a vignette must be listed in the DESCRIPTION. If a package is used only for a vignette, and not elsewhere, make sure it’s listed in Suggests. If you really want to use a package and you don’t want to list it in DESCRIPTION, write an article instead of a vignette.\n\n\n\nChecking package vignettes in ‘inst/doc’. This checks that every source vignette (i.e. .Rmd) has a built equivalent (i.e. .html) in inst/doc. This shouldn’t fail if you’ve used the standard process outlined in Chapter 17. If there is a problem, start by checking your .Rbuildignore.\n\n\n\nChecking running R code from vignettes. The R code from each vignette is run. If you want to deliberately execute errors (to show the user what failure looks like), make sure the chunk has error = TRUE, purl = FALSE.\n\n\n\nChecking re-building of vignette outputs. Each vignette is re-knit to make sure that the output corresponds to the input. Again, this shouldn’t fail in normal circumstances."
  },
  {
    "objectID": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "href": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "title": "Appendix A — R CMD check",
    "section": "A.12 NOTEs that are informational",
    "text": "A.12 NOTEs that are informational\nOur blanket advice is to eliminate all ERRORs, WARNINGs, and even NOTEs that you see in R CMD check. But there are a few exceptions, i.e. there are a couple of NOTEs that do you not need to fix (and, indeed, probably can not fix).\n\nA.12.1 Initial CRAN submission\nWhen a package first goes to CRAN, there will always be one NOTE that alerts the CRAN maintainers that this is a new submission and that they’ll need to do some extra checks. You can’t eliminate this NOTE.\n* checking CRAN incoming feasibility ... NOTE\nMaintainer: 'Jane Doe <jane@example.com>'\n\nNew submission\n\n\nA.12.2 Non-ASCII characters in data\nIf your package’s data contains non-ASCII characters, you will get a NOTE like this, but it does not necessarily mean you need to do anything about it.\nCheck: data for non-ASCII characters\nResult: NOTE\n     Note: found 25 marked UTF-8 strings\nAs long as you are aware of the non-ASCII characters and the NOTE mentions your intended and declared encoding (preferably UTF-8), all is well.\n\n\nA.12.3 Rd cross-references\nIf your roxygen comments contain a cross-reference to a package that is not a formal, direct dependency, you might see a NOTE like this:\nCheck: Rd cross-references\nResult: NOTE\n    Undeclared package ‘jsonlite’ in Rd xrefs\nThis could happen if you want to document something related to a hard indirect dependency: There’s a legitimate reason to link to a topic in the other package and it is basically guaranteed to be installed. Therefore, in practice, often more good than harm comes from the cross-reference.\nIn our experience, this NOTE is only seen on certain CRAN check flavors and not others. Thus far, we have never been directed to address this NOTE by CRAN maintainers."
  },
  {
    "objectID": "whole-game.html#load-devtools-and-friends",
    "href": "whole-game.html#load-devtools-and-friends",
    "title": "1  The Whole Game",
    "section": "\n1.1 Load devtools and friends",
    "text": "1.1 Load devtools and friends\nYou can initiate your new package from any active R session. You don’t need to worry about whether you’re in an existing or new project or not. The functions we use ensure that we create a new clean project for the package.\nLoad the devtools package, which is the public face of a set of packages that support various aspects of package development. The most obvious of these is the usethis package, which you’ll see is also being loaded.\n\nlibrary(devtools)\n#> Warning: package 'devtools' was built under R version 4.2.3\n#> Loading required package: usethis\n#> Warning: package 'usethis' was built under R version 4.2.3\n\nDo you have an old version of devtools? Compare your version against ours and upgrade if necessary.\n\npackageVersion(\"devtools\")\n#> [1] '2.4.5'"
  },
  {
    "objectID": "whole-game.html#toy-package-regexcite",
    "href": "whole-game.html#toy-package-regexcite",
    "title": "1  The Whole Game",
    "section": "\n1.2 Toy package: regexcite",
    "text": "1.2 Toy package: regexcite\nTo help walk you through the process, we use various functions from devtools to build a small toy package from scratch, with features commonly seen in released packages:\n\nFunctions to address a specific need, in this case helpers for work with regular expressions.\nVersion control and an open development process.\n\nThis is completely optional in your work, but highly recommended. You’ll see how Git and GitHub help us expose all the intermediate stages of our toy package.\n\n\nAccess to established workflows for installation, getting help, and checking quality.\n\nDocumentation for individual functions via roxygen2.\nUnit testing with testthat.\nDocumentation for the package as a whole via an executable README.Rmd.\n\n\n\nWe call the package regexcite and it contains a couple of functions that make common tasks with regular expressions easier. Please note that these functions are very simple and we’re only using them here as a means to guide you through the package development process. If you’re looking for actual helpers for work with regular expressions, there are several proper R packages that address this problem space:\n\n\nstringr (which uses stringi)\nstringi\nrex\nrematch2\n\nAgain, the regexcite package itself is just a device for demonstrating a typical workflow for package development with devtools."
  },
  {
    "objectID": "whole-game.html#preview-the-finished-product",
    "href": "whole-game.html#preview-the-finished-product",
    "title": "1  The Whole Game",
    "section": "\n1.3 Preview the finished product",
    "text": "1.3 Preview the finished product\nThe regexcite package is tracked during its development with the Git version control system. This is purely optional and you can certainly follow along without implementing this. A nice side benefit is that we eventually connect it to a remote repository on GitHub, which means you can see the glorious result we are working towards by visiting regexcite on GitHub: https://github.com/jennybc/regexcite. By inspecting the commit history and especially the diffs, you can see exactly what changes at each step of the process laid out below."
  },
  {
    "objectID": "whole-game.html#create_package",
    "href": "whole-game.html#create_package",
    "title": "1  The Whole Game",
    "section": "\n1.4 create_package()\n",
    "text": "1.4 create_package()\n\nCall create_package() to initialize a new package in a directory on your computer. create_package() will automatically create that directory if it doesn’t exist yet (and that is usually the case). See Section 4.1 for more on creating packages.\nMake a deliberate choice about where to create this package on your computer. It should probably be somewhere within your home directory, alongside your other R projects. It should not be nested inside another RStudio Project, R package, or Git repo. Nor should it be in an R package library, which holds packages that have already been built and installed. The conversion of the source package we create here into an installed package is part of what devtools facilitates. Don’t try to do devtools’ job for it!\nOnce you’ve selected where to create this package, substitute your chosen path into a create_package() call like this:\n\ncreate_package(\"~/path/to/regexcite\")\n\nFor the creation of this book we have to work in a temporary directory, because the book is built non-interactively in the cloud. Behind the scenes, we’re executing our own create_package() command, but don’t be surprised if our output differs a bit from yours.\n\n#> ✔ Creating 'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite/'\n#> ✔ Setting active project to 'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite'\n#> ✔ Creating 'R/'\n#> ✔ Writing 'DESCRIPTION'\n#> Package: regexcite\n#> Title: What the Package Does (One Line, Title Case)\n#> Version: 0.0.0.9000\n#> Authors@R (parsed):\n#>     * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\n#> Description: What the package does (one paragraph).\n#> License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n#>     license\n#> Encoding: UTF-8\n#> Roxygen: list(markdown = TRUE)\n#> RoxygenNote: 7.2.3\n#> ✔ Writing 'NAMESPACE'\n#> ✔ Writing 'regexcite.Rproj'\n#> ✔ Adding '^regexcite\\\\.Rproj$' to '.Rbuildignore'\n#> ✔ Adding '.Rproj.user' to '.gitignore'\n#> ✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n#> ✔ Setting active project to '<no active project>'\n\nIf you’re working in RStudio, you should find yourself in a new instance of RStudio, opened into your new regexcite package (and Project). If you somehow need to do this manually, navigate to the directory and double click on regexcite.Rproj. RStudio has special handling for packages and you should now see a Build tab in the same pane as Environment and History.\nYou probably need to call library(devtools) again, because create_package() has probably dropped you into a fresh R session, in your new package.\n\nlibrary(devtools)\n\nWhat’s in this new directory that is also an R package and, probably, an RStudio Project? Here’s a listing (locally, you can consult your Files pane):\n\n\n\n\npath\ntype\n\n\n\n.gitignore\nfile\n\n\n.Rbuildignore\nfile\n\n\nDESCRIPTION\nfile\n\n\nNAMESPACE\nfile\n\n\nR\ndirectory\n\n\nregexcite.Rproj\nfile\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nIn the Files pane, go to More (gear symbol) > Show Hidden Files to toggle the visibility of hidden files (a.k.a. “dotfiles”). A select few are visible all the time, but sometimes you want to see them all.\n\n\n\n\n.Rbuildignore lists files that we need to have around but that should not be included when building the R package from source. If you aren’t using RStudio, create_package() may not create this file (nor .gitignore) at first, since there’s no RStudio-related machinery that needs to be ignored. However, you will likely develop the need for .Rbuildignore at some point, regardless of what editor you are using. It is discussed in more detail in Section 3.3.1.\n\n.Rproj.user, if you have it, is a directory used internally by RStudio.\n\n.gitignore anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.\n\nDESCRIPTION provides metadata about your package. We edit this shortly and Chapter 9 covers the general topic of the DESCRIPTION file.\n\nNAMESPACE declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.\nThe R/ directory is the “business end” of your package. It will soon contain .R files with function definitions.\n\nregexcite.Rproj is the file that makes this directory an RStudio Project. Even if you don’t use RStudio, this file is harmless. Or you can suppress its creation with create_package(..., rstudio = FALSE). More in Section 4.2."
  },
  {
    "objectID": "whole-game.html#use_git",
    "href": "whole-game.html#use_git",
    "title": "1  The Whole Game",
    "section": "\n1.5 use_git()\n",
    "text": "1.5 use_git()\n\nThe regexcite directory is an R source package and an RStudio Project. Now we make it also a Git repository, with use_git(). (By the way, use_git() works in any project, regardless of whether it’s an R package.)\n\nuse_git()\n#> ✔ Initialising Git repo\n#> ✔ Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\n\nIn an interactive session, you will be asked if you want to commit some files here and you should accept the offer. Behind the scenes, we’ll also commit those same files.\nSo what has changed in the package? Only the creation of a .git directory, which is hidden in most contexts, including the RStudio file browser. Its existence is evidence that we have indeed initialized a Git repo here.\n\n\n\n\npath\ntype\n\n\n.git\ndirectory\n\n\n\n\nIf you’re using RStudio, it probably requested permission to relaunch itself in this Project, which you should do. You can do so manually by quitting, then relaunching RStudio by double clicking on regexcite.Rproj. Now, in addition to package development support, you have access to a basic Git client in the Git tab of the Environment/History/Build pane.\n\nClick on History (the clock icon in the Git pane) and, if you consented, you will see an initial commit made via use_git():\n\n\n\n\ncommit\nauthor\nmessage\n\n\n9c6a0fbb2b…\nzhenghu 1308155474@qq.com\n\nInitial commit\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio can initialize a Git repository, in any Project, even if it’s not an R package, as long you’ve set up RStudio + Git integration. Do Tools > Version Control > Project Setup. Then choose Version control system: Git and initialize a new git repository for this project."
  },
  {
    "objectID": "whole-game.html#write-the-first-function",
    "href": "whole-game.html#write-the-first-function",
    "title": "1  The Whole Game",
    "section": "\n1.6 Write the first function",
    "text": "1.6 Write the first function\nA fairly common task when dealing with strings is the need to split a single string into many parts. The strsplit() function in base R does exactly this.\n\n(x <- \"alfa,bravo,charlie,delta\")\n#> [1] \"alfa,bravo,charlie,delta\"\nstrsplit(x, split = \",\")\n#> [[1]]\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nTake a close look at the return value.\n\nstr(strsplit(x, split = \",\"))\n#> List of 1\n#>  $ : chr [1:4] \"alfa\" \"bravo\" \"charlie\" \"delta\"\n\nThe shape of this return value often surprises people or, at least, inconveniences them. The input is a character vector of length one and the output is a list of length one. This makes total sense in light of R’s fundamental tendency towards vectorization. But sometimes it’s still a bit of a bummer. Often you know that your input is morally a scalar, i.e. it’s just a single string, and really want the output to be the character vector of its parts.\nThis leads R users to employ various methods of “unlist”-ing the result:\n\nunlist(strsplit(x, split = \",\"))\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nstrsplit(x, split = \",\")[[1]]\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nThe second, safer solution is the basis for the inaugural function of regexcite: strsplit1().\n\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\nThis book does not teach you how to write functions in R. To learn more about that take a look at the Functions chapter of R for Data Science and the Functions chapter of Advanced R.\n\n\n\n\n\n\nTip\n\n\n\nThe name of strsplit1() is a nod to the very handy paste0(), which first appeared in R 2.15.0 in 2012. paste0() was created to address the extremely common use case of paste()-ing strings together without a separator. paste0() has been lovingly described as “statistical computing’s most influential contribution of the 21st century”.\nThe strsplit1() function was so inspiring that it’s now a real function in the stringr package: stringr::str_split_1()!"
  },
  {
    "objectID": "whole-game.html#use_r",
    "href": "whole-game.html#use_r",
    "title": "1  The Whole Game",
    "section": "\n1.7 use_r()\n",
    "text": "1.7 use_r()\n\nWhere should you put the definition of strsplit1()? Save it in a .R file, in the R/ subdirectory of your package. A reasonable starting position is to make a new .R file for each user-facing function in your package and name the file after the function. As you add more functions, you’ll want to relax this and begin to group related functions together. We’ll save the definition of strsplit1() in the file R/strsplit1.R.\nThe helper use_r() creates and/or opens a script below R/. It really shines in a more mature package, when navigating between .R files and the associated test file. But, even here, it’s useful to keep yourself from getting too carried away while working in Untitled4.\n\nuse_r(\"strsplit1\")\n#> • Edit 'R/strsplit1.R'\n\nPut the definition of strsplit1() and only the definition of strsplit1() in R/strsplit1.R and save it. The file R/strsplit1.R should NOT contain any of the other top-level code we have recently executed, such as the definition of our practice input x, library(devtools), or use_git(). This foreshadows an adjustment you’ll need to make as you transition from writing R scripts to R packages. Packages and scripts use different mechanisms to declare their dependency on other packages and to store example or test code. We explore this further in Chapter 6."
  },
  {
    "objectID": "whole-game.html#sec-whole-game-load-all",
    "href": "whole-game.html#sec-whole-game-load-all",
    "title": "1  The Whole Game",
    "section": "\n1.8 load_all()\n",
    "text": "1.8 load_all()\n\nHow do we test drive strsplit1()? If this were a regular R script, we might use RStudio to send the function definition to the R Console and define strsplit1() in the global environment. Or maybe we’d call source(\"R/strsplit1.R\"). For package development, however, devtools offers a more robust approach.\nCall load_all() to make strsplit1() available for experimentation.\n\nload_all()\n#> ℹ Loading regexcite\n\nNow call strsplit1(x) to see how it works.\n\n(x <- \"alfa,bravo,charlie,delta\")\n#> [1] \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nNote that load_all() has made the strsplit1() function available, although it does not exist in the global environment.\n\nexists(\"strsplit1\", where = globalenv(), inherits = FALSE)\n#> [1] FALSE\n\nIf you see TRUE instead of FALSE, that indicates you’re still using a script-oriented workflow and sourcing your functions. Here’s how to get back on track:\n\nClean out the global environment and restart R.\nRe-attach devtools with library(devtools) and re-load regexcite with load_all().\nRedefine the test input x and call strsplit1(x, split = \",\") again. This should work!\nRun exists(\"strsplit1\", where = globalenv(), inherits = FALSE) again and you should see FALSE.\n\nload_all() simulates the process of building, installing, and attaching the regexcite package. As your package accumulates more functions, some exported, some not, some of which call each other, some of which call functions from packages you depend on, load_all() gives you a much more accurate sense of how the package is developing than test driving functions defined in the global environment. Also load_all() allows much faster iteration than actually building, installing, and attaching the package. See Section 4.4 for more about load_all().\nTo review what we’ve done so far:\n\nWe wrote our first function, strsplit1(), to split a string into a character vector (not a list containing a character vector).\nWe used load_all() to quickly make this function available for interactive use, as if we’d built and installed regexcite and attached it via library(regexcite).\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes load_all() in the Build menu, in the Build pane via More > Load All, and in keyboard shortcuts Ctrl + Shift + L (Windows & Linux) or Cmd + Shift + L (macOS).\n\n\n\n1.8.1 Commit strsplit1()\n\nIf you’re using Git, use your preferred method to commit the new R/strsplit1.R file. We do so behind the scenes here and here’s the associated diff.\n\ndiff --git a/R/strsplit1.R b/R/strsplit1.R\nnew file mode 100644\nindex 0000000..29efb88\n--- /dev/null\n+++ b/R/strsplit1.R\n@@ -0,0 +1,3 @@\n+strsplit1 <- function(x, split) {\n+  strsplit(x, split = split)[[1]]\n+}\n\nFrom this point on, we commit after each step. Remember these commits are available in the public repository."
  },
  {
    "objectID": "whole-game.html#check",
    "href": "whole-game.html#check",
    "title": "1  The Whole Game",
    "section": "\n1.9 check()\n",
    "text": "1.9 check()\n\nWe have informal, empirical evidence that strsplit1() works. But how can we be sure that all the moving parts of the regexcite package still work? This may seem silly to check, after such a small addition, but it’s good to establish the habit of checking this often.\nR CMD check, executed in the shell, is the gold standard for checking that an R package is in full working order. check() is a convenient way to run this without leaving your R session.\nNote that check() produces rather voluminous output, optimized for interactive consumption. We intercept that here and just reveal a summary. Your local check() output will be different.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 36.8s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n0 errors ✔ | 1 warning ✖ | 0 notes ✔\n\nIt is essential to actually read the output of the check! Deal with problems early and often. It’s just like incremental development of .R and .Rmd files. The longer you go between full checks that everything works, the harder it becomes to pinpoint and solve your problems.\nAt this point, we expect 1 warning (and 0 errors, 0 notes):\nNon-standard license specification:\n  `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n  license\nWe’ll address that soon, by doing exactly what it says. You can learn more about check() in Section 4.5.\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes check() in the Build menu, in the Build pane via Check, and in keyboard shortcuts Ctrl + Shift + E (Windows & Linux) or Cmd + Shift + E (macOS)."
  },
  {
    "objectID": "whole-game.html#edit-description",
    "href": "whole-game.html#edit-description",
    "title": "1  The Whole Game",
    "section": "\n1.10 Edit DESCRIPTION\n",
    "text": "1.10 Edit DESCRIPTION\n\nThe DESCRIPTION file provides metadata about your package and is covered fully in Chapter 9. This is a good time to have a look at regexcite’s current DESCRIPTION. You’ll see it’s populated with boilerplate content, which needs to be replaced.\nTo add your own metadata, make these edits:\n\nMake yourself the author. If you don’t have an ORCID, you can omit the comment = ... portion.\nWrite some descriptive text in the Title and Description fields.\n\n\n\n\n\n\n\nRStudio\n\n\n\nUse Ctrl + . in RStudio and start typing “DESCRIPTION” to activate a helper that makes it easy to open a file for editing. In addition to a filename, your hint can be a function name. This is very handy once a package has lots of files.\n\n\nWhen you’re done, DESCRIPTION should look similar to this:\n\n\n\nPackage: regexcite\nTitle: Make Regular Expressions More Exciting\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"Jane\", \"Doe\", , \"jane@example.com\", role = c(\"aut\", \"cre\"))\nDescription: Convenience functions to make some common tasks with string\n    manipulation and regular expressions a bit easier.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.2"
  },
  {
    "objectID": "whole-game.html#use_mit_license",
    "href": "whole-game.html#use_mit_license",
    "title": "1  The Whole Game",
    "section": "\n1.11 use_mit_license()\n",
    "text": "1.11 use_mit_license()\n\n\nPick a License, Any License. – Jeff Atwood\n\nWe currently have a placeholder in the License field of DESCRIPTION that’s deliberately invalid and suggests a resolution.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nTo configure a valid license for the package, call use_mit_license().\n\nuse_mit_license()\n#> ✔ Adding 'MIT + file LICENSE' to License\n#> ✔ Writing 'LICENSE'\n#> ✔ Writing 'LICENSE.md'\n#> ✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\nThis configures the License field correctly for the MIT license, which promises to name the copyright holders and year in a LICENSE file. Open the newly created LICENSE file and confirm it looks something like this:\n\nYEAR: 2023\nCOPYRIGHT HOLDER: regexcite authors\n\nLike other license helpers, use_mit_license() also puts a copy of the full license in LICENSE.md and adds this file to .Rbuildignore. It’s considered a best practice to include a full license in your package’s source, such as on GitHub, but CRAN disallows the inclusion of this file in a package tarball. You can learn more about licensing in Chapter 12."
  },
  {
    "objectID": "whole-game.html#sec-whole-game-document",
    "href": "whole-game.html#sec-whole-game-document",
    "title": "1  The Whole Game",
    "section": "\n1.12 document()\n",
    "text": "1.12 document()\n\nWouldn’t it be nice to get help on strsplit1(), just like we do with other R functions? This requires that your package have a special R documentation file, man/strsplit1.Rd, written in an R-specific markup language that is sort of like LaTeX. Luckily we don’t necessarily have to author that directly.\nWe write a specially formatted comment right above strsplit1(), in its source file, and then let a package called roxygen2 handle the creation of man/strsplit1.Rd. The motivation and mechanics of roxygen2 are covered in Chapter 16.\nIf you use RStudio, open R/strsplit1.R in the source editor and put the cursor somewhere in the strsplit1() function definition. Now do Code > Insert roxygen skeleton. A very special comment should appear above your function, in which each line begins with #'. RStudio only inserts a barebones template, so you will need to edit it to look something like that below.\nIf you don’t use RStudio, create the comment yourself. Regardless, you should modify it to look something like this:\n\n#' Split a string\n#'\n#' @param x A character vector with one element.\n#' @param split What to split on.\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' strsplit1(x, split = \",\")\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n\nBut we’re not done yet! We still need to trigger the conversion of this new roxygen comment into man/strsplit1.Rd with document():\n\ndocument()\n#> ℹ Updating regexcite documentation\n#> Setting `RoxygenNote` to \"7.2.3\"\n#> ℹ Loading regexcite\n#> Writing 'NAMESPACE'\n#> Writing 'strsplit1.Rd'\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes document() in the Build menu, in the Build pane via More > Document, and in keyboard shortcuts Ctrl + Shift + D (Windows & Linux) or Cmd + Shift + D (macOS).\n\n\nYou should now be able to preview your help file like so:\n\n?strsplit1\n\nYou’ll see a message like “Rendering development documentation for ‘strsplit1’”, which reminds that you are basically previewing draft documentation. That is, this documentation is present in your package’s source, but is not yet present in an installed package. In fact, we haven’t installed regexcite yet, but we will soon. If ?strsplit1 doesn’t work for you, you may need to call load_all() first, then try again.\nNote also that your package’s documentation won’t be properly wired up until it has been formally built and installed. This polishes off niceties like the links between help files and the creation of a package index.\n\n1.12.1 NAMESPACE changes\nIn addition to converting strsplit1()’s special comment into man/strsplit1.Rd, the call to document() updates the NAMESPACE file, based on @export tags found in roxygen comments. Open NAMESPACE for inspection. The contents should be:\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(strsplit1)\n\nThe export directive in NAMESPACE is what makes strsplit1() available to a user after attaching regexcite via library(regexcite). Just as it is entirely possible to author .Rd files “by hand”, you can manage NAMESPACE explicitly yourself. But we choose to delegate this to devtools (and roxygen2)."
  },
  {
    "objectID": "whole-game.html#check-again",
    "href": "whole-game.html#check-again",
    "title": "1  The Whole Game",
    "section": "\n1.13 check() again",
    "text": "1.13 check() again\nregexcite should pass R CMD check cleanly now and forever more: 0 errors, 0 warnings, 0 notes.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 30.5s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔"
  },
  {
    "objectID": "whole-game.html#install",
    "href": "whole-game.html#install",
    "title": "1  The Whole Game",
    "section": "\n1.14 install()\n",
    "text": "1.14 install()\n\nNow that we know we have a minimum viable product, let’s install the regexcite package into your library via install():\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/1.study/R/R-4.2.0/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/1.study/R/R-4.2.0/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes similar functionality in the Build menu and in the Build pane via Install and Restart, and in keyboard shortcuts Ctrl + Shift + B (Windows & Linux) or Cmd + Shift + B (macOS).\n\n\nAfter installation is complete, we can attach and use regexcite like any other package. Let’s revisit our small example from the top. This is also a good time to restart your R session and ensure you have a clean workspace.\n\nlibrary(regexcite)\n\nx <- \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#> [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nSuccess!"
  },
  {
    "objectID": "whole-game.html#use_testthat",
    "href": "whole-game.html#use_testthat",
    "title": "1  The Whole Game",
    "section": "\n1.15 use_testthat()\n",
    "text": "1.15 use_testthat()\n\nWe’ve tested strsplit1() informally, in a single example. We can formalize this as a unit test. This means we express a concrete expectation about the correct strsplit1() result for a specific input.\nFirst, we declare our intent to write unit tests and to use the testthat package for this, via use_testthat():\n\nuse_testthat()\n#> ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n#> ✔ Adding '3' to Config/testthat/edition\n#> ✔ Creating 'tests/testthat/'\n#> ✔ Writing 'tests/testthat.R'\n#> • Call `use_test()` to initialize a basic test file and open it for editing.\n\nThis initializes the unit testing machinery for your package. It adds Suggests: testthat to DESCRIPTION, creates the directory tests/testthat/, and adds the script tests/testthat.R. You’ll notice that testthat is probably added with a minimum version of 3.0.0 and a second DESCRIPTION field, Config/testthat/edition: 3. We’ll talk more about those details in Chapter 13.\nHowever, it’s still up to YOU to write the actual tests!\nThe helper use_test() opens and/or creates a test file. You can provide the file’s basename or, if you are editing the relevant source file in RStudio, it will be automatically generated. For many of you, if R/strsplit1.R is the active file in RStudio, you can just call use_test(). However, since this book is built non-interactively, we must provide the basename explicitly:\n\nuse_test(\"strsplit1\")\n#> ✔ Writing 'tests/testthat/test-strsplit1.R'\n#> • Edit 'tests/testthat/test-strsplit1.R'\n\nThis creates the file tests/testthat/test-strsplit1.R. If it had already existed, use_test() would have just opened it. You will notice that there is an example test in the newly created file - delete that code and replace it with this content:\n\ntest_that(\"strsplit1() splits a string\", {\n  expect_equal(strsplit1(\"a,b,c\", split = \",\"), c(\"a\", \"b\", \"c\"))\n})\n\nThis tests that strsplit1() gives the expected result when splitting a string.\nRun this test interactively, as you will when you write your own. If test_that() or strsplit1() can’t be found, that suggests that you probably need to call load_all().\nGoing forward, your tests will mostly run en masse and at arm’s length via test():\n\n\ntest()\n#> ℹ Testing regexcite\n#> ✔ | F W S  OK | Context\n#> \n#> ⠏ |         0 | strsplit1                                           \n#> ✔ |         1 | strsplit1\n#> \n#> ══ Results ═════════════════════════════════════════════════════════\n#> [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes test() in the Build menu, in the Build pane via More > Test package, and in keyboard shortcuts Ctrl + Shift + T (Windows & Linux) or Cmd + Shift + T (macOS).\n\n\nYour tests are also run whenever you check() the package. In this way, you basically augment the standard checks with some of your own, that are specific to your package. It is a good idea to use the covr package to track what proportion of your package’s source code is exercised by the tests. More details can be found in Chapter 13."
  },
  {
    "objectID": "whole-game.html#use_package",
    "href": "whole-game.html#use_package",
    "title": "1  The Whole Game",
    "section": "\n1.16 use_package()\n",
    "text": "1.16 use_package()\n\nYou will inevitably want to use a function from another package in your own package. We will need to use package-specific methods for declaring the other packages we need (i.e. our dependencies) and for using these packages in ours. If you plan to submit a package to CRAN, note that this even applies to functions in packages that you think of as “always available”, such as stats::median() or utils::head().\nOne common dilemma when using R’s regular expression functions is uncertainty about whether to request perl = TRUE or perl = FALSE. And then there are often, but not always, other arguments that alter how patterns are matched, such as fixed, ignore.case, and invert. It can be hard to keep track of which functions use which arguments and how the arguments interact, so many users never get to the point where they retain these details without rereading the docs.\nThe stringr package “provides a cohesive set of functions designed to make working with strings as easy as possible”. In particular, stringr uses one regular expression system everywhere (ICU regular expressions) and uses the same interface in every function for controlling matching behaviors, such as case sensitivity. Some people find this easier to internalize and program around. Let’s imagine you decide you’d rather build regexcite based on stringr (and stringi) than base R’s regular expression functions.\nFirst, declare your general intent to use some functions from the stringr namespace with use_package():\n\nuse_package(\"stringr\")\n#> ✔ Adding 'stringr' to Imports field in DESCRIPTION\n#> • Refer to functions with `stringr::fun()`\n\nThis adds the stringr package to the Imports field of DESCRIPTION. And that is all it does.\nLet’s revisit strsplit1() to make it more stringr-like. Here’s a new take on it1:\n\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\nNotice that we:\n\nRename the function to str_split_one(), to signal that that is a wrapper around stringr::str_split().\nAdopt the argument names from stringr::str_split(). Now we have string and pattern (and n), instead of x and split.\nIntroduce a bit of argument checking and edge case handling. This is unrelated to the switch to stringr and would be equally beneficial in the version built on strsplit().\nUse the package::function() form when calling stringr::str_split(). This specifies that we want to call the str_split() function from the stringr namespace. There is more than one way to call a function from another package and the one we endorse here is explained fully in Chapter 11.\n\nWhere should we write this new function definition? If we want to keep following the convention where we name the .R file after the function it defines, we now need to do some fiddly file shuffling. Because this comes up fairly often in real life, we have the rename_files() function, which choreographs the renaming of a file in R/ and its associated companion files below test/.\n\nrename_files(\"strsplit1\", \"str_split_one\")\n#> ✔ Moving 'R/strsplit1.R' to 'R/str_split_one.R'\n#> ✔ Moving 'tests/testthat/test-strsplit1.R' to 'tests/testthat/test-str_split_one.R'\n\nRemember: the file name work is purely aspirational. We still need to update the contents of these files!\nHere are the updated contents of R/str_split_one.R. In addition to changing the function definition, we’ve also updated the roxygen header to reflect the new arguments and to include examples that show off the stringr features.\n\n#' Split a string\n#'\n#' @param string A character vector with, at most, one element.\n#' @inheritParams stringr::str_split\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' str_split_one(x, pattern = \",\")\n#' str_split_one(x, pattern = \",\", n = 2)\n#'\n#' y <- \"192.168.0.1\"\n#' str_split_one(y, pattern = stringr::fixed(\".\"))\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\nDon’t forget to also update the test file!\nHere are the updated contents of tests/testthat/test-str_split_one.R. In addition to the change in the function’s name and arguments, we’ve added a couple more tests.\n\ntest_that(\"str_split_one() splits a string\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\"), c(\"a\", \"b\", \"c\"))\n})\n\ntest_that(\"str_split_one() errors if input length > 1\", {\n  expect_error(str_split_one(c(\"a,b\",\"c,d\"), \",\"))\n})\n\ntest_that(\"str_split_one() exposes features of stringr::str_split()\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\", n = 2), c(\"a\", \"b,c\"))\n  expect_equal(str_split_one(\"a.b\", stringr::fixed(\".\")), c(\"a\", \"b\"))\n})\n\nBefore we take the new str_split_one() out for a test drive, we need to call document(). Why? Remember that document() does two main jobs:\n\nConverts our roxygen comments into proper R documentation.\n(Re)generates NAMESPACE.\n\nThe second job is especially important here, since we will no longer export strsplit1() and we will newly export str_split_one(). Don’t be dismayed by the warning about \"Objects listed as exports, but not present in namespace: strsplit1\". That always happens when you remove something from the namespace.\n\ndocument()\n#> ℹ Updating regexcite documentation\n#> ℹ Loading regexcite\n#> Warning: Objects listed as exports, but not present in namespace:\n#> • strsplit1\n#> Writing 'NAMESPACE'\n#> Writing 'str_split_one.Rd'\n#> Deleting 'strsplit1.Rd'\n\nTry out the new str_split_one() function by simulating package installation via load_all():\n\nload_all()\n#> ℹ Loading regexcite\nstr_split_one(\"a, b, c\", pattern = \", \")\n#> [1] \"a\" \"b\" \"c\""
  },
  {
    "objectID": "whole-game.html#use_github",
    "href": "whole-game.html#use_github",
    "title": "1  The Whole Game",
    "section": "\n1.17 use_github()\n",
    "text": "1.17 use_github()\n\nYou’ve seen us making commits during the development process for regexcite. You can see an indicative history at https://github.com/jennybc/regexcite. Our use of version control and the decision to expose the development process means you can inspect the state of the regexcite source at each developmental stage. By looking at so-called diffs, you can see exactly how each devtools helper function modifies the source files that constitute the regexcite package.\nHow would you connect your local regexcite package and Git repository to a companion repository on GitHub? Here are three approaches:\n\n\nuse_github() is a helper that we recommend for the long-term. We won’t demonstrate it here because it requires some credential setup on your end. We also don’t want to tear down and rebuild the public regexcite package every time we build this book.\nSet up the GitHub repo first! It sounds counter-intuitive, but the easiest way to get your work onto GitHub is to initiate there, then use RStudio to start working in a synced local copy. This approach is described in Happy Git’s workflows New project, GitHub first and Existing project, GitHub first.\nCommand line Git can always be used to add a remote repository post hoc. This is described in the Happy Git workflow Existing project, GitHub last.\n\nAny of these approaches will connect your local regexcite project to a GitHub repo, public or private, which you can push to or pull from using the Git client built into RStudio. In Chapter 20, we elaborate on why version control (e.g., Git) and, specifically, hosted version control (e.g. GitHub) is worth incorporating into your package development process."
  },
  {
    "objectID": "whole-game.html#use_readme_rmd",
    "href": "whole-game.html#use_readme_rmd",
    "title": "1  The Whole Game",
    "section": "\n1.18 use_readme_rmd()\n",
    "text": "1.18 use_readme_rmd()\n\nNow that your package is on GitHub, the README.md file matters. It is the package’s home page and welcome mat, at least until you decide to give it a website (see Chapter 19), add a vignette (see Chapter 17), or submit it to CRAN (see Chapter 22).\nThe use_readme_rmd() function initializes a basic, executable README.Rmd ready for you to edit:\n\nuse_readme_rmd()\n#> ✔ Writing 'README.Rmd'\n#> ✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n#> • Update 'README.Rmd' to include installation instructions.\n#> ✔ Writing '.git/hooks/pre-commit'\n\nIn addition to creating README.Rmd, this adds some lines to .Rbuildignore, and creates a Git pre-commit hook to help you keep README.Rmd and README.md in sync.\nREADME.Rmd already has sections that prompt you to:\n\nDescribe the purpose of the package.\nProvide installation instructions. If a GitHub remote is detected when use_readme_rmd() is called, this section is pre-filled with instructions on how to install from GitHub.\nShow a bit of usage.\n\nHow to populate this skeleton? Copy stuff liberally from DESCRIPTION and any formal and informal tests or examples you have. Anything is better than nothing. This is helpful because people probably won’t install your package and comb through individual help files to figure out how to use it.\nWe like to write the README in R Markdown, so it can feature actual usage. The inclusion of live code also makes it less likely that your README grows stale and out-of-sync with your actual package.\nTo make your own edits, if RStudio has not already done so, open README.Rmd for editing. Make sure it shows some usage of str_split_one().\nThe README.Rmd we use is here: README.Rmd and here’s what it contains:\n\n---\noutput: github_document\n---\n\n<!-- README.md is generated from README.Rmd. Please edit that file -->\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n\n**NOTE: This is a toy package created for expository purposes, for the second edition of [R Packages](https://r-pkgs.org). It is not meant to actually be useful. If you want a package for factor handling, please see [stringr](https://stringr.tidyverse.org), [stringi](https://stringi.gagolewski.com/),\n[rex](https://cran.r-project.org/package=rex), and\n[rematch2](https://cran.r-project.org/package=rematch2).**\n\n# regexcite\n\n<!-- badges: start -->\n<!-- badges: end -->\n\nThe goal of regexcite is to make regular expressions more exciting!\nIt provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.\n\n## Installation\n\nYou can install the development version of regexcite from [GitHub](https://github.com/) with:\n      \n``` r\n# install.packages(\"devtools\")\ndevtools::install_github(\"jennybc/regexcite\")\n```\n\n## Usage\n\nA fairly common task when dealing with strings is the need to split a single string into many parts.\nThis is what `base::strplit()` and `stringr::str_split()` do.\n\n```{r}\n(x <- \"alfa,bravo,charlie,delta\")\nstrsplit(x, split = \",\")\nstringr::str_split(x, pattern = \",\")\n```\n\nNotice how the return value is a **list** of length one, where the first element holds the character vector of parts.\nOften the shape of this output is inconvenient, i.e. we want the un-listed version.\n\nThat's exactly what `regexcite::str_split_one()` does.\n\n```{r}\nlibrary(regexcite)\n\nstr_split_one(x, pattern = \",\")\n```\n\nUse `str_split_one()` when the input is known to be a single string.\nFor safety, it will error if its input has length greater than one.\n\n`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.\n\n```{r}\nstr_split_one(x, pattern = \",\", n = 2)\n\ny <- \"192.168.0.1\"\nstr_split_one(y, pattern = stringr::fixed(\".\"))\n```\n\nDon’t forget to render it to make README.md! The pre-commit hook should remind you if you try to commit README.Rmd, but not README.md, and also when README.md appears to be out-of-date.\nThe very best way to render README.Rmd is with build_readme(), because it takes care to render with the most current version of your package, i.e. it installs a temporary copy from the current source.\n\nbuild_readme()\n#> ℹ Installing regexcite in temporary library\n#> ℹ Building\n#>   'C:/Users/13081/AppData/Local/Temp/Rtmp2BQsY2/regexcite/README.Rmd'\n\nYou can see the rendered README.md simply by visiting regexcite on GitHub.\nFinally, don’t forget to do one last commit. And push, if you’re using GitHub."
  },
  {
    "objectID": "whole-game.html#the-end-check-and-install",
    "href": "whole-game.html#the-end-check-and-install",
    "title": "1  The Whole Game",
    "section": "\n1.19 The end: check() and install()\n",
    "text": "1.19 The end: check() and install()\n\nLet’s run check() again to make sure all is still well.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 34.4s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nregexcite should have no errors, warnings or notes. This would be a good time to re-build and install it properly. And celebrate!\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/1.study/R/R-4.2.0/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\13081\\AppData\\Local\\Temp\\Rtmp2BQsY2/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/1.study/R/R-4.2.0/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** tests\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\nFeel free to visit the regexcite package on GitHub, which appears exactly as developed here. The commit history reflects each individual step, so use the diffs to see the addition and modification of files, as the package evolved. The rest of this book goes in greater detail for each step you’ve seen here and much more."
  },
  {
    "objectID": "whole-game.html#review",
    "href": "whole-game.html#review",
    "title": "1  The Whole Game",
    "section": "\n1.20 Review",
    "text": "1.20 Review\nThis chapter is meant to give you a sense of the typical package development workflow, summarized as a diagram in Figure 1.1. Everything you see here has been touched on in this chapter, with the exception of GitHub Actions, which you will learn more about in Section 20.2.1.\n\n\n\n\nFigure 1.1: The devtools package development workflow.\n\n\n\n\nHere is a review of the key functions you’ve seen in this chapter, organized roughly by their role in the development process.\nThese functions setup parts of the package and are typically called once per package:\n\ncreate_package()\nuse_git()\nuse_mit_license()\nuse_testthat()\nuse_github()\nuse_readme_rmd()\n\nYou will call these functions on a regular basis, as you add functions and tests or take on dependencies:\n\nuse_r()\nuse_test()\nuse_package()\n\nYou will call these functions multiple times per day or per hour, during development:\n\nload_all()\ndocument()\ntest()\ncheck()"
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nSince the first edition of R Packages was published, the packages supporting the workflows described here have undergone extensive development. The original trio of devtools, roxygen2, and testthat has expanded to include the packages created by the “conscious uncoupling” of devtools, as described in Section 2.2. Most of these packages originate with Hadley Wickham (HW), because of their devtools roots. There are many other significant contributors, many of whom now serve as maintainers:\n\ndevtools: HW, Winston Chang, Jim Hester (maintainer, >= v1.13.5), Jennifer Bryan (maintainer >= v2.4.3)\nusethis: HW, Jennifer Bryan (maintainer >= v1.5.0), Malcolm Barrett\nroxygen2: HW (maintainer), Peter Danenburg, Manuel Eugster\n\ntestthat: HW (maintainer)\ndesc: Gábor Csárdi (maintainer), Kirill Müller, Jim Hester\n\npkgbuild: HW, Jim Hester, Gábor Csárdi (maintainer >= v1.2.1)\npkgload: HW, Jim Hester, Winston Chang, Lionel Henry (maintainer >= v1.2.4)\nrcmdcheck: Gábor Csárdi (maintainer)\nremotes: HW, Jim Hester, Gábor Csárdi (maintainer), Winston Chang, Martin Morgan, Dan Tenenbaum\n\nrevdepcheck: HW, Gábor Csárdi (maintainer)\nsessioninfo: HW, Gábor Csárdi (maintainer), Winston Chang, Robert Flight, Kirill Müller, Jim Hester\n\n\nThis book was written and revised in the open and it is truly a community effort: many people read drafts, fix typos, suggest improvements, and contribute content. Without those contributors, the book wouldn’t be nearly as good as it is, and we are deeply grateful for their help. We are indebted to our colleagues at Posit, especially the tidyverse team, for being perpetually game to discuss package development practices. The book has been greatly improved by the suggestions from our fantastic team of technical reviewers: Malcolm Barrett, Laura DeCicco, Zhian Kamvar, Tom Mock and Maëlle Salmon.\n#> Warning: package 'tidyverse' was built under R version 4.2.3\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n#> Warning: package 'tibble' was built under R version 4.2.3\n#> Warning: package 'tidyr' was built under R version 4.2.3\n#> Warning: package 'readr' was built under R version 4.2.3\n#> Warning: package 'purrr' was built under R version 4.2.3\n#> Warning: package 'dplyr' was built under R version 4.2.3\n#> Warning: package 'stringr' was built under R version 4.2.2\n#> Warning: package 'forcats' was built under R version 4.2.3\n#> Warning: package 'lubridate' was built under R version 4.2.3\n#> ── Attaching core tidyverse packages ──────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n#> Rows: 410 Columns: 3\n#> ── Column specification ────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr (3): user, name, maybe_name\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nThanks to all contributors the the first and second editions (in alphabetical order by GitHub username):\n@aaelony, @aaronwolen (Aaron Wolen), @ablejec (Andrej Blejec), @adamcduncan (Adam Duncan), @adessy, @adrtod (Adrien Todeschini), @aghaynes (Alan Haynes), @agrueneberg (Alexander Grueneberg), @alejandrohagan (Alejandro Hagan), @alesantuz (Ale Santuz), @alexandrehsd (Alexandre Henrique), @alexholcombe (Alex O. Holcombe), @alexpghayes (alex hayes), @alforj (Justin Alford), @almartin82 (Andrew Martin), @aluxh (Alex Ho), @AmelZulji, @andreaphsz (Andrea Cantieni), @andrewdolman (Andrew Dolman), @andrewpbray (Andrew Bray), @AndrewsOR (John Andrews), @andycraig (Andrew Craig), @angela-li (Angela Li), @anjalisilva (Anjali Silva), @apomatix (Brad Friedman), @apreshill (Alison Presmanes Hill), @arashHaratian (Arash), @arilamstein (Ari Lamstein), @arneschillert (Arne Schillert), @arni-magnusson (Arni Magnusson), @asadow (Adam Sadowski), @ateucher (Andy Teucher), @avisser (Andy Visser), @ayormark (Adam Yormark), @azzaea (Azza Ahmed), @batpigandme (Mara Averick), @bclipp (Brian L), @beevabeeva, @behrman (Bill Behrman), @benmarwick (Ben Marwick), @BernhardKonrad (Bernhard Konrad), @bgreenwell (Brandon Greenwell), @Bisaloo (Hugo Gruson), @bklamer (Brett Klamer), @bm5tev3, @bms63 (Ben Straub), @bpbond (Ben Bond-Lamberty), @bquast (Bastiaan Quast), @Br-Johnson (Brett Johnson), @brews (Brewster Malevich), @brianrice2 (Brian Rice), @brry (Berry Boessenkool), @btruel, @calligross (Calli), @carldotac (Carl Lieberman), @carloscinelli (Carlos Cinelli), @CDCookJr, @cderv (Christophe Dervieux), @chambm (Matt Chambers), @charliejhadley (Charlie Joey Hadley), @chezou (Aki Ariga), @chsafouane (Safouane Chergui), @clente (Caio Lente), @cmarmstrong, @cooknl (CAPN), @CorradoLanera (Corrado Lanera), @craigcitro (Craig Citro), @crtahlin (Crt Ahlin), @daattali (Dean Attali), @danhalligan (Dan Halligan), @daroczig (Gergely Daróczi), @datarttu (Arttu Kosonen), @davidkane9 (David Kane), @DavisVaughan (Davis Vaughan), @deanbodenham, @dfalbel (Daniel Falbel), @dgrtwo (David Robinson), @dholstius (David Holstius), @DickStartz, @dkgaraujo (Douglas K. G. Araujo), @dlukes (David Lukes), @DOH-PXC5303 (Philip Crain), @dongzhuoer (Zhuoer Dong), @DougManuel (Doug Manuel), @dpprdan (Daniel Possenriede), @dracodoc (dracodoc), @drag05 (Dragos Bandur), @drvinceknight (Vince Knight), @dryzliang, @dyavorsky (Dan Yavorsky), @e-pet, @earino (E. Ariño de la Rubia), @echelleburns, @eeholmes (Eli Holmes), @eipi10 (Joel Schwartz), @ekbrown (Earl Brown), @EllaKaye (Ella Kaye), @EmilHvitfeldt (Emil Hvitfeldt), @eogoodwin, @erictleung (Eric Leung), @erikerhardt (Erik Erhardt), @espinielli (Enrico Spinielli), @ewan (Ewan Dunbar), @fbertran (Frederic Bertrand), @federicomarini (Federico Marini), @fenguoerbian (Chao Cheng), @fkohrt (Florian Kohrt), @florisvdh (Floris Vanderhaeghe), @floswald (Florian Oswald), @franrodalg (Francisco Rodríguez-Algarra), @franticspider (Simon Hickinbotham), @frycast (Daniel Vidali Fryer), @fsavje (Fredrik Sävje), @gajusmiknaitis, @gcpoole (Geoffrey Poole), @geanders (Brooke Anderson), @georoen (Jee Roen), @GerardTromp (Gerard Tromp), @GillesSanMartin (Gilles San Martin), @gmaubach (Georg Maubach), @gonzalezgouveia (Rafael Gonzalez Gouveia), @gregmacfarlane (Greg Macfarlane), @gregrs-uk (Greg), @grst (Gregor Sturm), @gsrohde (Scott Rohde), @guru809, @gustavdelius (Gustav W Delius), @haibin (Liu Haibin), @hanneoberman (Hanne Oberman), @harrismcgehee (Harris McGehee), @havenl (Haven Liu), @hcyvan (程一航), @hdraisma (Harmen), @hedderik (Hedderik van Rijn), @heists ((ꐦ°᷄д°)ა), @helske (Jouni Helske), @henningte (Henning Teickner), @HenrikBengtsson (Henrik Bengtsson), @heogden (Helen Ogden), @hfrick (Hannah Frick), @Holzhauer (Sascha Holzhauer), @howardbaek (Howard Baek), @howbuildingsfail (How Buildings Fail), @hq9000 (Sergey Grechin), @hrbrmstr (boB Rudis), @iangow (Ian Gow), @iargent, @idmn (Iaroslav Domin), @ijlyttle (Ian Lyttle), @imchoyoung (Choyoung Im), @InfiniteCuriosity (Russ Conte), @ionut-stefanb (Ionut Stefan-Birdea), @Ironholds (Os Keyes), @ismayc (Chester Ismay), @isomorphisms (i), @jackwasey (Jack Wasey), @jacobbien (Jacob Bien), @jadeynryan (Jadey Ryan), @jameelalsalam (Jameel Alsalam), @jameslairdsmith (James Laird-Smith), @janzzon (Stefan Jansson), @JayCeBB, @jcainey (Joe Cainey), @jdblischak (John Blischak), @jedwards24 (James Edwards), @jemus42 (Lukas Burk), @jenniferthompson (Jennifer Thompson), @jeremycg (Jeremy Gray), @jgarthur (Joey Arthur), @jimhester (Jim Hester), @jimr1603 (James Riley), @jjesusfilho (José de Jesus Filho), @jkeirstead (James Keirstead), @jmarca (James Marca), @jmarshallnz (Jonathan Marshall), @joethorley (Joe Thorley), @johnbaums (John), @jolars (Johan Larsson), @jonthegeek (Jon Harmon), @jowalski (John Kowalski), @jpinelo (Joao Pinelo Silva), @jrdnbradford (Jordan), @jthomasmock (Tom Mock), @julian-urbano (Julián Urbano), @jwpestrak, @jzadra (Jonathan Zadra), @jzhaoo (Joanna Zhao), @kaetschap (Sonja), @karthik (Karthik Ram), @KasperThystrup (Kasper Thystrup Karstensen), @KatherineCox, @katrinleinweber (Katrin Leinweber), @kbroman (Karl Broman), @kekecib (Ibrahim Kekec), @KellenBrosnahan, @kendonB (Kendon Bell), @kevinushey (Kevin Ushey), @kikapp (Kristopher Kapphahn), @KirkDSL, @KJByron (Karen J. Byron), @klmr (Konrad Rudolph), @KoderKow (Kyle Harris), @kokbent (Ben Toh), @kongdd (Dongdong Kong), @krlmlr (Kirill Müller), @kwenzig (Knut Wenzig), @kwstat (Kevin Wright), @kylelundstedt (Kyle G. Lundstedt), @lancelote (Pavel Karateev), @lbergelson (Louis Bergelson), @LechMadeyski (Lech Madeyski), @Lenostatos (Leon), @lindbrook, @lionel- (Lionel Henry), @LluisRamon (Lluís Ramon), @lorenzwalthert (Lorenz Walthert), @lwjohnst86 (Luke W Johnston), @maelle (Maëlle Salmon), @maiermarco, @maislind (David M), @majr-red (Matthew Roberts), @malcolmbarrett (Malcolm Barrett), @malexan (Alexander Matrunich), @manuelreif (Manuel Reif), @MarceloRTonon (Marcelo Tonon), @mariacuellar (Maria Cuellar), @markdly (Mark Dulhunty), @Marlin-Na (Marlin), @martin-mfg, @matanhakim (Matan Hakim), @matdoering, @matinang (Matina Angelopoulou), @mattflor (Matthias Flor), @maurolepore (Mauro Lepore), @maxheld83 (Max Held), @mayankvanani (Mayank Vanani), @mbjones (Matt Jones), @mccarthy-m-g (Michael McCarthy), @mdequeljoe (Matthew de Queljoe), @mdsumner (Michael Sumner), @michaelboerman (Michael Boerman), @MichaelChirico (Michael Chirico), @michaelmikebuckley (Michael Buckley), @michaelweylandt (Michael Weylandt), @miguelmorin, @MikeJohnPage, @mikelnrd (Michael Leonard), @mikelove (Mike Love), @mikemc (Michael McLaren), @MilesMcBain (Miles McBain), @mjkanji (Muhammad Jarir Kanji), @mkuehn10 (Michael Kuehn), @mllg (Michel Lang), @mohamed-180 (Mohamed El-Desokey), @moodymudskipper (Antoine Fabri), @Moohan (James McMahon), @MrAE (Jesse Leigh Patsolic), @mrcaseb, @ms609 (Martin R. Smith), @mskyttner (Markus Skyttner), @MWilson92 (Matthew Wilson), @myoung3, @nachti (Gerhard Nachtmann), @nanxstats (Nan Xiao), @nareal (Nelson Areal), @nattalides, @ncarchedi (Nick Carchedi), @ndphillips (Nathaniel Phillips), @nick-youngblut (Nick Youngblut), @njtierney (Nicholas Tierney), @nsheff (Nathan Sheffield), @osorensen (Øystein Sørensen), @PabRod (Pablo Rodríguez-Sánchez), @paternogbc (Gustavo Brant Paterno), @paulrougieux (Paul Rougieux), @pdwaggoner (Philip Waggoner), @pearsonca (Carl A. B. Pearson), @perryjer1 (Jeremiah), @petermeissner (Peter Meissner), @petersonR (Ryan Peterson), @petzi53 (Peter Baumgartner), @PhilipPallmann (Philip Pallmann), @philliplab (Phillip Labuschagne), @phonixor (Gerrit-Jan Schutten), @pkimes (Patrick Kimes), @pnovoa (Pavel Novoa), @ppanko (Pavel Panko), @pritesh-shrivastava (Pritesh Shrivastava), @PrzeChoj (PrzeChoj), @PursuitOfDataScience (Y. Yu), @pwaeckerle, @raerickson (Richard Erickson), @ramiromagno (Ramiro Magno), @ras44, @rbirkelbach (Robert Birkelbach), @rcorty (Robert W. Corty), @rdiaz02 (Ramon Diaz-Uriarte), @realAkhmed (Akhmed Umyarov), @reikookamoto (Reiko Okamoto), @renkun-ken (Kun Ren), @retowyss (Reto Wyss), @revodavid (David Smith), @rgknight (Ryan Knight), @rhgof (Richard), @rmar073, @rmflight (Robert M Flight), @rmsharp (R. Mark Sharp), @rnuske (Robert Nuske), @robertzk (Robert Krzyzanowski), @Robinlovelace (Robin Lovelace), @robiRagan (Robi Ragan), @Robsteranium (Robin Gower), @romanzenka (Roman Zenka), @royfrancis (Roy Francis), @rpruim (Randall Pruim), @rrunner, @rsangole (Rahul), @ryanatanner (Ryan), @salim-b (Salim B), @SamEdwardes (Sam Edwardes), @SangdonLim (Sangdon Lim), @sathishsrinivasank (Sathish), @sbgraves237, @schifferl (Lucas Schiffer), @scw (Shaun Walbridge), @sdarodrigues (Sabrina Rodrigues), @sebffischer (Sebastian Fischer), @serghiou (Stylianos Serghiou), @setoyama60jp, @sfirke (Sam Firke), @shannonpileggi (Shannon Pileggi), @Shelmith-Kariuki (Shel), @SheridanLGrant (Sheridan Grant), @shntnu (Shantanu Singh), @sibusiso16 (S’busiso Mkhondwane), @simdadim (Simen Buodd), @SimonPBiggs (SPB), @simonthelwall (Simon Thelwall), @SimonYansenZhao (Simon He Zhao), @singmann (Henrik Singmann), @Skenvy (Nathan Levett), @Smudgerville (Richard M. Smith), @sn248 (Satyaprakash Nayak), @sowla (Praer (Suthira) Owlarn), @srushe (Stephen Rushe), @statnmap (Sébastien Rochette), @steenharsted (Steen Harsted), @stefaneng (Stefan Eng), @stefanherzog (Stefan Herzog), @stephen-frank (Stephen Frank), @stephenll (Stephen Lienhard), @stephenturner (Stephen Turner), @stevenprimeaux (Steven Primeaux), @stevensbr, @stewid (Stefan Widgren), @sunbeomk (Sunbeom Kwon), @superdesolator (Po Su), @syclik (Daniel Lee), @symbolrush (Adrian Stämpfli-Schmid), @taekyunk (Taekyun Kim), @talgalili (Tal Galili), @tanho63 (Tan Ho), @tbrugz (Telmo Brugnara), @thisisnic (Nic Crane), @TimHesterberg (Tim Hesterberg), @titaniumtroop (Nathan), @tjebo, @tklebel (Thomas Klebel), @tmstauss (Tanner Stauss), @tonybreyal (Tony Breyal), @tonyfischetti (Tony Fischetti), @TonyLadson (Tony Ladson), @trickytank (Rick Tankard), @TroyVan, @uribo (Shinya Uryu), @urmils, @valeonte, @vgonzenbach (Virgilio Gonzenbach), @vladpetyuk (Vlad Petyuk), @vnijs (Vincent Nijs), @vspinu (Vitalie Spinu), @wcarlsen (Willi Carlsen), @wch (Winston Chang), @wenjie2wang (Wenjie Wang), @werkstattcodes, @wiaidp, @wibeasley (Will Beasley), @wilkinson (Sean Wilkinson), @williamlief (Lief Esbenshade), @winterschlaefer (Christof Winter), @wlamnz (William Lam), @wrathematics (Drew Schmidt), @XiangyunHuang (Xiangyun Huang), @xiaochi-liu (Xiaochi), @XiaoqiLu (Xiaoqi Lu), @xiaosongz (Xiaosong Zhang), @yihui (Yihui Xie), @ynsec37, @yonicd, @ysdgroot, @yui-knk (Yuichiro Kaneko), @Zedseayou (Calum You), @zeehio (Sergio Oller), @zekiakyol (Zeki Akyol), @zenggyu (Guangyu Zeng), @zhaoy, @zhilongjia (Zhilong), @zhixunwang, @zkamvar (Zhian N. Kamvar), @zouter (Wouter Saelens)."
  },
  {
    "objectID": "preface.html#conventions",
    "href": "preface.html#conventions",
    "title": "Preface",
    "section": "Conventions",
    "text": "Conventions\nThroughout this book, we write fun() to refer to functions, var to refer to variables and function arguments, and path/ for paths.\nLarger code blocks intermingle input and output. Output is commented so that if you have an electronic version of the book, e.g., https://r-pkgs.org, you can easily copy and paste examples into R. Output comments look like #> to distinguish them from regular comments."
  },
  {
    "objectID": "preface.html#colophon",
    "href": "preface.html#colophon",
    "title": "Preface",
    "section": "Colophon",
    "text": "Colophon\nThis book was authored using Quarto inside RStudio. The website is hosted with Netlify, and automatically updated after every commit by GitHub actions. The complete source is available from GitHub.\nThis version of the book was built with:\n\nlibrary(devtools)\n#> Warning: package 'devtools' was built under R version 4.2.3\n#> Loading required package: usethis\n#> Warning: package 'usethis' was built under R version 4.2.3\nlibrary(roxygen2)\n#> Warning: package 'roxygen2' was built under R version 4.2.3\nlibrary(testthat)\n#> Warning: package 'testthat' was built under R version 4.2.3\n#> \n#> Attaching package: 'testthat'\n#> The following object is masked from 'package:devtools':\n#> \n#>     test_file\n#> The following object is masked from 'package:dplyr':\n#> \n#>     matches\n#> The following object is masked from 'package:purrr':\n#> \n#>     is_null\n#> The following objects are masked from 'package:readr':\n#> \n#>     edition_get, local_edition\n#> The following object is masked from 'package:tidyr':\n#> \n#>     matches\ndevtools::session_info()\n#> ─ Session info ───────────────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.2.0 (2022-04-22 ucrt)\n#>  os       Windows 10 x64 (build 22621)\n#>  system   x86_64, mingw32\n#>  ui       RTerm\n#>  language (EN)\n#>  collate  Chinese (Simplified)_China.utf8\n#>  ctype    Chinese (Simplified)_China.utf8\n#>  tz       Asia/Taipei\n#>  date     2023-06-19\n#>  pandoc   2.19.2 @ D:/1.study/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  bit           4.0.5   2022-11-15 [1] CRAN (R 4.2.3)\n#>  bit64         4.0.5   2020-08-30 [1] CRAN (R 4.2.1)\n#>  brio          1.1.3   2021-11-30 [1] CRAN (R 4.2.0)\n#>  cachem        1.0.8   2023-05-01 [1] CRAN (R 4.2.3)\n#>  callr         3.7.3   2022-11-02 [1] CRAN (R 4.2.2)\n#>  cli           3.6.1   2023-03-23 [1] CRAN (R 4.2.3)\n#>  colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.2.3)\n#>  crayon        1.5.2   2022-09-29 [1] CRAN (R 4.2.1)\n#>  devtools    * 2.4.5   2022-10-11 [1] CRAN (R 4.2.3)\n#>  digest        0.6.29  2021-12-01 [1] CRAN (R 4.2.0)\n#>  dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.2.3)\n#>  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.2.0)\n#>  evaluate      0.21    2023-05-05 [1] CRAN (R 4.2.3)\n#>  fansi         1.0.4   2023-01-22 [1] CRAN (R 4.2.3)\n#>  fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.2.3)\n#>  forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.2.3)\n#>  fs            1.6.2   2023-04-25 [1] CRAN (R 4.2.3)\n#>  generics      0.1.3   2022-07-05 [1] CRAN (R 4.2.0)\n#>  ggplot2     * 3.4.2   2023-04-03 [1] CRAN (R 4.2.3)\n#>  glue          1.6.2   2022-02-24 [1] CRAN (R 4.2.0)\n#>  gtable        0.3.3   2023-03-21 [1] CRAN (R 4.2.3)\n#>  hms           1.1.3   2023-03-21 [1] CRAN (R 4.2.3)\n#>  htmltools     0.5.4   2022-12-07 [1] CRAN (R 4.2.2)\n#>  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.2.3)\n#>  httpuv        1.6.11  2023-05-11 [1] CRAN (R 4.2.3)\n#>  jsonlite      1.8.5   2023-06-05 [1] CRAN (R 4.2.3)\n#>  knitr         1.43    2023-05-25 [1] CRAN (R 4.2.3)\n#>  later         1.3.1   2023-05-02 [1] CRAN (R 4.2.3)\n#>  lifecycle     1.0.3   2022-10-07 [1] CRAN (R 4.2.1)\n#>  lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.2.3)\n#>  magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n#>  memoise       2.0.1   2021-11-26 [1] CRAN (R 4.2.0)\n#>  mime          0.12    2021-09-28 [1] CRAN (R 4.2.0)\n#>  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.2.0)\n#>  munsell       0.5.0   2018-06-12 [1] CRAN (R 4.2.2)\n#>  pillar        1.9.0   2023-03-22 [1] CRAN (R 4.2.3)\n#>  pkgbuild      1.4.0   2022-11-27 [1] CRAN (R 4.2.2)\n#>  pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.2.0)\n#>  pkgload       1.3.2   2022-11-16 [1] CRAN (R 4.2.2)\n#>  prettyunits   1.1.1   2020-01-24 [1] CRAN (R 4.2.0)\n#>  processx      3.8.1   2023-04-18 [1] CRAN (R 4.2.3)\n#>  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.2.3)\n#>  promises      1.2.0.1 2021-02-11 [1] CRAN (R 4.2.0)\n#>  ps            1.7.5   2023-04-18 [1] CRAN (R 4.2.3)\n#>  purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.2.3)\n#>  R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.0)\n#>  Rcpp          1.0.10  2023-01-22 [1] CRAN (R 4.2.3)\n#>  readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.2.3)\n#>  remotes       2.4.2   2021-11-30 [1] CRAN (R 4.2.0)\n#>  rlang         1.1.1   2023-04-28 [1] CRAN (R 4.2.3)\n#>  rmarkdown     2.22    2023-06-01 [1] CRAN (R 4.2.3)\n#>  roxygen2    * 7.2.3   2022-12-08 [1] CRAN (R 4.2.3)\n#>  rstudioapi    0.14    2022-08-22 [1] CRAN (R 4.2.1)\n#>  scales        1.2.1   2022-08-20 [1] CRAN (R 4.2.1)\n#>  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n#>  shiny         1.7.4   2022-12-15 [1] CRAN (R 4.2.2)\n#>  stringi       1.7.12  2023-01-11 [1] CRAN (R 4.2.2)\n#>  stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.2.2)\n#>  testthat    * 3.1.8   2023-05-04 [1] CRAN (R 4.2.3)\n#>  tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.2.3)\n#>  tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.2.3)\n#>  tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.2.1)\n#>  tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.2.3)\n#>  timechange    0.2.0   2023-01-11 [1] CRAN (R 4.2.3)\n#>  tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.2.3)\n#>  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.2.1)\n#>  usethis     * 2.2.0   2023-06-06 [1] CRAN (R 4.2.3)\n#>  utf8          1.2.3   2023-01-31 [1] CRAN (R 4.2.3)\n#>  vctrs         0.6.2   2023-04-19 [1] CRAN (R 4.2.3)\n#>  vroom         1.6.3   2023-04-28 [1] CRAN (R 4.2.3)\n#>  withr         2.5.0   2022-03-03 [1] CRAN (R 4.2.0)\n#>  xfun          0.39    2023-04-20 [1] CRAN (R 4.2.3)\n#>  xml2          1.3.4   2023-04-27 [1] CRAN (R 4.2.3)\n#>  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.2.0)\n#> \n#>  [1] D:/1.study/R/R-4.2.0/library\n#> \n#> ──────────────────────────────────────────────────────────────────\n\n\n\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive Pretty Printing of R Code. http://styler.r-lib.org."
  },
  {
    "objectID": "introduction.html#sec-intro-phil",
    "href": "introduction.html#sec-intro-phil",
    "title": "Introduction",
    "section": "Philosophy",
    "text": "Philosophy\nThis book espouses our philosophy of package development: anything that can be automated, should be automated. Do as little as possible by hand. Do as much as possible with functions. The goal is to spend your time thinking about what you want your package to do rather than thinking about the minutiae of package structure.\nThis philosophy is realized primarily through the devtools package, which is the public face for a suite of R functions that automate common development tasks. The release of version 2.0.0 in October 2018 marked its internal restructuring into a set of more focused packages, with devtools becoming more of a meta-package. The usethis package is the sub-package you are most likely to interact with directly; we explain the devtools-usethis relationship in Section 2.2.\nAs always, the goal of devtools is to make package development as painless as possible. It encapsulates the best practices developed by Hadley Wickham, initially from his years as a prolific solo developer. More recently, he has assembled a team of developers at Posit (formerly known as RStudio), who collectively look after hundreds of open source R packages, including those known as the tidyverse. The reach of this team allows us to explore the space of all possible mistakes at an extraordinary scale. Fortunately, it also affords us the opportunity to reflect on both the successes and failures, in the company of expert and sympathetic colleagues. We try to develop practices that make life more enjoyable for both the maintainer and users of a package. The devtools meta-package is where these lessons are made concrete.\ndevtools works hand-in-hand with RStudio, which we believe is the best development environment for most R users. The most popular alternative to RStudio is currently Visual Studio Code (VS Code) with the R extension enabled. This can be a rewarding and powerful environment, however it does require a bit more work to set up and customize1.\n\n\n\n\n\n\nRStudio\n\n\n\nThroughout the book, we highlight specific ways that RStudio can expedite your package development workflow, in specially formatted sections like this.\n\n\nTogether, devtools and RStudio insulate you from the low-level details of how packages are built. As you start to develop more packages, we highly recommend that you learn more about those details. The best resource for the official details of package development is always the official writing R extensions manual2. However, this manual can be hard to understand if you’re not already familiar with the basics of packages. It’s also exhaustive, covering every possible package component, rather than focusing on the most common and useful components, as this book does. Writing R extensions is a useful resource once you’ve mastered the basics and want to learn what’s going on under the hood."
  },
  {
    "objectID": "introduction.html#intro-outline",
    "href": "introduction.html#intro-outline",
    "title": "Introduction",
    "section": "In this book",
    "text": "In this book\nThe first part of the book is all about giving you all the tools you need to start your package development journey and we highly recommend that you read it in order. We begin in Chapter 1 with a run through the complete development of a small package. It’s meant to paint the big picture and suggest a workflow, before we descend into the detailed treatment of the key components of an R package. Then in Chapter 2 you’ll learn how to prepare your system for package development, and in Chapter 3 you’ll learn the basic structure of a package and how that varies across different states. Next, in Chapter 4, we’ll cover the core workflows that come up repeatedly for package developers. The first part of the book ends with another case study (Chapter 5), this time focusing on how you might convert a script to a package and discussing the challenges you’ll face along the way.\nThe remainder of the book is designed to be read as needed. Pick and choose between the chapters as the various topics come up in your development process.\nFirst we cover key package components: Chapter 6 discusses where your code lives and how to organize it, Chapter 7 shows you how to include data in your package, and Chapter 8 covers a few less important files and directories that need to be discussed somewhere.\nNext we’ll dive into to the package metadata, starting with DESCRIPTION in Chapter 9. We’ll then go deep into dependencies. In Chapter 10, we’ll cover the costs and benefits of taking on dependencies and provide some technical background on package namespaces and the search path. In Chapter 11, we focus on practical matters, such as how to use different types of dependencies in different parts of your package. This is also where we discuss exporting functions, which is what makes it possible for other packages and projects to depend on your package. We’ll finish off this part with a look at licensing in Chapter 12.\nTo ensure your package works as designed (and continues to work as you make changes), it’s essential to test your code, so the next three chapters cover the art and science of testing. Chapter 13 gets you started with the basics of testing with the testthat package. Chapter 14 teaches you how to design and organise tests in the most effective way. Then we finish off our coverage of testing in Chapter 15 which teaches you advanced skills to tackle challenging situations.\nIf you want other people (including future-you!) to understand how to use the functions in your package, you’ll need to document them. Chapter 16 gets you started using roxygen2 to document the functions in your package. Function documentation is only helpful if you know what function to look up, so next in Chapter 17 we’ll discuss vignettes, which help you document the package as a whole. We’ll finish up documentation with a discussion of other important markdown files like README.md and NEWS.md in Chapter 18, and creating a package website with pkgdown in Chapter 19.\nThe book concludes by zooming back out to consider development practices, such as the benefit of using version control and continuous integration (Chapter 20). We wrap things up by discussing the lifecycle (Chapter 21) of a package, including releasing it on CRAN (Chapter 22).\nThis is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features (e.g. just an R/ directory!) and build up over time. To paraphrase the Zen monk Shunryu Suzuki: “Each package is perfect the way it is — and it can use a little improvement”."
  },
  {
    "objectID": "introduction.html#whats-not-here",
    "href": "introduction.html#whats-not-here",
    "title": "Introduction",
    "section": "What’s not here",
    "text": "What’s not here\nThere are also specific practices that have little to no treatment here simply because we do not use them enough to have any special insight. Does this mean that we actively discourage those practices? Probably not, as we try to be explicit about practices we think you should avoid. So if something is not covered here, it just means that a couple hundred heavily-used R packages are built without meaningful reliance on that technique. That observation should motivate you to evaluate how likely it is that your development requirements truly don’t overlap with ours. But sometimes the answer is a clear “yes”, in which case you’ll simply need to consult another resource.\n\n\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2."
  }
]