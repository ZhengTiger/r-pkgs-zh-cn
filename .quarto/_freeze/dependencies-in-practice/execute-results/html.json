{
  "hash": "c0038b9bb541cd753d22c06ce33391ab",
  "result": {
    "markdown": "# Dependencies: In Practice {#sec-dependencies-in-practice}\n\n\n::: {.cell}\n\n:::\n\n\nThis chapter presents the practical details of working with your dependencies inside your package.\nIf you need a refresher on any of the background:\n\n-   @sec-description covers the DESCRIPTION file.\n    Listing a dependency in that file, such as in `Imports`, is a necessary first step when taking a dependency.\n\n-   @sec-dependencies-pros-cons provides a decision-making framework for dependencies.\n\n-   The technical details of package namespaces, the search path, and attaching vs. loading are laid out in @sec-dependencies-namespace, @sec-dependencies-search, and @sec-dependencies-attach-vs-load.\n\nWe're finally ready to talk about how to use different types of dependencies within the different parts of your package:\n\n-   in your functions, below `R/`\n-   in your tests, below `tests/testthat/`\n-   in your examples, in the help topics, below `man/`\n-   in your vignettes and articles, below `vignettes/`\n\n## Confusion about `Imports`\n\nLet's make this crystal clear:\n\n> Listing a package in `Imports` in `DESCRIPTION` does not \"import\" that package.\n\nIt is natural to assume that listing a package in `Imports` actually \"imports\" the package, but this is just an unfortunate choice of name for the `Imports` field.\nThe `Imports` field makes sure that the packages listed there are installed when your package is installed.\nIt does not make those functions available to you, e.g. below `R/`, or to your user.\n\nIt is neither automatic nor necessarily advisable that a package listed in `Imports` also appears in `NAMESPACE` via `imports()` or `importFrom()`.\nIt is common for a package to be listed in `Imports` in `DESCRIPTION`, but not in `NAMESPACE`.\nThe converse is not true.\nEvery package mentioned in `NAMESPACE` must also be present in the `Imports` or `Depends` fields.\n\n## Conventions for this chapter\n\nSometimes our examples can feature real functions from real packages.\nBut if we need to talk about a generic package or function, here are the conventions we use below:\n\n-   pkg: the name of your hypothetical package\n\n-   aaapkg or bbbpkg: the name of a hypothetical package your package depends on\n\n-   `aaa_fun()`: the name of a function exported by aaapkg\n\n## `NAMESPACE` Workflow {#sec-dependencies-NAMESPACE-workflow}\n\nIn the sections below, we give practical instructions on how (and when) to import functions from another package into yours and how to export functions from your package.\nThe file that keeps track of all this is the `NAMESPACE` file (more details in @sec-dependencies-NAMESPACE-file).\n\nIn the devtools workflow and this book, we generate the `NAMESPACE` file from special comments in the `R/*.R` files.\nSince the package that ultimately does this work is roxygen2, these are called \"roxygen comments\".\nThese roxygen comments are also the basis for your package's help topics, which is covered in @sec-man-workflow.\n\nThe `NAMESPACE` file starts out with a single commented-out line explaining the situation (and hopefully discouraging any manual edits):\n\n```         \n# Generated by roxygen2: do not edit by hand\n```\n\nAs you incorporate roxygen tags to export and import functions, you need to re-generate the `NAMESPACE` file periodically.\nHere is the general workflow for regenerating `NAMESPACE` (and your documentation):\n\n1.  Add namespace-related tags to the roxygen comments in your `R/*.R` files.\n    This is an artificial example, but it gives you the basic idea:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #' @importFrom aaapkg aaa_fun\n    #' @import bbbpkg\n    #' @export\n    foo <- function(x, y, z) {\n      ...\n    }\n    ```\n    :::\n\n\n2.  Run `devtools::document()` (or press Ctrl/Cmd + Shift + D in RStudio) to \"document\" your package.\n    By default, two things happen:\n\n    -   The help topics in the `man/*.Rd` files are updated (covered in @sec-man).\n\n    -   The `NAMESPACE` file is re-generated.\n        In our example, the `NAMESPACE` file would look like:\n\n        ```         \n        # Generated by roxygen2: do not edit by hand\n\n        export(foo)\n        import(bbbpkg)\n        importFrom(aaapkg,aaa_fun)\n        ```\n\nRoxygen2 is quite smart and will insert the appropriate directive in `NAMESPACE`, i.e. it can usually determine whether to use `export()` or `S3method()`.\n\n::: callout-tip\n## RStudio\n\nPress Ctrl/Cmd + Shift + D, to generate your package's `NAMESPACE` (and `man/*.Rd` files).\nThis is also available via *Document* in the *Build* menu and pane.\n:::\n\n## Package is listed in `Imports` {#sec-dependencies-in-imports}\n\nConsider a dependency that is listed in `DESCRIPTION` in `Imports`:\n\n``` yaml\nImports:\n    aaapkg\n```\n\nThe code inside your package can assume that aaapkg is installed whenever pkg is installed.\n\n### In code below R/ {#sec-dependencies-in-imports-r-code}\n\nOur recommended default is to call external functions using the `package::function()` syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomefunction <- function(...) {\n  ...\n  x <- aaapkg::aaa_fun(...)\n  ...\n}\n```\n:::\n\n\nSpecifically, we recommend that you default to *not* importing anything from aaapkg into your namespace.\nThis makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future.\nThis also eliminates any concerns about name conflicts between aaapkg and your package.\n\nOf course there are reasons to make exceptions to this rule and to import something from another package into yours:\n\n-   An operator: You can't call an operator from another package via `::`, so you must import it.\n    Examples: the null-coalescing operator `%||%` from rlang or the original pipe `%>%` from magrittr.\n\n-   A function that you use *a lot*: If importing a function makes your code much more readable, that's a good enough reason to import it.\n    This literally reduces the number of characters required to call the external function.\n    This can be especially handy when generating user-facing messages, because it makes it more likely that lines in the source correspond to lines in the output.\n\n-   A function that you call in a tight loop: There is a minor performance penalty associated with `::`.\n    It's on the order of 100ns, so it will only matter if you call the function millions of times.\n\nA handy function for your interactive workflow is `usethis::use_import_from()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_import_from(\"glue\", \"glue_collapse\")\n```\n:::\n\n\nThe call above writes this roxygen tag into the source code of your package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @importFrom glue glue_collapse\n```\n:::\n\n\nWhere should this roxygen tag go?\nThere are two reasonable locations:\n\n-   As close as possible to the usage of the external function.\n    With this mindset, you would place `@importFrom` in the roxygen comment above the function in your package where you use the external function.\n    If this is your style, you'll have to do it by hand.\n    We have found that this feels natural at first, but starts to break down as you use more external functions in more places.\n\n-   In a central location.\n    This approach keeps all `@importFrom` tags together, in a dedicated section of the package-level documentation file (which can be created with `usethis::use_package_doc()`, @sec-man-package-doc).\n    This is what `use_import_from()` implements.\n    So, in `R/pkg-package.R`, you'll end up with something like this:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # The following block is used by usethis to automatically manage\n    # roxygen namespace tags. Modify with care!\n    ## usethis namespace: start\n    #' @importFrom glue glue_collapse\n    ## usethis namespace: end\n    NULL\n    ```\n    :::\n\n\nRecall that `devtools::document()` processes your roxygen comments (@sec-dependencies-NAMESPACE-workflow), which writes help topics to `man/*.Rd` and, relevant to our current goal, generates the `NAMESPACE` file.\nIf you use `use_import_from()`, it does this for you and also calls `load_all()`, making the newly imported function available in your current session.\n\nThe roxygen tag above causes this directive to appear in the `NAMESPACE` file:\n\n```         \nimportFrom(glue, glue_collapse)\n```\n\nNow you can use the imported function directly in your code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomefunction <- function(...) {\n  ...\n  x <- glue_collapse(...)\n  ...\n}\n```\n:::\n\n\nSometimes you make such heavy use of so many functions from another package that you want to import its entire namespace.\nThis should be relatively rare.\nIn the tidyverse, the package we most commonly treat this way is rlang, which functions almost like a base package for us.\n\nHere is the roxygen tag that imports all of rlang.\nThis should appear somewhere in `R/*.R`, such as the dedicated space described above for collecting all of your namespace import tags.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @import rlang\n```\n:::\n\n\nAfter calling `devtools::document()`, this roxygen tag causes this directive to appear in the `NAMESPACE` file:\n\n```         \nimport(rlang)\n```\n\nThis is the least recommended solution because it can make your code harder to read (you can't tell where a function is coming from), and if you `@import` many packages, it increases the chance of function name conflicts.\nSave this for very special situations.\n\n#### How to *not* use a package in Imports\n\nSometimes you have a package listed in `Imports`, but you don't actually use it inside your package or, at least, R doesn't think you use it.\nThat leads to a `NOTE` from `R CMD check`:\n\n```         \n* checking dependencies in R code ... NOTE\nNamespace in Imports field not imported from: ‘aaapkg’\n  All declared Imports should be used.\n```\n\nThis can happen if you need to list an indirect dependency in `Imports`, perhaps to state a minimum version for it.\nThe tidyverse meta-package has this problem on a large scale, since it exists mostly to install a bundle of packages at specific versions.\nAnother scenario is when your package uses a dependency in such a way that requires another package that is only suggested by the direct dependency[^dependencies-in-practice-1].\nThere are various situations where it's not obvious that your package truly needs every package listed in `Imports`, but in fact it does.\n\n[^dependencies-in-practice-1]: For example, if your package needs to call `ggplot2::geom_hex()`, you might choose to list hexbin in `Imports`, since ggplot2 only lists it in `Suggests`.\n\nHow can you get rid of this `NOTE`?\n\nOur recommendation is to put a namespace-qualified reference (not a call) to an object in aaapkg in some file below `R/`, such as a `.R` file associated with package-wide setup:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nignore_unused_imports <- function() {\n  aaapkg::aaa_fun\n}\n```\n:::\n\n\nYou don't need to call `ignore_unused_imports()` anywhere.\nYou shouldn't export it.\nYou don't have to actually exercise `aaapkg::aaa_fun()`.\nWhat's important is to access something in aaapkg's namespace with `::`.\n\nAn alternative approach you might be tempted to use is to import `aaapkg::aaa_fun()` into your package's namespace, probably with the roxygen tag `@importFrom aaapkg aaa_fun`.\nThis does suppress the `NOTE`, but it also does more.\nThis causes aaapkg to be loaded whenever your package is loaded.\nIn contrast, if you use the approach we recommend, the aaapkg will only be loaded if your user does something that actually requires it.\nThis rarely matters in practice, but it's always nice to minimize or delay the loading of additional packages.\n\n### In test code {#sec-dependencies-in-imports-in-tests}\n\nRefer to external functions in your tests just as you refer to them in the code below `R/`.\nUsually this means you should use `aaapkg::aaa_fun()`.\nBut if you have imported a particular function, either specifically or as part of an entire namespace, you can just call it directly in your test code.\n\nIt's generally a bad idea to use `library(aaapkg)` to attach one of your dependencies somewhere in your tests, because it makes the search path in your tests different from how your package actually works.\nThis is covered in more detail in @sec-testing-design-tension.\n\n### In examples and vignettes\n\nIf you use a package that appears in `Imports` in one of your examples or vignettes, you'll need to either attach the package with `library(aaapkg)` or use a `aaapkg::aaa_fun()`-style call.\nYou can assume that aaapkg is available, because that's what `Imports` guarantees.\nRead more in @sec-man-examples-dependencies-conditional-execution and @sec-vignettes-eval-option.\n\n## Package is listed in `Suggests` {#sec-dependencies-in-suggests}\n\nConsider a dependency that is listed in `DESCRIPTION` in `Suggests`:\n\n``` yaml\nSuggests:\n    aaapkg\n```\n\nYou can NOT assume that every user has installed aaapkg (but you can assume that a developer has).\nWhether a user has aaapkg will depend on how they installed your package.\nMost of the functions that are used to install packages support a `dependencies` argument that controls whether to install just the hard dependencies or to take a more expansive approach, which includes suggested packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(dependencies =)\nremotes::install_github(dependencies =)\npak::pkg_install(dependencies =)\n```\n:::\n\n\nBroadly speaking, the default is to not install packages in `Suggests`.\n\n### In code below `R/` {#sec-dependencies-in-suggests-r-code}\n\nInside a function in your own package, check for the availability of a suggested package with `requireNamespace(\"aaapkg\", quietly = TRUE)`.\nThere are two basic scenarios: the dependency is absolutely required or your package offers some sort of fallback behaviour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the suggested package is required \nmy_fun <- function(a, b) {\n  if (!requireNamespace(\"aaapkg\", quietly = TRUE)) {\n    stop(\n      \"Package \\\"aaapkg\\\" must be installed to use this function.\",\n      call. = FALSE\n    )\n  }\n  # code that includes calls such as aaapkg::aaa_fun()\n}\n\n# the suggested package is optional; a fallback method is available\nmy_fun <- function(a, b) {\n  if (requireNamespace(\"aaapkg\", quietly = TRUE)) {\n    aaapkg::aaa_fun()\n  } else {\n    g()\n  }\n}\n```\n:::\n\n\nThe rlang package has some useful functions for checking package availability: `rlang::check_installed()` and `rlang::is_installed()`.\nHere's how the checks around a suggested package could look if you use rlang:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the suggested package is required \nmy_fun <- function(a, b) {\n  rlang::check_installed(\"aaapkg\", reason = \"to use `aaa_fun()`\")\n  # code that includes calls such as aaapkg::aaa_fun()\n}\n\n# the suggested package is optional; a fallback method is available\nmy_fun <- function(a, b) {\n  if (rlang::is_installed(\"aaapkg\")) {\n    aaapkg::aaa_fun()\n  } else {\n    g()\n  }\n}\n```\n:::\n\n\nThese rlang functions have handy features for programming, such as vectorization over `pkg`, classed errors with a data payload, and, for `check_installed()`, an offer to install the needed package in an interactive session.\n\n### In test code {#sec-dependencies-in-suggests-in-tests}\n\nThe tidyverse team generally writes tests as if all suggested packages are available.\nThat is, we use them unconditionally in the tests.\n\nThe motivation for this posture is self-consistency and pragmatism.\nThe key package needed to run tests is testthat and it appears in `Suggests`, not in `Imports` or `Depends`.\nTherefore, if the tests are actually executing, that implies that an expansive notion of package dependencies has been applied.\n\nAlso, empirically, in every important scenario of running `R CMD check`, the suggested packages are installed.\nThis is generally true for CRAN and we ensure that it's true in our own automated checks.\nHowever, it's important to note that other package maintainers take a different stance and choose to protect all usage of suggested packages in their tests and vignettes.\n\nSometimes even we make an exception and guard the use of a suggested package in a test.\nHere's a test from ggplot2, which uses `testthat::skip_if_not_installed()` to skip execution if the suggested sf package is not available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"basic plot builds without error\", {\n  skip_if_not_installed(\"sf\")\n\n  nc_tiny_coords <- matrix(\n    c(-81.473, -81.741, -81.67, -81.345, -81.266, -81.24, -81.473,\n      36.234, 36.392, 36.59, 36.573, 36.437, 36.365, 36.234),\n    ncol = 2\n  )\n\n  nc <- sf::st_as_sf(\n    data_frame(\n      NAME = \"ashe\",\n      geometry = sf::st_sfc(sf::st_polygon(list(nc_tiny_coords)), crs = 4326)\n    )\n  )\n\n  expect_doppelganger(\"sf-polygons\", ggplot(nc) + geom_sf() + coord_sf())\n})\n```\n:::\n\n\nWhat might justify the use of `skip_if_not_installed()`?\nIn this case, the sf package can be nontrivial to install and it is conceivable that a contributor would want to run the remaining tests, even if sf is not available.\n\nFinally, note that `testthat::skip_if_not_installed(pkg, minimum_version = \"x.y.z\")` can be used to conditionally skip a test based on the version of the other package.\n\n### In examples and vignettes {#sec-dependencies-in-suggests-in-examples-and-vignettes}\n\nAnother common place to use a suggested package is in an example and here we often guard with `require()` or `requireNamespace()`.\nThis example is from `ggplot2::coord_map()`.\nggplot2 lists the maps package in `Suggests`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @examples\n#' if (require(\"maps\")) {\n#'   nz <- map_data(\"nz\")\n#'   # Prepare a map of NZ\n#'   nzmap <- ggplot(nz, aes(x = long, y = lat, group = group)) +\n#'     geom_polygon(fill = \"white\", colour = \"black\")\n#'  \n#'   # Plot it in cartesian coordinates\n#'   nzmap\n#' }\n```\n:::\n\n\nAn example is basically the only place where we would use `require()` inside a package.\nRead more in @sec-dependencies-attach-vs-load.\n\nOur stance regarding the use of suggested packages in vignettes is similar to that for tests.\nThe key packages needed to build vignettes (rmarkdown and knitr) are listed in `Suggests`.\nTherefore, if the vignettes are being built, it's reasonable to assume that all of the suggested packages are available.\nWe typically use suggested packages unconditionally inside vignettes.\n\nBut if you choose to use suggested packages conditionally in your vignettes, the knitr chunk option `eval` is very useful for achieving this.\nSee @sec-vignettes-eval-option for more.\n\n## Package is listed in `Depends` {#sec-dependencies-in-depends}\n\nConsider a dependency that is listed in `DESCRIPTION` in `Depends`:\n\n``` yaml\nDepends:\n    aaapkg\n```\n\nThis situation has a lot in common with a package listed in `Imports`.\nThe code inside your package can assume that aaapkg is installed on the system.\nThe only difference is that aaapkg will be attached whenever your package is.\n\n### In code below `R/` and in test code\n\nYour options are exactly the same as using functions from a package listed in `Imports`:\n\n-   Use the `aaapkg::aaa_fun()` syntax.\n\n-   Import an individual function with the `@importFrom aaapkg aaa_fun` roxygen tag and call `aaa_fun()` directly.\n\n-   Import the entire aaapkg namespace with the `@import aaapkg` roxygen tag and call any function directly.\n\nThe main difference between this situation and a dependency listed in `Imports` is that it's much more common to import the entire namespace of a package listed in `Depends`.\nThis often makes sense, due to the special dependency relationship that motivated listing it in `Depends` in the first place.\n\n### In examples and vignettes\n\nThis is the most obvious difference with a dependency in `Depends` versus `Imports`.\nSince your package is attached when your examples are executed, so is the package listed in `Depends`.\nYou don't have to attach it explicitly with `library(aaapkg)`.\n\nThe ggforce package `Depends` on ggplot2 and the examples for `ggforce::geom_mark_rect()` use functions like `ggplot2::ggplot()` and `ggplot2::geom_point()` without any explicit call to `library(ggplot2)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(Petal.Length, Petal.Width)) +\n  geom_mark_rect(aes(fill = Species, filter = Species != 'versicolor')) +\n  geom_point()\n# example code continues ...\n```\n:::\n\n\nThe first line of code executed in one of your vignettes is probably `library(pkg)`, which attaches your package and, as a side effect, attaches any dependency listed in `Depends`.\nYou do not need to explicitly attach the dependency before using it.\nThe censored package `Depends` on the survival package and the code in `vignette(\"examples\", package = \"censored\")` starts out like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(censored)\n#> Loading required package: survival\n\n# vignette code continues ...\n```\n:::\n\n\n## Package is a nonstandard dependency {#sec-dependencies-nonstandard}\n\nIn packages developed with devtools, you may see `DESCRIPTION` files that use a couple other nonstandard fields for package dependencies specific to development tasks.\n\n### Depending on the development version of a package\n\nThe `Remotes` field can be used when you need to install a dependency from a nonstandard place, i.e. from somewhere besides CRAN or Bioconductor.\nOne common example of this is when you're developing against a development version of one of your dependencies.\nDuring this time, you'll want to install the dependency from its development repository, which is often GitHub.\nThe way to specify various remote sources is described in a [devtools vignette](https://devtools.r-lib.org/articles/dependencies.html) and in a [pak help topic](https://pak.r-lib.org/reference/pak_package_sources.html).\n\nThe dependency and any minimum version requirement still need to be declared in the normal way in, e.g., `Imports`.\n`usethis::use_dev_package()` helps to make the necessary changes in `DESCRIPTION`.\nIf your package temporarily relies on a development version of aaapkg, the affected `DESCRIPTION` fields might evolve like this:\n\n<!-- This is unlovely, but I just wanted to get the content down \"on paper\". It's easier to convey with a concrete example. -->\n\n```         \nStable -->               Dev -->                       Stable again\n----------------------   ---------------------------   ----------------------\nPackage: pkg             Package: pkg                  Package: pkg\nVersion: 1.0.0           Version: 1.0.0.9000           Version: 1.1.0\nImports:                 Imports:                      Imports: \n    aaapkg (>= 2.1.3)       aaapkg (>= 2.1.3.9000)       aaapkg (>= 2.2.0)\n                         Remotes:   \n                             jane/aaapkg \n```\n\n::: callout-warning\n## CRAN\n\nIt's important to note that you should not submit your package to CRAN in the intermediate state, meaning with a `Remotes` field and with a dependency required at a version that's not available from CRAN or Bioconductor.\nFor CRAN packages, this can only be a temporary development state, eventually resolved when the dependency updates on CRAN and you can bump your minimum version accordingly.\n:::\n\n### `Config/Needs/*` field {#sec-dependencies-nonstandard-config-needs}\n\nYou may also see devtools-developed packages with packages listed in `DESCRIPTION` fields in the form of `Config/Needs/*`, which we described in @sec-description-custom-fields.\n\n\n```{=html}\n<!--\nhttps://github.com/wch/r-source/blob/de49776d9fe54cb4580fbbd04906b40fe2f6117e/src/library/tools/R/QC.R#L7133\nhttps://github.com/wch/r-source/blob/efacf56dcf2f880b9db8eafa28d49a08d56e861e/src/library/tools/R/utils.R#L1316-L1389\n-->\n```\n\nThe use of `Config/Needs/*` is not directly related to devtools.\nIt's more accurate to say that it's associated with continuous integration workflows made available to the community at <https://github.com/r-lib/actions/> and exposed via functions such as `usethis::use_github_actions()`.\nA `Config/Needs/*` field tells the [`setup-r-dependencies`](https://github.com/r-lib/actions/tree/HEAD/setup-r-dependencies#readme) GitHub Action about extra packages that need to be installed.\n\n`Config/Needs/website` is the most common and it provides a place to specify packages that aren't a formal dependency, but that must be present in order to build the package's website (@sec-website).\nThe readxl package is a good example.\nIt has a [non-vignette article on workflows](https://readxl.tidyverse.org/articles/readxl-workflows.html) that shows readxl working in concert with other tidyverse packages, such as readr and purrr.\nBut it doesn't make sense for readxl to have a formal dependency on readr or purrr or (even worse) the tidyverse!\n\nOn the left is what readxl has in the `Config/Needs/website` field of `DESCRIPTION` to indicate that the tidyverse is needed in order to build the website, which is also formatted with styling that lives in the `tidyverse/template` GitHub repo.\nOn the right is the corresponding excerpt from the configuration of the workflow that builds and deploys the website.\n\n```         \nin DESCRIPTION                  in .github/workflows/pkgdown.yaml\n--------------------------      ---------------------------------\nConfig/Needs/website:           - uses: r-lib/actions/setup-r-dependencies@v2\n    tidyverse,                    with:\n    tidyverse/tidytemplate          extra-packages: pkgdown\n                                    needs: website\n```\n\nPackage websites and continuous integration are discussed more in @sec-website and @sec-sw-dev-practices-ci, respectively.\n\nThe `Config/Needs/*` convention is handy because it allows a developer to use `DESCRIPTION` as their definitive record of package dependencies, while maintaining a clean distinction between true runtime dependencies versus those that are only needed for specialized development tasks.\n\n## Exports\n\nFor a function to be usable outside of your package, you must **export** it.\nWhen you create a new package with `usethis::create_package()`, nothing is exported at first, even once you add some functions.\nYou can still experiment interactively with `load_all()`, since that loads all functions, not just those that are exported.\nBut if you install and attach the package with `library(pkg)` in a fresh R session, you'll notice that no functions are available.\n\n### What to export\n\nExport functions that you want other people to use.\nExported functions must be documented, and you must be cautious when changing their interface --- other people are using them!\nGenerally, it's better to export too little than too much.\nIt's easy to start exporting something that you previously did not; it's hard to stop exporting a function because it might break existing code.\nAlways err on the side of caution, and simplicity.\nIt's easier to give people more functionality than it is to take away stuff they're used to.\n\nWe believe that packages that have a wide audience should strive to do one thing and do it well.\nAll functions in a package should be related to a single problem (or a set of closely related problems).\nAny functions not related to that purpose should not be exported.\nFor example, most of our packages have a `utils.R` file (@sec-code-organising) that contains small utility functions that are useful internally, but aren't part of the core purpose of those packages.\nWe don't export such functions.\nThere are at least two reasons for this:\n\n-   Freedom to be less robust and less general.\n    A utility for internal use doesn't have to be implemented in the same way as a function used by others.\n    You just need to cover your own use case.\n\n-   Regrettable reverse dependencies.\n    You don't want people depending on your package for functionality and functions that are unrelated to its core purpose.\n\nThat said, if you're creating a package for yourself, it's far less important to be this disciplined.\nBecause you know what's in your package, it's fine to have a local \"miscellany\" package that contains a hodgepodge of functions that you find useful.\nBut it is probably not a good idea to release such a package for wider use.\n\nSometimes your package has a function that could be of interest to other developers extending your package, but not to typical users.\nIn this case, you want to export the function, but also to give it a very low profile in terms of public documentation.\nThis can be achieved by combining the roxygen tags `@export` and `@keywords internal`.\nThe `internal` keyword keeps the function from appearing in the package index, but the associated help topic still exists and the function still appears among those exported in the `NAMESPACE` file.\n\n### Re-exporting\n\nSometimes you want to make something available to users of your package that is actually provided by one of your dependencies.\nWhen devtools was split into several smaller packages (@sec-setup-usage), many of the user-facing functions moved elsewhere.\nFor usethis, the chosen solution was to list it in `Depends` (@sec-dependencies-imports-vs-depends), but that is not a good general solution.\nInstead, devtools now re-exports certain functions that actually live in a different package.\n\nHere is a blueprint for re-exporting an object from another package, using the `session_info()` function as our example:\n\n1.  List the package that hosts the re-exported object in `Imports` in `DESCRIPTION`.[^dependencies-in-practice-2]\n    In this case, the `session_info()` function is exported by the sessioninfo package.\n\n    ``` yaml\n    Imports:\n        sessioninfo\n    ```\n\n2.  In one of your `R/*.R` files, have a reference to the target function, preceded by roxygen tags for both importing and exporting.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #' @export\n    #' @importFrom sessioninfo session_info\n    sessioninfo::session_info\n    ```\n    :::\n\n\n[^dependencies-in-practice-2]: Remember `usethis::use_package()` is helpful for adding dependencies to `DESCRIPTION`.\n\nThat's it!\nNext time you re-generate NAMESPACE, these two lines will be there (typically interspersed with other exports and imports):\n\n```         \n...\nexport(session_info)\n...\nimportFrom(sessioninfo,session_info)\n...\n```\n\nAnd this explains how `library(devtools)` makes `session_info()` available in the current session.\nThis will also lead to the creation of the `man/reexports.Rd` file, which finesses the requirement that your package must document all of its exported functions.\nThis help topic lists all re-exported objects and links to their primary documentation.\n\n## Imports and exports related to S3\n\nR has multiple object-oriented programming (OOP) systems:\n\n-   S3 is currently the most important for us and is what's addressed in this book.\n    The [S3 chapter of Advanced R](https://adv-r.hadley.nz/s3.html) is a good place to learn more about S3 conceptually and the [vctrs package](https://vctrs.r-lib.org) is worth studying for practical knowledge.\n\n-   S4 is very important within certain R communities, most notably within the Bioconductor project.\n    We only use S4 when it's necessary for compatibility with other packages.\n    If you want to learn more, the [S4 chapter of Advanced R](https://adv-r.hadley.nz/s4.html) is a good starting point and has recommendations for additional resources.\n\n-   R6 is used in many tidyverse packages (broadly defined), but is out of scope for this book.\n    Good places to learn more include the [R6 package website](https://r6.r-lib.org), the [R6 chapter of Advanced R](https://adv-r.hadley.nz/r6.html), and the [roxygen2 documentation related to R6](https://roxygen2.r-lib.org/articles/rd-other.html#r6).\n\nIn terms of namespace issues around S3 classes, the main things to consider are generic functions and their class-specific implementations known as methods.\nIf your package \"owns\" an S3 class, it makes sense to export a user-friendly constructor function.\nThis is often just a regular function and there is no special S3 angle.\n\nIf your package \"owns\" an S3 generic and you want others to be able to use it, you should export the generic.\nFor example, the dplyr package exports the generic function `dplyr::count()` and also implements and exports a specific method, `count.data.frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' ... all the usual documentation for count() ...\n#' @export\ncount <- function(x, ..., wt = NULL, sort = FALSE, name = NULL) {\n  UseMethod(\"count\")\n}\n\n#' @export\ncount.data.frame <- function(\n  x,\n  ...,\n  wt = NULL,\n  sort = FALSE,\n  name = NULL,\n  .drop = group_by_drop_default(x)) { ... }\n```\n:::\n\n\nThe corresponding lines in dplyr's `NAMESPACE` file look like this:\n\n```         \n...\nS3method(count,data.frame)\n...\nexport(count)\n...\n```\n\nNow imagine that your package implements a method for `count()` for a class you \"own\" (not `data.frame`).\nA good example is the dbplyr package, which implements `count()` for the `tbl_lazy` class.\nAn add-on package that implements an S3 generic for a new class should list the generic-providing package in `Imports`, import the generic into its namespace, and export its S3 method.\nHere's part of dbplyr's `DESCRIPTION` file:\n\n```         \nImports: \n    ...,\n    dplyr,\n    ...\n```\n\nIn `dbplyr/R/verb-count.R`, we have:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @importFrom dplyr count\n#' @export\ncount.tbl_lazy <- function(x, ..., wt = NULL, sort = FALSE, name = NULL) { ... }\n```\n:::\n\n\nIn `NAMESPACE`, we have:\n\n```         \nS3method(count,tbl_lazy)\n...\nimportFrom(dplyr,count)\n```\n\nDbplyr also provides methods for various generics provided by the base package, such as `dim()` and `names()`.\nIn this case, there is no need to import those generics, but it's still necessary to export the methods.\nIn `dbplyr/R/tbl_lazy.R`, we have:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @export\ndim.tbl_lazy <- function(x) {\n  c(NA, length(op_vars(x$lazy_query)))\n}\n\n#' @export\nnames.tbl_lazy <- function(x) {\n  colnames(x)\n}\n```\n:::\n\n\nIn `NAMESPACE`, this produces:\n\n```         \nS3method(dim,tbl_lazy)\n...\nS3method(names,tbl_lazy)\n```\n\nThe last and trickiest case is when your package offers a method for a generic \"owned\" by a package you've listed in `Suggests`.\nThe basic idea is that you want to register the availability of your S3 method conditionally, when your package is being loaded.\nIf the suggested package is present, your S3 method should be registered, but otherwise it should not.\n\nWe'll illustrate this with an example.\nWithin the tidyverse, the glue package is managed as a low-level package that should have minimal dependencies (@sec-dependencies-tidyverse).\nGlue functions generally return a character vector that also has the `\"glue\"` S3 class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\nname <- \"Betty\"\n(ret <- glue('My name is {name}.'))\n#> My name is Betty.\nclass(ret)\n#> [1] \"glue\"      \"character\"\n```\n:::\n\n\nThe motivation for this is that it allows glue to offer special methods for `print()`, the `+` operator, and subsetting via `[` and `[[`.\nOne downside, though, is that this class attribute complicates string comparisons:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(ret, \"My name is Betty.\")\n#> [1] FALSE\nall.equal(ret, \"My name is Betty.\")\n#> [1] \"Attributes: < Modes: list, NULL >\"                   \n#> [2] \"Attributes: < Lengths: 1, 0 >\"                       \n#> [3] \"Attributes: < names for target but not for current >\"\n#> [4] \"Attributes: < current is not list-like >\"            \n#> [5] \"target is glue, current is character\"\n```\n:::\n\n\nTherefore, for testing, it is helpful if glue offers a method for `testthat::compare()`, which explains why this expectation succeeds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntestthat::expect_equal(ret, \"My name is Betty.\")\n```\n:::\n\n\nBut glue can't list testthat in `Imports`!\nIt must go in `Suggests`.\nThe solution is to register the method conditionally when glue is loaded.\nHere is a redacted version of glue's `.onLoad()` function, where you'll see that it conditionally registers some other methods as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.onLoad <- function(...) {\n  s3_register(\"testthat::compare\", \"glue\")\n  s3_register(\"waldo::compare_proxy\", \"glue\")\n  s3_register(\"vctrs::vec_ptype2\", \"glue.glue\")\n  ...\n  invisible()\n}\n```\n:::\n\n\nThe `s3_register()` function comes from the vctrs package.\nIf you don't have an organic need to depend on vctrs, it is common (and encouraged) to simply inline [the `s3_register()` source](https://github.com/r-lib/vctrs/blob/main/R/register-s3.R) into your own package.\nYou can't always copy code from other people's packages and paste it into yours, but you can in this case.\nThis usage is specifically allowed by the license of the source code of `s3_register()`.\nThis provides a great segue into @sec-license, which is all about licensing.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}