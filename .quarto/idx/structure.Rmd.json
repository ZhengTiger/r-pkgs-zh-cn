{"title":"Package structure and state","markdown":{"headingText":"Package structure and state","headingAttr":{"id":"sec-package-structure-state","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n```{r, echo = FALSE}\nsource(\"common.R\")\n```\n\n本章将通过把您从使用 R 包中获得的隐性知识转换为创建和修改它们所需的显式知识，从而开始开发程序包。\n您将了解程序包（package）的各种状态，以及它和库（library）之间的区别（以及为什么要关心二者的区别）。\n\n\n## Package states {#sec-package-states}\n\n当你创建或修改一个包时，需要在它的源代码（\"source code\"）或源文件（\"source files\"）上进行。\n您能够以源代码（**source**）的形式与正在开发的程序包进行交互。\n这不是您在日常使用中最熟悉的包形式。\n如果您了解 R 程序包可能处于的五种状态，那么程序包开发的工作流将变得更有意义：\n\n- 源代码（source）\n- 捆绑的（bundled）\n- 二进制文件（binary）\n- 已安装的（installed）\n- 载入内存中的（in-memory）\n\n您已经知道一些将程序包转入这些状态的函数。\n例如，`install.packages()` 可以将包从源码（source）、捆绑（bundled）或二进制（binary）状态移动到已安装（installed）状态。\n`devtools::install_github()` 获取 GitHub 上的源码（source）包并将其移至已安装（installed）状态。\n`library()` 函数的作用是：将已安装的程序包加载到内存中，以便可以马上直接使用。\n\n\n## Source package {#sec-source-package}\n\n一个源码（**source**）程序包就是一个有着特定结构的文件目录。\n它包含特定的组件，例如一个 `DESCRIPTION` 文件、包含 `.R` 文件的 `R/` 目录等。\n本书余下的大部分章节都致力于详细说明这些组成部分。\n\n如果您刚刚接触 R 程序包的开发，那么您可能从未见过源码（source）形式的程序包！\n您的计算机上可能甚至没有任何源码程序包。\n以源码形式查看程序包的最简单的方法是在 web 上浏览其代码。\n\n许多 R 程序包是在 GitHub（或者 GitLab 以及类似的平台）上的公开库中开发的。\n最好的方案是访问程序包的 CRAN 主页，例如：\n\n-   forcats: <https://cran.r-project.org/package=forcats>\n-   readxl: <https://cran.r-project.org/package=readxl>\n\n并且其中一个网页链接（URLs）链接到公共托管服务上的存储库（repository），例如：\n\n-   forcats: <https://github.com/tidyverse/forcats>\n-   readxl: <https://github.com/tidyverse/readxl>\n\n即使程序包是在公共存储库中开发的，一些维护人员还是忘记了列出这个网页链接（URL），但是您仍然可以通过搜索来发现它。\n\n即使程序包不是在公共平台上开发的，也可以在 [unofficial, read-only mirror maintained by R-hub](https://docs.r-hub.io/#cranatgh) 中访问其源代码。\n示例：\n\n-   MASS: <https://github.com/cran/MASS>\n-   car: <https://github.com/cran/car>\n\n请注意，在 `cran` GitHub 组织内探索包的源码和历史记录与探索包的真正开发场所不同，因为此源码及其演变只是从包的 CRAN 版本进行逆向工程。\n它提供了对程序包及其开发历史的审查视图，但根据定义，源代码及其历史包含了所有程序包开发的必需的内容。\n\n\n## Bundled package {#sec-bundled-package}\n\n捆绑的（**bundled**）程序包是被压缩成单个文件的程序包。\n按照惯例（该惯例来自 Linux），R 中的捆绑程序包使用 `.tar.gz` 扩展名，并且有时被称为源码压缩包（\"source tarballs\"）。\n这意味着多个文件已经被打包为一个文件（`.tar`）并使用 gzip（`.gz`）进行压缩。\n虽然捆绑程序包本身并不那么有用，但它是源码包和已安装包之间平台无关的、便于传输的中间媒介。\n\n在从本地开发的程序包中生成捆绑程序包这种罕见的情况下，请使用 `devtools::build()`。\n在幕后，它会调用 `pkgbuild::build()` 并最终调用 `R CMD build`，这些会在 [Writing R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html) 的 [Building package tarballs](https://cran.r-project.org/doc/manuals/R-exts.html#Building-package-tarballs) 部分中进一步阐述。\n\n这应该会提醒您，捆绑程序包或源码压缩包不仅仅是对源文件进行 tar 打包存档，然后使用 gzip 压缩的结果。\n按照惯例，在 R 世界中，在制作 `.tar.gz` 文件时还要执行一些操作。\n这就是我们选择将其称为捆绑（**bundle**）程序包的原因。\n\n每个 CRAN 包都可以通过其登陆页面的 \"Package source\" 字段以捆绑（bundled）形式提供。\n继续我们上面的示例，您可以下载 `forcats_0.4.0.tar.gz` 和 `readxl_1.3.1.tar.gz` 的捆绑包（或者任何当前的版本）。\n您可以在 shell（而不是 R 控制台）中进行解压缩：\n\n``` bash\ntar xvf forcats_0.4.0.tar.gz\n```\n\n如果您解压缩一个捆绑包，您将看到它看起来几乎与源码包相同。\n@fig-package-files 显示了名为 zzzpackage 的虚构包的源码（source）、捆绑（bundled）、二进制（binary）形式的文件。\n我们特意制作了这个示例，以包含本书中涵盖的大部分包部分。\n并非每个包都包含此处看到的每个文件，此图也不包含可能出现在包中的每个可能文件。\n\n```{r}\n#| label: fig-package-files\n#| echo: false\n#| out-width: ~\n#| fig-cap: >\n#|   Package forms: source vs. bundled vs. binary.\n#| fig-alt: >\n#|   Side-by-side comparison of source, bundled, and binary package. \n#|   The flow of files (location and format) from package source to \n#|   bundled to binary state is shown. This is described in\n#|   detail in the appropriately named sections of this chapter.\nknitr::include_graphics(\"diagrams/package-files.png\")\n```\n\n源码（source）包和未压缩的捆绑（bundle）包之间的主要区别为：\n\n-   已经生成了 Vignettes，因此以已渲染的输出（如 HTML）出现在 `inst/doc/` 目录下，并且 Vignette 索引出现在 `build/` 目录中。\n\n-   本地源码包可能包含用于在开发期间节省时间的临时文件，如 `src/` 中的编译文件。\n    这些文件从来没有在捆绑包中找到过。\n\n-   `.Rbuildignore` 中列出的任何文件都不包含在捆绑包中。\n    这些文件通常有助于您的开发过程，但应该从分发式的产品中排除。\n\n### `.Rbuildignore` {#sec-rbuildignore}\n\n您不需要非常频繁地考虑 `.tar.gz` 文件形式的程序包的确切结构，但您确实需要了解 `.Rbuildignore` 文件。\n它决定了源码包中的哪些文件可以进入后面的工作流。\n\n`.Rbuildignore` 的每一行都是与 Perl 兼容的正则表达式，不考虑大小写，它与源码包中每个文件的路径匹配[^structure-1]。\n如果与正则表达式匹配，则排除该文件或目录。\n注意，有一些默认排除项由 R 本身执行，主要与经典的版本控制系统和编辑器（如 SVN、Git 和 Emacs）有关。\n\n[^structure-1]: 要查看应该在您的雷达上的文件路径集，请在包的顶级目录中执行 `dir(full.names = TRUE, recursive = TRUE, include.dirs = TRUE, all.files = TRUE)` 。\n\n我们通常使用 `usethis::use_build_ignore()` 函数修改 `.Rbuildignore`，它负责处理容易忘记的细节，例如正则表达式锚定和转义。\n要排除特定文件或目录（最常见的使用示例），您必须锚定（anchor）正则表达式。\n例如，要排除名为 \"notes\" 的目录，`.Rbuildignore` 条目必须是 `^notes$`，而未锚定的正则表达式 `notes` 将匹配任何包含 \"notes\" 的文件名，例如 `R/notes.R`、`man/important-notes.R`、`data/endnotes.Rdata` 等。\n我们发现 `use_build_ignore()` 可以帮助我们一次性获得更多的 `.Rbuildignore` 条目。\n\n`.Rbuildignore` 是解决让您更便利地开发的操作与 CRAN 提交和分发的要求之间一些紧张关系的一种方法 (@sec-release)。\n即使您不打算在 CRAN 上发布，遵循这些约定能让您最好地使用 R 的内置工具来检查和安装程序包。\n你应该 `.Rbuildignore` 的文件分为两个广泛的、半重叠的类别：\n\n-   帮助您以编程方式生成程序包内容的文件。例如：\n    -   使用 `README.Rmd` 生成信息丰富的最新 `README.md`（@sec-readme）。\n    -   存储 `.R` 脚本以创建和更新内部或导出数据（@sec-data-data-raw）。\n-   驱动程序包开发、检查和产生文档的文件，不在 CRAN 的范围内。例如：\n    -   与 RStudio IDE 相关的文件（@sec-workflow101-rstudio-projects）。\n    -   使用 [pkgdown package](https://pkgdown.r-lib.org/) 生成网站（@sec-website）。\n    -   与持续集成/部署相关的配置文件（@sec-sw-dev-practices-ci）。\n\n以下是 tidyverse 中程序包的 `.Rbuildignore` 文件中典型条目的非完整列表：\n\n```         \n^.*\\.Rproj$         # Designates the directory as an RStudio Project\n^\\.Rproj\\.user$     # Used by RStudio for temporary files\n^README\\.Rmd$       # An Rmd file used to generate README.md\n^LICENSE\\.md$       # Full text of the license\n^cran-comments\\.md$ # Comments for CRAN submission\n^data-raw$          # Code used to create data included in the package\n^pkgdown$           # Resources used for the package website\n^_pkgdown\\.yml$     # Configuration info for the package website\n^\\.github$          # GitHub Actions workflows\n```\n\n请注意，上面的注释不能出现在实际的 `.Rbuildignore` 文件中；此处包含这些注释只是为了演示。\n\n我们会在需要的时候提到何时需要向 `.Rbuildignore` 中添加排除项。\n请记住 `usethis::use_build_ignore()` 是管理此文件的一种有吸引力的方法。\n此外，许多使用此功能添加应在 `.Rbuildignore` 中列出的文件会自动处理此问题。\n例如，`use_read_rmd()` 将 \"\\^README\\\\.Rmd\\$\" 添加到 `.Rbuildignore`。\n\n\n## Binary package {#sec-structure-binary}\n\n如果要将程序包分发给没有程序包开发工具的 R 用户，则需要提供二进制（**binary**）包。\n二进制包的主要制造者和分发者是 CRAN，而不是个人维护者。\n但是，即使您将分发包的责任委托给 CRAN，维护者了解二进制包的性质仍然很重要。\n\n与捆绑包一样，二进制包是单个文件。\n与捆绑包不同，二进制包是特定于平台的，有两种基本风格：Windows 和 macOS。\n（Linux 用户通常需要拥有从 `.tar.gz` 文件安装所需的工具，尽管像 [Posit Public Package Manager](https://packagemanager.posit.co/) 这样的资源的出现让 Linux 用户可以像他们在 Windows 和 macOS 上的同事一样访问二进制包。）\n\nmacOS 的二进制包存储为 `.tgz`，而 Windows 二进制包以 `.zip` 结尾。\n如果需要制作二进制包，请在相关操作系统上使用 `devtools::build(binary = TRUE)`。\n在幕后，这会调用 `pkgbuild::build(binary = TRUE)` 并最终调用 `R CMD INSTALL --build`，这在 [Writing R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html) 的 [Building binary packages](https://cran.r-project.org/doc/manuals/R-exts.html#Building-binary-packages) 部分中有进一步描述。\n如果你选择在 CRAN 上发布你的包（@sec-release），你以捆绑形式提交你的包，然后 CRAN 创建并分发包二进制文件。\n\n不论是 macOS 或 Windows，还是 R 的当前、先前和（可能的）开发版本，CRAN 通常都能以二进制包形式提供。\n继续我们上面的例子，您能够下载二进制包，例如：\n\n-   forcats for macOS: `forcats_0.4.0.tgz`\n-   readxl for Windows: `readxl_1.3.1.zip`\n\n事实上，这是您在调用 `isntall.packages()` 时通常进行的部分幕后操作。\n\n如果解压缩二进制包，您将看到它的内部结构与源码包或捆绑包有很大不同。\n@fig-package-files 包含了二者的比较。\n以下是一些最显著的区别：\n\n-   在 `R/` 目录中没有 `.R` 文件，而是有三个文件以有效的文件格式存储着解析的函数。\n    这基本上是加载所有 R 代码，然后用 `save()` 保存函数的结果。\n    （在这个过程中，这会添加一些额外的 metadata，使得过程尽可能地快）。\n\n-   `Meta/` 目录中包含许多 `.rds` 文件。\n    这些文件包含有关包的缓存 metadata，如帮助文件所涵盖的主题和 `DESCRIPTION` 文件的解析版本。\n    （您可以使用 `readRDS()` 查看这些文件中的内容）。\n    这些文件通过缓存代价高昂的计算使程序包更快地加载。\n\n-   实际的帮助内容出现在 `help/` 和 `html/`（不再出现在 `man/`）中。\n\n-   如果 `src/` 目录中有任何代码，那么现在将有一个 `libs/` 目录，其中包含经过编译的代码。\n\n-   如果 `data/` 中有任何对象，则它们现在已转换为更具效率的形式。\n\n-   `inst/` 的内容被移动到顶层目录。\n    例如，vignette 文件现在位于 `doc/` 中。\n\n-   一些文件和文件夹已被删除，如 `README.md`、`build/`、`tests/` 和 `vignettes/`。\n\n\n## Installed package {#sec-installed-package}\n\n已安装的（**installed**）包是已解压缩到程序包库中的二进制包（described in @sec-library）。\n@fig-installation 说明了安装程序包的多种方法，以及将软件包从一种状态转换为另一种状态的一些其他函数。\n这个图表很复杂！在理想情况下，安装包需要将一组简单的步骤串在一起：source -\\> bundle, bundle -\\> binary, binary -\\> installed。\n在现实世界中，这个过程并不是这么简单，因为通常有（更快的）快捷方式可用。\n\n```{r}\n#| label: fig-installation\n#| echo: false\n#| out-width: ~\n#| fig-cap: >\n#|   Many methods for converting between package states.\n#| fig-alt: > \n#|   A chart showing different ways to go from one package state to another:\n#|   1. library() puts an installed package into memory.\n#|   2. Functions such as install.packages(),\n#|      devtools::install_github(), and devtools::install()\n#|      can install a package starting variously in the source,\n#|      bundle, or binary forms.\n#|   3. devtools::build() can create a bundle or a binary.\n#|   4. devtools::load_all() puts a source package into memory.\nknitr::include_graphics(\"diagrams/install-load.png\")\n```\n\n内置命令行工具 `R CMD INSTALL` 支持所有程序包的安装。\n它可以从源码文件、捆绑包、或二进制包安装程序包。\n有关详细信息，请参阅 [R Installation and Administration](https://cran.r-project.org/doc/manuals/R-admin.html) 的 [Installing packages](https://cran.r-project.org/doc/manuals/R-admin.html#Installing-packages) 部分。\n与 `devtools::build()` 一样，devtools 提供了一个包装函数 `devtools::install()`，使该工具在 R 会话（R Session）中可用。\n\n::: callout-tip\n## RStudio\n\nRStudio 可以帮助您安装开发中的包，通过 *Build* 窗格中的 *Install* 和 *More* 下拉菜单以及 *Build* 菜单中的 *Install Package*。\n:::\n\n可以理解，大多数用户喜欢 R 会话（R Session）的舒适性，因此直接从 CRAN 安装软件包。\n内置函数 `install.packages()` 满足了这一需要。\n它可以以各种形式下载程序包并安装它，还可以选择程序包依赖项的安装。\n\n然而，从 R 会话中安装 R 包的便利性是有代价的。\n如您所料，重新安装已在当前会话中使用的包可能有点棘手。\n这实际上大部分时间都有效，但有时却无效，尤其是在 Windows 上安装带有编译代码的 R 包时。\n由于文件句柄在 Windows 上的锁定方式，尝试安装正在使用的包的新版本可能会导致安装损坏，其中包的 R 代码已更新，但其编译代码尚未更新。\n排除故障时，Windows 用户应努力在干净的 R 会话中安装包，并加载尽可能少的包。\n\npak 包 (<https://pak.r-lib.org/>) 相对较新（在撰写本文时），它提供了一个有前途的替代 `install.packages()` 以及其他更专业的功能，例如 `devtools::install_github()`。\n现在全面推荐使用 pak 来满足您的所有软件包安装需求还为时过早，但我们肯定在我们的个人工作流程中越来越多地使用它。\npak 的旗舰功能之一是它很好地解决了上述 \"locked DLL\" 问题，即在 Windows 上使用编译代码更新包。\n随着您对包开发的深入，您会发现自己正在执行一组全新的任务，例如从开发中的分支安装依赖项或仔细检查包依赖项树。\npak 为这个任务和许多其他相关任务提供了一个丰富的工具包。\n我们预计 pak 将很快成为我们关于如何安装软件包（以及更多）的官方推荐。\n\n然而，与此同时，我们描述了现状。\ndevtools 长期以来一直提供一系列 `install_*()` 函数来解决一些超出 `install.packages()` 范围的需求，或者使现有功能更容易访问。\n这些功能实际上是在 [remotes package](https://remotes.r-lib.org/) 中维护的，并由 devtools 重新导出。\n（鉴于我们上面所说的，remotes 很可能会在本质上被取代，取而代之的是 pak，但我们还没有到那一步。）\n\n```{r}\nlibrary(remotes)\n\nfuns <- as.character(lsf.str(\"package:remotes\"))\ngrep(\"^install_.+\", funs, value = TRUE)\n```\n\n`install_github()` 是这些函数中最有用的一个，也显示在 @fig-installation 中。\n它是一系列功能的最佳示例，可以从非 CRAN 的远程位置下载包，并执行安装包所需的任何操作。\n其余的 devtools/remotes `install_*()` 函数旨在使基本工具在技术上更简单或更明确一些，例如 `install_version()`，它能够安装特定版本的 CRAN 包。\n\n与 `.Rbuildignore` 类似，如 @sec-rbuildignore 所述，`.Rinstignore` 允许您将捆绑包中的文件保留在已安装包之外。\n然而，与 `.Rbuildignore` 相反，这个功能相当模糊，而且很少需要这样做。\n\n\n## In-memory package\n\n我们终于讲述到了一个每个使用 R 的人都熟悉的命令。\n\n```{r, eval = FALSE}\nlibrary(usethis)\n```\n\n假设已经安装了 usethis，这个语句将使得里面的所有函数可用，即现在我们可以执行以下操作：\n\n```{r, eval = FALSE}\ncreate_package(\"/path/to/my/coolpackage\")\n```\n\n这样，usethis 包已加载到内存中，并且实际上也已附加到搜索路径。\n在编写脚本时，加载和附加程序包之间的区别并不重要，但在编写程序包时非常重要。\n您将在 @sec-dependencies-attach-vs-load 中了解更多关于差异及其重要性的信息。\n\n`library()` 并不是迭代调整和测试正在开发的程序包的好方法，因为它只适用于已安装的包。\n在 @sec-workflow101-load-all 中，您将了解 `devtools::load_all()` 如何通过允许您将源码包直接加载到内存中来加速开发过程。\n\n\n## Package libraries {#sec-library}\n\n我们刚刚讨论了 `library()` 函数，它的名字源于它的作用。\n当你调用 `library(somepackage)` 时，R 会在当前 **libraries** 中查找一个叫做 \"somepackage\" 的已安装包，如果成功了，R 将让 somepackage 变得可以使用。\n\n在 R 中，一个 **library** 就是一个包含了已安装程序包的目录，有点像图书库。\n不幸的是，在 R 的世界，您将会经常遇到 \"library\" 和 \"package\" 的混淆用法。\n例如，dplyr 是一个 package，但是通常有人将其称为一个 library。\n造成这种混乱的原因有几个。\n首先，R 的术语可以说是与更广泛的编程约定背道而驰的，\"library\" 的通常含义更接近于我们所说的 \"package\"。\n`library()` 函数本身的名称可能会强化这一错误的关联。\n最后，这种词汇错误通常是无害的，因此 R 用户很容易养成错误的习惯，而指出这个错误的人看起来像是令人无法忍受的学究。\n但底线是：\n\n> 我们使用 `library()` 函数加载一个 **package**[^structure-2]。\n\n[^structure-2]: 嗯，实际上，`library()` 加载并附加一个 package，但这是 @sec-dependencies-attach-vs-load 的主题。\n\n当您参与包开发时，两者之间的区别是重要且有用的。\n\n您的计算机上可以有多个 libraries。\n事实上，你们中的很多人已经这样做了，尤其是在 Windows 上。\n可以使用 `.libPaths()` 查看当前处于活动状态的 libraries。\n在 Windows 上看起来如下：\n\n```{r, eval = FALSE}\n# on Windows\n.libPaths()\n#> [1] \"C:/Users/jenny/Documents/R/win-library/4.2\"\n#> [2] \"C:/Program Files/R/R-4.2.2/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#> [[1]]\n#>   [1] \"abc\"           \"anytime\"       \"askpass\"       \"assertthat\"   \n#>  ...\n#> [145] \"zeallot\"      \n#> \n#> [[2]]\n#>  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#>  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#>  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#> [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#> [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#> [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#> [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#> [29] \"translations\" \"utils\"\n```\n\n在 macOS 上看起来类似（但您的结果可能会有所不同）:\n\n```{r, eval = FALSE}\n# on macOS\n.libPaths()\n#> [1] \"/Users/jenny/Library/R/arm64/4.2/library\"\n#> [2] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#> [[1]]\n#>    [1] \"abc\"                  \"abc.data\"             \"abind\"                \n#>  ...\n#> [1033] \"Zelig\"                \"zip\"                  \"zoo\"                 \n#> \n#> [[2]]\n#>  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#>  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#>  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#> [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#> [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#> [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#> [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#> [29] \"translations\" \"utils\"\n```\n\n在这两种情况下，我们可以看到两个活动库，它们的查询顺序如下：\n\n1.  用户库\n2.  系统级或全局库\n\n这样的设置是 Windows 上的经典设置，但通常是 macOS 和 Linux 上需要选择的设置[^structure-3]。\n在这样的设置之下，从 CRAN（或其他地方）安装的或本地开发的附加程序包保存在用户库中。\n和上面一样，macOS 系统被用作主要的开发机器，这里有很多软件包（\\~1000），而 Windows 系统只是偶尔使用，而且要简朴得多。\nR 附带的基本和推荐程序包的核心集位于系统级库中，这一点在 macOS 和 Windows 上是相同的。\n这种分离对许多开发人员很有吸引力，例如，在不干扰 base R 的安装的情况下使得清理附加包变得很容易。\n\n[^structure-3]: 有关更多详细信息，请参阅 *What They Forgot To Teach You About R* 中的 [Maintaining R section](https://whattheyforgot.org/maintaining-r.html#how-to-transfer-your-library-when-updating-r) 部分、*R Installation and Administration* 中的 [Managing Libraries](https://rstudio.github.io/r-manuals/r-admin/Add-on-packages.html#managing-libraries) 以及 `?Startup` 和 `?.libPaths` 的 R 帮助文件。\n\n如果您在 macOS 或 Linux 上只看到一个库，并不需要紧急更改任何内容。\n但下次升级 R 时，请考虑创建一个用户级库。\n默认情况下，R 查找存储在环境变量 `R_LIBS_USER` 中的路径下的用户库，在 macOS 上默认为 `~/Library/R/x.y/library`，在 Linux 上默认为 `~/R/m-library/x.y`（其中 `m` 是 CPU 架构的简明描述，`x.y` 是 R 版本）。\n您可以使用 `Sys.getenv(\"R_LIBS_USER\")` 查看此路径。\n默认情况下这些目录不存在，必须通过创建目录来启用它们。\n安装新版本的 R 时，在安装任何附加包之前，请使用 `dir.create(Sys.getenv(\"R_LIBS_USER\"), recursive = TRUE)` 在默认位置创建用户库。\n现在您将拥有上面看到的库设置。\n或者，您可以在其他地方设置用户库，并通过在 `.Renviron` 中设置 `R_LIBS_USER` 环境变量来告诉 R。\n编辑 `.Renviron` 文件的最简单方法是使用 `usethis::edit_r_environ()`，如果文件不存在，它将创建该文件，并打开它进行编辑。\n\n这些库的文件路径也清楚地表明它们与特定版本的 R（在编写本文时是 4.2.x）相关联，这也是经典的。\n这反映并强化了这样一个事实：当您将 R 从 4.1 更新到 4.2，即一个在次要（**minor**）版本上的更改时，您需要重新安装附加程序包。\n对于在补丁（**patch**）版本上的更改，例如从 R 4.2.1 到 4.2.2，通常不需要重新安装附加程序包。\n\n随着 R 的使用变得越来越复杂，开始更加有意地管理程序包库是十分平常的。\n例如，像 [renv](https://rstudio.github.io/renv/)（及其前身 [packrat](https://rstudio.github.io/packrat/)）这样的工具可以使管理项目特定库的过程自动化。\n这对于使数据产品具有可复制性、可移植性和相互隔离性非常重要。\n程序包开发人员可能会在库的搜索路径前添加一个临时库，其中包含一组特定版本的程序包，以便在不影响其他日常工作的情况下探索前后兼容性问题。\n反向依赖性检查（Reverse dependency checks）是另一个显式管理库的搜索路径的例子。\n\n以下是按范围和持久性顺序控制哪些库处于活动状态的主要杠杆：\n\nHere are the main levers that control which libraries are active, in order of scope and persistence:\n\n-   环境变量，如 `R_LIBS` 和 `R_LIBS_USER`，它们在启动时被查询。\n-   使用一个或多个文件路径调用 `.libPaths()`。\n-   通过 `withr::with_libpaths()` 使用临时更改的库搜索路径执行小型的代码段。\n-   单个函数的参数，比如 `install.packages(lib =)` 和 `library(lib.loc =)`。\n\n最后，需要注意的是，`library()` 永远不应该在程序包中使用。\n程序包和脚本依赖于不同的机制来声明它们的依赖性，这是您需要在您的心理模型和习惯中做出的最大调整之一。\n我们将在 @sec-description-imports-suggests 和 @sec-dependencies-in-practice 全面探讨这个话题。\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":["plausible.html"],"output-file":"structure.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.475","bibliography":["book.bib"],"editor":"source","mainfont":"Microsoft Yahei","theme":["cosmo","custom.scss"]},"extensions":{"book":{"multiFile":true}}}}}