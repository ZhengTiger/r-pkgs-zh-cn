{"title":"The Whole Game","markdown":{"headingText":"The Whole Game","headingAttr":{"id":"sec-whole-game","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n```{r, include = FALSE, R.options = list(tidyverse.quiet = TRUE)}\nsource(\"common.R\")\nlibrary(glue)\nlibrary(fs)\nlibrary(tidyverse)\n\n# Whenever any chunk changes, we want to re-run _every_ chunk\nrmd <- parsermd::parse_rmd(\"whole-game.Rmd\")\nchunks <- parsermd::rmd_select(rmd, parsermd::has_type(\"rmd_chunk\"))\nknitr::opts_chunk$set(\n  cache = TRUE,\n  cache.extra = digest::digest(chunks)\n)\n\n# By default, knitr saves loaded packages and reloads at the start of the\n# the new session. This doesn't work for our toy package because it is\n# deleted at the end of this Rmd. So we just hack knitr to not save or load\n# the package info\nassignInNamespace(\n  \"cache\", ns = \"knitr\",\n  modifyList(knitr:::cache, list(library = function(...) {}))\n)\n\n# do you want to see how this sausage is made?\ndebug <- FALSE\n\n# do we build the toy package? if so, where?\n# NA            --> no, don't build it\n# \"tmp_user\"    --> build in ~/tmp/TOYPACKAGE, so it's easy to access after\n# \"tmp_session\" --> build in session temp dir, it's disposable\nwhere <- \"tmp_session\"\n```\n\n*Spoiler alert!*\n\nThis chapter runs through the development of a small toy package.\nIt's meant to paint the Big Picture and suggest a workflow, before we descend into the detailed treatment of the key components of an R package.\n\nTo keep the pace brisk, we exploit the modern conveniences in the devtools package and the RStudio IDE. In later chapters, we are more explicit about what those helpers are doing for us.\n\nThis chapter is self-contained, in that completing the exercise is not a strict requirement to continue with the rest of the book, however we strongly suggest you follow along and create this toy package with us.\n\n## Load devtools and friends\n\nYou can initiate your new package from any active R session.\nYou don't need to worry about whether you're in an existing or new project or not.\nThe functions we use ensure that we create a new clean project for the package.\n\nLoad the devtools package, which is the public face of a set of packages that support various aspects of package development.\nThe most obvious of these is the usethis package, which you'll see is also being loaded.\n\n```{r}\nlibrary(devtools)\n```\n\nDo you have an old version of devtools?\nCompare your version against ours and upgrade if necessary.\n\n```{r}\npackageVersion(\"devtools\")\n```\n\n## Toy package: regexcite\n\nTo help walk you through the process, we use various functions from devtools to build a small toy package from scratch, with features commonly seen in released packages:\n\n-   Functions to address a specific need, in this case helpers for work with regular expressions.\n-   Version control and an open development process.\n    -   This is completely optional in your work, but highly recommended. You'll see how Git and GitHub help us expose all the intermediate stages of our toy package.\n-   Access to established workflows for installation, getting help, and checking quality.\n    -   Documentation for individual functions via [roxygen2](https://roxygen2.r-lib.org).\n    -   Unit testing with [testthat](https://testthat.r-lib.org).\n    -   Documentation for the package as a whole via an executable `README.Rmd`.\n\nWe call the package **regexcite** and it contains a couple of functions that make common tasks with regular expressions easier.\nPlease note that these functions are very simple and we're only using them here as a means to guide you through the package development process.\nIf you're looking for actual helpers for work with regular expressions, there are several proper R packages that address this problem space:\n\n-   [stringr](https://stringr.tidyverse.org) (which uses stringi)\n-   [stringi](https://stringi.gagolewski.com/)\n-   [rex](https://cran.r-project.org/package=rex)\n-   [rematch2](https://cran.r-project.org/package=rematch2)\n\nAgain, the regexcite package itself is just a device for demonstrating a typical workflow for package development with devtools.\n\n## Preview the finished product\n\nThe regexcite package is tracked during its development with the Git version control system.\nThis is purely optional and you can certainly follow along without implementing this.\nA nice side benefit is that we eventually connect it to a remote repository on GitHub, which means you can see the glorious result we are working towards by visiting regexcite on GitHub: <https://github.com/jennybc/regexcite>.\nBy inspecting the [commit history](https://github.com/jennybc/regexcite/commits/main) and especially the diffs, you can see exactly what changes at each step of the process laid out below.\n\n<!-- TODO: I think these diffs are extremely useful and would like to surface them better here. -->\n\n## `create_package()`\n\nCall `create_package()` to initialize a new package in a directory on your computer.\n`create_package()` will automatically create that directory if it doesn't exist yet (and that is usually the case).\nSee @sec-workflow101-create-package for more on creating packages.\n\nMake a deliberate choice about where to create this package on your computer.\nIt should probably be somewhere within your home directory, alongside your other R projects.\nIt should not be nested inside another RStudio Project, R package, or Git repo.\nNor should it be in an R package library, which holds packages that have already been built and installed.\nThe conversion of the source package we create here into an installed package is part of what devtools facilitates.\nDon't try to do devtools' job for it!\n\nOnce you've selected where to create this package, substitute your chosen path into a `create_package()` call like this:\n\n```{r create-package-fake, eval = FALSE}\ncreate_package(\"~/path/to/regexcite\")\n```\n\nFor the creation of this book we have to work in a temporary directory, because the book is built non-interactively in the cloud.\nBehind the scenes, we're executing our own `create_package()` command, but don't be surprised if our output differs a bit from yours.\n\n```{r configure, include = FALSE}\nwhere <- match.arg(\n  as.character(where),\n  choices = c(NA, \"tmp_user\", \"tmp_session\")\n)\ncreate <- !is.na(where)\n\nwhere <- switch(\n  where,\n  tmp_user = path_home(\"tmp\"),\n  tmp_session = path_temp(),\n  NULL\n)\n\npkgpath <- path(where, \"regexcite\")\n\nif (!is.null(where)) {\n  if (requireNamespace(\"regexcite\", quietly = TRUE)) {\n    remove.packages(\"regexcite\")\n    unloadNamespace(\"regexcite\")\n  }\n  if (dir_exists(pkgpath)) {\n    dir_delete(pkgpath)\n  }\n  dir_create(where)\n}\n```\n\n```{r create-package, eval = create, echo = debug}\nwithr::with_options(\n  list(usethis.description = NULL),\n  create_package(pkgpath, open = FALSE, rstudio = TRUE)\n)\n```\n\n```{r set-proj-and-wd, include = debug, eval = create}\n(owd <- getwd())\nlocal_project(pkgpath, setwd = TRUE)\ngetwd()\n\n# I normally am not this masochistic, but there is little choice\nknitr::opts_knit$set(root.dir = pkgpath)\n```\n\n```{r sitrep, include = debug, eval = create}\n# can't be in chunk above, because knitr\nproj_sitrep()\n```\n\nIf you're working in RStudio, you should find yourself in a new instance of RStudio, opened into your new regexcite package (and Project).\nIf you somehow need to do this manually, navigate to the directory and double click on `regexcite.Rproj`.\nRStudio has special handling for packages and you should now see a *Build* tab in the same pane as *Environment* and *History*.\n\nYou probably need to call `library(devtools)` again, because `create_package()` has probably dropped you into a fresh R session, in your new package.\n\n```{r eval = FALSE}\nlibrary(devtools)\n```\n\nWhat's in this new directory that is also an R package and, probably, an RStudio Project?\nHere's a listing (locally, you can consult your *Files* pane):\n\n```{r init-show-files, echo = FALSE, eval = create}\ndir_info(all = TRUE) %>% \n  select(path, type) %>%\n  knitr::kable()\n```\n\n::: callout-tip\n## RStudio\n\nIn the *Files* pane, go to *More (gear symbol) \\> Show Hidden Files* to toggle the visibility of hidden files (a.k.a. [\"dotfiles\"](https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory#Unix_and_Unix-like_environments)).\nA select few are visible all the time, but sometimes you want to see them all.\n:::\n\n-   `.Rbuildignore` lists files that we need to have around but that should not be included when building the R package from source. If you aren't using RStudio, `create_package()` may not create this file (nor `.gitignore`) at first, since there's no RStudio-related machinery that needs to be ignored. However, you will likely develop the need for `.Rbuildignore` at some point, regardless of what editor you are using. It is discussed in more detail in @sec-rbuildignore.\n-   `.Rproj.user`, if you have it, is a directory used internally by RStudio.\n-   `.gitignore` anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.\n-   `DESCRIPTION` provides metadata about your package. We edit this shortly and @sec-description covers the general topic of the `DESCRIPTION` file.\n-   `NAMESPACE` declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.\n-   The `R/` directory is the \"business end\" of your package. It will soon contain `.R` files with function definitions.\n-   `regexcite.Rproj` is the file that makes this directory an RStudio Project. Even if you don't use RStudio, this file is harmless. Or you can suppress its creation with `create_package(..., rstudio = FALSE)`. More in @sec-workflow101-rstudio-projects.\n\n## `use_git()`\n\nThe regexcite directory is an R source package and an RStudio Project.\nNow we make it also a Git repository, with `use_git()`.\n(By the way, `use_git()` works in any project, regardless of whether it's an R package.)\n\n```{r use-git, eval = create}\nuse_git()\n```\n\nIn an interactive session, you will be asked if you want to commit some files here and you should accept the offer.\nBehind the scenes, we'll also commit those same files.\n\n```{r gert-begin, eval = create, include = debug}\nsuppressPackageStartupMessages(library(gert))\ngit_add(\".\")\ngit_commit(\"Initial commit\")\n```\n\nSo what has changed in the package?\nOnly the creation of a `.git` directory, which is hidden in most contexts, including the RStudio file browser.\nIts existence is evidence that we have indeed initialized a Git repo here.\n\n```{r post-git-file-list, echo = FALSE, eval = create}\ndir_info(all = TRUE, regexp = \"^[.]git$\") %>% \n  select(path, type) %>%\n  knitr::kable()\n```\n\nIf you're using RStudio, it probably requested permission to relaunch itself in this Project, which you should do.\nYou can do so manually by quitting, then relaunching RStudio by double clicking on `regexcite.Rproj`.\nNow, in addition to package development support, you have access to a basic Git client in the *Git* tab of the *Environment/History/Build* pane.\n\n<!-- TODO: good place for a screenshot. -->\n\nClick on History (the clock icon in the Git pane) and, if you consented, you will see an initial commit made via `use_git()`:\n\n```{r inspect-first-commit, echo = FALSE, eval = create}\ngit_log(max = 1) %>% \n  select(commit, author, message) %>%\n  mutate(commit = paste0(substr(commit, 1, 10), \"...\")) %>%\n  knitr::kable()\n```\n\n::: callout-tip\n## RStudio\n\nRStudio can initialize a Git repository, in any Project, even if it's not an R package, as long you've set up RStudio + Git integration.\nDo *Tools \\> Version Control \\> Project Setup*.\nThen choose *Version control system: Git* and *initialize a new git repository for this project*.\n:::\n\n## Write the first function\n\nA fairly common task when dealing with strings is the need to split a single string into many parts.\nThe `strsplit()` function in base R does exactly this.\n\n```{r}\n(x <- \"alfa,bravo,charlie,delta\")\nstrsplit(x, split = \",\")\n```\n\nTake a close look at the return value.\n\n```{r}\nstr(strsplit(x, split = \",\"))\n```\n\nThe shape of this return value often surprises people or, at least, inconveniences them.\nThe input is a character vector of length one and the output is a list of length one.\nThis makes total sense in light of R's fundamental tendency towards vectorization.\nBut sometimes it's still a bit of a bummer.\nOften you know that your input is morally a scalar, i.e. it's just a single string, and really want the output to be the character vector of its parts.\n\nThis leads R users to employ various methods of \"unlist\"-ing the result:\n\n```{r}\nunlist(strsplit(x, split = \",\"))\n\nstrsplit(x, split = \",\")[[1]]\n```\n\nThe second, safer solution is the basis for the inaugural function of regexcite: `strsplit1()`.\n\n```{cat strsplit1-write, eval = create, class.source = \"r\"}\n#| engine.opts = list(file = path(\"R\", \"strsplit1.R\"))\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n```\n\nThis book does not teach you how to write functions in R.\nTo learn more about that take a look at the [Functions chapter](https://r4ds.hadley.nz/functions.html) of R for Data Science and the [Functions chapter](https://adv-r.hadley.nz/functions.html) of Advanced R.\n\n::: callout-tip\nThe name of `strsplit1()` is a nod to the very handy `paste0()`, which first appeared in R 2.15.0 in 2012.\n`paste0()` was created to address the extremely common use case of `paste()`-ing strings together *without* a separator.\n`paste0()` has been lovingly described as [\"statistical computing's most influential contribution of the 21st century\"](https://simplystatistics.org/posts/2013-01-31-paste0-is-statistical-computings-most-influential-contribution-of-the-21st-century/).\n\nThe `strsplit1()` function was so inspiring that it's now a real function in the stringr package: `stringr::str_split_1()`!\n:::\n\n## `use_r()`\n\nWhere should you put the definition of `strsplit1()`?\nSave it in a `.R` file, in the `R/` subdirectory of your package.\nA reasonable starting position is to make a new `.R` file for each user-facing function in your package and name the file after the function.\nAs you add more functions, you'll want to relax this and begin to group related functions together.\nWe'll save the definition of `strsplit1()` in the file `R/strsplit1.R`.\n\nThe helper `use_r()` creates and/or opens a script below `R/`.\nIt really shines in a more mature package, when navigating between `.R` files and the associated test file.\nBut, even here, it's useful to keep yourself from getting too carried away while working in `Untitled4`.\n\n```{r init-strsplit1, eval = create}\nuse_r(\"strsplit1\")\n```\n\nPut the definition of `strsplit1()` **and only the definition of `strsplit1()`** in `R/strsplit1.R` and save it.\nThe file `R/strsplit1.R` should NOT contain any of the other top-level code we have recently executed, such as the definition of our practice input `x`, `library(devtools)`, or `use_git()`.\nThis foreshadows an adjustment you'll need to make as you transition from writing R scripts to R packages.\nPackages and scripts use different mechanisms to declare their dependency on other packages and to store example or test code.\nWe explore this further in @sec-r.\n\n## `load_all()` {#sec-whole-game-load-all}\n\nHow do we test drive `strsplit1()`?\nIf this were a regular R script, we might use RStudio to send the function definition to the R Console and define `strsplit1()` in the global environment.\nOr maybe we'd call `source(\"R/strsplit1.R\")`.\nFor package development, however, devtools offers a more robust approach.\n\nCall `load_all()` to make `strsplit1()` available for experimentation.\n\n```{r load-all, eval = create}\nload_all()\n```\n\nNow call `strsplit1(x)` to see how it works.\n\n```{r, eval = create}\n(x <- \"alfa,bravo,charlie,delta\")\nstrsplit1(x, split = \",\")\n```\n\nNote that `load_all()` has made the `strsplit1()` function available, although it does not exist in the global environment.\n\n```{r, eval = create}\nexists(\"strsplit1\", where = globalenv(), inherits = FALSE)\n```\n\nIf you see `TRUE` instead of `FALSE`, that indicates you're still using a script-oriented workflow and sourcing your functions.\nHere's how to get back on track:\n\n-   Clean out the global environment and restart R.\n-   Re-attach devtools with `library(devtools)` and re-load regexcite with `load_all()`.\n-   Redefine the test input `x` and call `strsplit1(x, split = \",\")` again. This should work!\n-   Run `exists(\"strsplit1\", where = globalenv(), inherits = FALSE)` again and you should see `FALSE`.\n\n`load_all()` simulates the process of building, installing, and attaching the regexcite package.\nAs your package accumulates more functions, some exported, some not, some of which call each other, some of which call functions from packages you depend on, `load_all()` gives you a much more accurate sense of how the package is developing than test driving functions defined in the global environment.\nAlso `load_all()` allows much faster iteration than actually building, installing, and attaching the package.\nSee @sec-workflow101-load-all for more about `load_all()`.\n\nTo review what we've done so far:\n\n-   We wrote our first function, `strsplit1()`, to split a string into a character vector (not a list containing a character vector).\n-   We used `load_all()` to quickly make this function available for interactive use, as if we'd built and installed regexcite and attached it via `library(regexcite)`.\n\n::: callout-tip\n## RStudio\n\nRStudio exposes `load_all()` in the *Build* menu, in the *Build* pane via *More \\> Load All*, and in keyboard shortcuts Ctrl + Shift + L (Windows & Linux) or Cmd + Shift + L (macOS).\n:::\n\n### Commit `strsplit1()`\n\nIf you're using Git, use your preferred method to commit the new `R/strsplit1.R` file.\nWe do so behind the scenes here and here's the associated diff.\n\n```{r strsplit1-commit, eval = create, include = debug}\ngit_add(path(\"R\", \"strsplit1.R\"))\ngit_commit(\"Add strsplit1()\")\n## tags might be useful for making stable links to the package at specific\n## evolutionary stages\n## possible convention: tag name = chunk label\n#tag_name <- knitr::opts_current$get(\"label\")\n#tag(repo, tag_name, \"initial creation of strsplit1()\")\n#tag(repo, \"strsplit1-init\", \"initial creation of strsplit1()\")\n#sha <- (commits(repo)[[1]])@sha\n```\n\n```{r add-strsplit1-diff, echo = FALSE, eval = create, comment = \"\"}\ncat(git_diff_patch(ref = \"HEAD\"))\n```\n\nFrom this point on, we commit after each step.\nRemember [these commits](https://github.com/jennybc/regexcite/commits/main) are available in the public repository.\n\n## `check()`\n\nWe have informal, empirical evidence that `strsplit1()` works.\nBut how can we be sure that all the moving parts of the regexcite package still work?\nThis may seem silly to check, after such a small addition, but it's good to establish the habit of checking this often.\n\n`R CMD check`, executed in the shell, is the gold standard for checking that an R package is in full working order.\n`check()` is a convenient way to run this without leaving your R session.\n\nNote that `check()` produces rather voluminous output, optimized for interactive consumption.\nWe intercept that here and just reveal a summary.\nYour local `check()` output will be different.\n\n```{r first-check-fake, eval = FALSE}\ncheck()\n```\n\n```{r first-check, eval = create, warning = TRUE, echo = FALSE, comment = \"\"}\nshhh_check(error_on = \"never\")\n```\n\n*It is essential to actually read the output of the check!* Deal with problems early and often.\nIt's just like incremental development of `.R` and `.Rmd` files.\nThe longer you go between full checks that everything works, the harder it becomes to pinpoint and solve your problems.\n\nAt this point, we expect 1 warning (and 0 errors, 0 notes):\n\n```         \nNon-standard license specification:\n  `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n  license\n```\n\nWe'll address that soon, by doing exactly what it says.\nYou can learn more about `check()` in @sec-workflow101-r-cmd-check.\n\n::: callout-tip\n## RStudio\n\nRStudio exposes `check()` in the *Build* menu, in the *Build* pane via *Check*, and in keyboard shortcuts Ctrl + Shift + E (Windows & Linux) or Cmd + Shift + E (macOS).\n:::\n\n## Edit `DESCRIPTION`\n\nThe `DESCRIPTION` file provides metadata about your package and is covered fully in @sec-description.\nThis is a good time to have a look at regexcite's current `DESCRIPTION`.\nYou'll see it's populated with boilerplate content, which needs to be replaced.\n\nTo add your own metadata, make these edits:\n\n-   Make yourself the author. If you don't have an ORCID, you can omit the `comment = ...` portion.\n-   Write some descriptive text in the `Title` and `Description` fields.\n\n::: callout-tip\n## RStudio\n\nUse Ctrl + `.` in RStudio and start typing \"DESCRIPTION\" to activate a helper that makes it easy to open a file for editing.\nIn addition to a filename, your hint can be a function name.\nThis is very handy once a package has lots of files.\n:::\n\nWhen you're done, `DESCRIPTION` should look similar to this:\n\n<!-- I'm trying to avoid any syntax highlighting here, while also not trying to do things in a way that's acceptable to O'Reilly who wants \"text\". -->\n\n```{cat DESCRIPTION-write, eval = create, class.source = \"text\"}\n#| engine.opts = list(file = \"DESCRIPTION\")\nPackage: regexcite\nTitle: Make Regular Expressions More Exciting\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"Jane\", \"Doe\", , \"jane@example.com\", role = c(\"aut\", \"cre\"))\nDescription: Convenience functions to make some common tasks with string\n    manipulation and regular expressions a bit easier.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.2\n```\n\n```{r commit-description, eval = create, include = debug}\ngit_add(\"DESCRIPTION\")\ngit_commit(\"Edit DESCRIPTION\")\n```\n\n## `use_mit_license()`\n\n> [Pick a License, Any License. -- Jeff Atwood](https://blog.codinghorror.com/pick-a-license-any-license/)\n\nWe currently have a placeholder in the `License` field of `DESCRIPTION` that's deliberately invalid and suggests a resolution.\n\n```         \nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n```\n\nTo configure a valid license for the package, call `use_mit_license()`.\n\n```{r use-mit-license, eval = create}\nuse_mit_license()\n```\n\nThis configures the `License` field correctly for the MIT license, which promises to name the copyright holders and year in a `LICENSE` file.\nOpen the newly created `LICENSE` file and confirm it looks something like this:\n\n```{r reveal-LICENSE, eval = create, echo = FALSE, comment = \"\"}\nwriteLines(readLines(\"LICENSE\"))\n```\n\nLike other license helpers, `use_mit_license()` also puts a copy of the full license in `LICENSE.md` and adds this file to `.Rbuildignore`.\nIt's considered a best practice to include a full license in your package's source, such as on GitHub, but CRAN disallows the inclusion of this file in a package tarball.\nYou can learn more about licensing in @sec-license.\n\n```{r commit-license, eval = create, include = debug}\ngit_add(c(\".Rbuildignore\", \"DESCRIPTION\", \"LICENSE\", \"LICENSE.md\"))\ngit_commit(\"Use MIT license\")\n```\n\n## `document()` {#sec-whole-game-document}\n\nWouldn't it be nice to get help on `strsplit1()`, just like we do with other R functions?\nThis requires that your package have a special R documentation file, `man/strsplit1.Rd`, written in an R-specific markup language that is sort of like LaTeX.\nLuckily we don't necessarily have to author that directly.\n\nWe write a specially formatted comment right above `strsplit1()`, in its source file, and then let a package called [roxygen2](https://roxygen2.r-lib.org) handle the creation of `man/strsplit1.Rd`.\nThe motivation and mechanics of roxygen2 are covered in @sec-man.\n\nIf you use RStudio, open `R/strsplit1.R` in the source editor and put the cursor somewhere in the `strsplit1()` function definition.\nNow do *Code \\> Insert roxygen skeleton*.\nA very special comment should appear above your function, in which each line begins with `#'`.\nRStudio only inserts a barebones template, so you will need to edit it to look something like that below.\n\nIf you don't use RStudio, create the comment yourself.\nRegardless, you should modify it to look something like this:\n\n```{cat strsplit1-with-roxygen-write, eval = create, class.source = \"r\"}\n#| engine.opts = list(file = path(\"R\", \"strsplit1.R\"))\n#' Split a string\n#'\n#' @param x A character vector with one element.\n#' @param split What to split on.\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' strsplit1(x, split = \",\")\nstrsplit1 <- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n```\n\n<!-- TODO: mention how RStudio helps you execute examples here? -->\n\n```{r commit-strsplit1-roxygen-header, eval = create, include = debug}\ngit_add(path(\"R\", \"strsplit1.R\"))\ngit_commit(\"Add roxygen header to document strsplit1()\")\n```\n\nBut we're not done yet!\nWe still need to trigger the conversion of this new roxygen comment into `man/strsplit1.Rd` with `document()`:\n\n```{r document-strsplit1, eval = create}\ndocument()\n```\n\n::: callout-tip\n## RStudio\n\nRStudio exposes `document()` in the *Build* menu, in the *Build* pane via *More \\> Document*, and in keyboard shortcuts Ctrl + Shift + D (Windows & Linux) or Cmd + Shift + D (macOS).\n:::\n\nYou should now be able to preview your help file like so:\n\n```{r eval = FALSE}\n?strsplit1\n```\n\nYou'll see a message like \"Rendering development documentation for 'strsplit1'\", which reminds that you are basically previewing draft documentation.\nThat is, this documentation is present in your package's source, but is not yet present in an installed package.\nIn fact, we haven't installed regexcite yet, but we will soon.\nIf `?strsplit1` doesn't work for you, you may need to call `load_all()` first, then try again.\n\nNote also that your package's documentation won't be properly wired up until it has been formally built and installed.\nThis polishes off niceties like the links between help files and the creation of a package index.\n\n### `NAMESPACE` changes\n\nIn addition to converting `strsplit1()`'s special comment into `man/strsplit1.Rd`, the call to `document()` updates the `NAMESPACE` file, based on `@export` tags found in roxygen comments.\nOpen `NAMESPACE` for inspection.\nThe contents should be:\n\n<!-- OK to use this approach here because I actively do not want a copy button. NAMESPACE should be managed by roxygen and I don't want to tempt anyone to edit it by hand. -->\n\n```{r asis = TRUE, echo = FALSE, comment = \"\", eval = create}\ncat(readLines(\"NAMESPACE\"), sep = \"\\n\")\n```\n\nThe export directive in `NAMESPACE` is what makes `strsplit1()` available to a user after attaching regexcite via `library(regexcite)`.\nJust as it is entirely possible to author `.Rd` files \"by hand\", you can manage `NAMESPACE` explicitly yourself.\nBut we choose to delegate this to devtools (and roxygen2).\n\n```{r commit-namespace, eval = create, include = debug}\ngit_add(c(\"NAMESPACE\", path(\"man\", \"strsplit1.Rd\")))\ngit_commit(\"Run document()\")\n```\n\n## `check()` again\n\nregexcite should pass `R CMD check` cleanly now and forever more: 0 errors, 0 warnings, 0 notes.\n\n```{r first-clean-check-fake, eval = FALSE}\ncheck()\n```\n\n```{r first-clean-check, eval = create, warning = TRUE, echo = FALSE, comment = \"\"}\nshhh_check(error_on = \"never\")\n```\n\n## `install()`\n\nNow that we know we have a minimum viable product, let's install the regexcite package into your library via `install()`:\n\n```{r first-install-fake, eval = FALSE}\ninstall()\n```\n\n```{r first-install, eval = create, echo = FALSE, comment = \"\"}\ncat(pretty_install(), sep = \"\\n\")\n```\n\n::: callout-tip\n## RStudio\n\nRStudio exposes similar functionality in the *Build* menu and in the *Build* pane via *Install and Restart*, and in keyboard shortcuts Ctrl + Shift + B (Windows & Linux) or Cmd + Shift + B (macOS).\n:::\n\nAfter installation is complete, we can attach and use regexcite like any other package.\nLet's revisit our small example from the top.\nThis is also a good time to restart your R session and ensure you have a clean workspace.\n\n```{r, eval = create}\nlibrary(regexcite)\n\nx <- \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n```\n\nSuccess!\n\n## `use_testthat()`\n\nWe've tested `strsplit1()` informally, in a single example.\nWe can formalize this as a unit test.\nThis means we express a concrete expectation about the correct `strsplit1()` result for a specific input.\n\nFirst, we declare our intent to write unit tests and to use the testthat package for this, via `use_testthat()`:\n\n```{r use-testthat, eval = create}\nuse_testthat()\n```\n\nThis initializes the unit testing machinery for your package.\nIt adds `Suggests: testthat` to `DESCRIPTION`, creates the directory `tests/testthat/`, and adds the script `tests/testthat.R`.\nYou'll notice that testthat is probably added with a minimum version of 3.0.0 and a second DESCRIPTION field, `Config/testthat/edition: 3`.\nWe'll talk more about those details in @sec-testing-basics.\n\n```{r commit-testthat-init, eval = create, include = debug}\ngit_add(c(\"DESCRIPTION\", path(\"tests\", \"testthat.R\")))\ngit_commit(\"Add testing infrastructure\")\n```\n\nHowever, it's still up to YOU to write the actual tests!\n\nThe helper `use_test()` opens and/or creates a test file.\nYou can provide the file's basename or, if you are editing the relevant source file in RStudio, it will be automatically generated.\nFor many of you, if `R/strsplit1.R` is the active file in RStudio, you can just call `use_test()`.\nHowever, since this book is built non-interactively, we must provide the basename explicitly:\n\n```{r test-strsplit1, eval = create}\nuse_test(\"strsplit1\")\n```\n\nThis creates the file `tests/testthat/test-strsplit1.R`.\nIf it had already existed, `use_test()` would have just opened it.\nYou will notice that there is an example test in the newly created file - delete that code and replace it with this content:\n\n```{r include = debug, eval = create}\ntest_path <- path(\"tests\", \"testthat\", \"test-strsplit1.R\")\n```\n\n```{cat strsplit1-test-write, eval = create, class.source = \"r\"}\n#| engine.opts = list(file = test_path)\ntest_that(\"strsplit1() splits a string\", {\n  expect_equal(strsplit1(\"a,b,c\", split = \",\"), c(\"a\", \"b\", \"c\"))\n})\n```\n\nThis tests that `strsplit1()` gives the expected result when splitting a string.\n\n```{r commit-strsplit1-test, eval = create, include = debug}\ngit_add(test_path)\ngit_commit(\"Test strsplit1()\")\n```\n\nRun this test interactively, as you will when you write your own.\nIf `test_that()` or `strsplit1()` can't be found, that suggests that you probably need to call `load_all()`.\n\nGoing forward, your tests will mostly run *en masse* and at arm's length via `test()`:\n\n<!-- TODO: I have no idea why I have to disable crayon here, but if I don't, I guess raw ANSI escapes. Other chunks seem to work fine with downlig. It would also be nice to not see evidence of progress reporting, but the previous approach to turning that off keeps this chunk from showing any output at all :( The previous approach was `R.options = list(testthat.default_reporter = testthat::ProgressReporter$new(update_interval = Inf))`. -->\n\n```{r, include = FALSE}\nlibrary(testthat) # suppress package loading messages\n```\n\n```{r eval = create, R.options = list(crayon.enabled = FALSE)}\ntest()\n```\n\n::: callout-tip\n## RStudio\n\nRStudio exposes `test()` in the *Build* menu, in the *Build* pane via *More \\> Test package*, and in keyboard shortcuts Ctrl + Shift + T (Windows & Linux) or Cmd + Shift + T (macOS).\n:::\n\nYour tests are also run whenever you `check()` the package.\nIn this way, you basically augment the standard checks with some of your own, that are specific to your package.\nIt is a good idea to use the [covr package](https://covr.r-lib.org) to track what proportion of your package's source code is exercised by the tests.\nMore details can be found in @sec-testing-basics.\n\n## `use_package()`\n\nYou will inevitably want to use a function from another package in your own package.\nWe will need to use package-specific methods for declaring the other packages we need (i.e. our dependencies) and for using these packages in ours.\nIf you plan to submit a package to CRAN, note that this even applies to functions in packages that you think of as \"always available\", such as `stats::median()` or `utils::head()`.\n\nOne common dilemma when using R's regular expression functions is uncertainty about whether to request `perl = TRUE` or `perl = FALSE`.\nAnd then there are often, but not always, other arguments that alter how patterns are matched, such as `fixed`, `ignore.case`, and `invert`.\nIt can be hard to keep track of which functions use which arguments and how the arguments interact, so many users never get to the point where they retain these details without rereading the docs.\n\nThe stringr package \"provides a cohesive set of functions designed to make working with strings as easy as possible\".\nIn particular, stringr uses one regular expression system everywhere (ICU regular expressions) and uses the same interface in every function for controlling matching behaviors, such as case sensitivity.\nSome people find this easier to internalize and program around.\nLet's imagine you decide you'd rather build regexcite based on stringr (and stringi) than base R's regular expression functions.\n\nFirst, declare your general intent to use some functions from the stringr namespace with `use_package()`:\n\n```{r use-stringr, eval = create}\nuse_package(\"stringr\")\n```\n\nThis adds the stringr package to the `Imports` field of `DESCRIPTION`.\nAnd that is all it does.\n\n```{r commit-stringr-imports, eval = create, include = debug}\ngit_add(\"DESCRIPTION\")\ngit_commit(\"Import stringr\")\n```\n\nLet's revisit `strsplit1()` to make it more stringr-like.\nHere's a new take on it[^whole-game-1]:\n\n[^whole-game-1]: Recall that this example was so inspiring that it's now a real function in the stringr package: \\`stringr::str_split_1()\\`!\n\n```{r str-split-one-sneak-peek, eval = FALSE}\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n```\n\nNotice that we:\n\n-   Rename the function to `str_split_one()`, to signal that that is a wrapper around `stringr::str_split()`.\n-   Adopt the argument names from `stringr::str_split()`. Now we have `string` and `pattern` (and `n`), instead of `x` and `split`.\n-   Introduce a bit of argument checking and edge case handling. This is unrelated to the switch to stringr and would be equally beneficial in the version built on `strsplit()`.\n-   Use the `package::function()` form when calling `stringr::str_split()`. This specifies that we want to call the `str_split()` function from the stringr namespace. There is more than one way to call a function from another package and the one we endorse here is explained fully in @sec-dependencies-in-practice.\n\nWhere should we write this new function definition?\nIf we want to keep following the convention where we name the `.R` file after the function it defines, we now need to do some fiddly file shuffling.\nBecause this comes up fairly often in real life, we have the `rename_files()` function, which choreographs the renaming of a file in `R/` and its associated companion files below `test/`.\n\n```{r}\nrename_files(\"strsplit1\", \"str_split_one\")\n```\n\nRemember: the file name work is purely aspirational.\nWe still need to update the contents of these files!\n\nHere are the updated contents of `R/str_split_one.R`.\nIn addition to changing the function definition, we've also updated the roxygen header to reflect the new arguments and to include examples that show off the stringr features.\n\n```{cat str-split-one-write, eval = create, class.source = \"r\"}\n#| engine.opts = list(file = path(\"R\", \"str_split_one.R\"))\n#' Split a string\n#'\n#' @param string A character vector with, at most, one element.\n#' @inheritParams stringr::str_split\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x <- \"alfa,bravo,charlie,delta\"\n#' str_split_one(x, pattern = \",\")\n#' str_split_one(x, pattern = \",\", n = 2)\n#'\n#' y <- \"192.168.0.1\"\n#' str_split_one(y, pattern = stringr::fixed(\".\"))\nstr_split_one <- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) <= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n```\n\nDon't forget to also update the test file!\n\nHere are the updated contents of `tests/testthat/test-str_split_one.R`.\nIn addition to the change in the function's name and arguments, we've added a couple more tests.\n\n```{cat str-split-one-test-write, eval = create, class.source = \"r\"}\n#| engine.opts = list(file = path(\"tests\", \"testthat\", \"test-str_split_one.R\"))\ntest_that(\"str_split_one() splits a string\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\"), c(\"a\", \"b\", \"c\"))\n})\n\ntest_that(\"str_split_one() errors if input length > 1\", {\n  expect_error(str_split_one(c(\"a,b\",\"c,d\"), \",\"))\n})\n\ntest_that(\"str_split_one() exposes features of stringr::str_split()\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\", n = 2), c(\"a\", \"b,c\"))\n  expect_equal(str_split_one(\"a.b\", stringr::fixed(\".\")), c(\"a\", \"b\"))\n})\n```\n\nBefore we take the new `str_split_one()` out for a test drive, we need to call `document()`.\nWhy?\nRemember that `document()` does two main jobs:\n\n1.  Converts our roxygen comments into proper R documentation.\n2.  (Re)generates `NAMESPACE`.\n\nThe second job is especially important here, since we will no longer export `strsplit1()` and we will newly export `str_split_one()`.\nDon't be dismayed by the warning about `\"Objects listed as exports, but not present in namespace: strsplit1\"`.\nThat always happens when you remove something from the namespace.\n\n```{r document-str-split-one, eval = create}\ndocument()\n```\n\nTry out the new `str_split_one()` function by simulating package installation via `load_all()`:\n\n```{r str-split-one-test-drive, eval = create}\nload_all()\nstr_split_one(\"a, b, c\", pattern = \", \")\n```\n\n```{r commit-str-split-one, eval = create, include = debug}\ngit_add(c(\n  \"NAMESPACE\",\n  path(\"man\", c(\"str_split_one.Rd\", \"strsplit1.Rd\")),\n  path(\"R\", c(\"str_split_one.R\", \"strsplit1.R\")),\n  path(\"tests\", \"testthat\", c(\"test-str_split_one.R\", \"test-strsplit1.R\"))\n))\ngit_commit(\"Switch to str_split_one()\")\n```\n\n## `use_github()`\n\nYou've seen us making commits during the development process for regexcite.\nYou can see an indicative history at <https://github.com/jennybc/regexcite>.\nOur use of version control and the decision to expose the development process means you can inspect the state of the regexcite source at each developmental stage.\nBy looking at so-called diffs, you can see exactly how each devtools helper function modifies the source files that constitute the regexcite package.\n\nHow would you connect your local regexcite package and Git repository to a companion repository on GitHub?\nHere are three approaches:\n\n1.  [`use_github()`](https://usethis.r-lib.org/reference/use_github.html) is a helper that we recommend for the long-term. We won't demonstrate it here because it requires some credential setup on your end. We also don't want to tear down and rebuild the public regexcite package every time we build this book.\n2.  Set up the GitHub repo first! It sounds counter-intuitive, but the easiest way to get your work onto GitHub is to initiate there, then use RStudio to start working in a synced local copy. This approach is described in Happy Git's workflows [New project, GitHub first](https://happygitwithr.com/new-github-first.html) and [Existing project, GitHub first](https://happygitwithr.com/existing-github-first.html).\n3.  Command line Git can always be used to add a remote repository *post hoc*. This is described in the Happy Git workflow [Existing project, GitHub last](https://happygitwithr.com/existing-github-last.html).\n\nAny of these approaches will connect your local regexcite project to a GitHub repo, public or private, which you can push to or pull from using the Git client built into RStudio.\nIn @sec-sw-dev-practices, we elaborate on why version control (e.g., Git) and, specifically, hosted version control (e.g. GitHub) is worth incorporating into your package development process.\n\n## `use_readme_rmd()`\n\nNow that your package is on GitHub, the `README.md` file matters.\nIt is the package's home page and welcome mat, at least until you decide to give it a website (see @sec-website), add a vignette (see @sec-vignettes), or submit it to CRAN (see @sec-release).\n\nThe `use_readme_rmd()` function initializes a basic, executable `README.Rmd` ready for you to edit:\n\n```{r use-readme-rmd, eval = create}\nuse_readme_rmd()\n```\n\nIn addition to creating `README.Rmd`, this adds some lines to `.Rbuildignore`, and creates a Git pre-commit hook to help you keep `README.Rmd` and `README.md` in sync.\n\n`README.Rmd` already has sections that prompt you to:\n\n-   Describe the purpose of the package.\n-   Provide installation instructions. If a GitHub remote is detected when `use_readme_rmd()` is called, this section is pre-filled with instructions on how to install from GitHub.\n-   Show a bit of usage.\n\nHow to populate this skeleton?\nCopy stuff liberally from `DESCRIPTION` and any formal and informal tests or examples you have.\nAnything is better than nothing.\nThis is helpful because people probably won't install your package and comb through individual help files to figure out how to use it.\n\nWe like to write the `README` in R Markdown, so it can feature actual usage.\nThe inclusion of live code also makes it less likely that your `README` grows stale and out-of-sync with your actual package.\n\nTo make your own edits, if RStudio has not already done so, open `README.Rmd` for editing.\nMake sure it shows some usage of `str_split_one()`.\n\nThe `README.Rmd` we use is here: [README.Rmd](https://github.com/jennybc/regexcite/blob/main/README.Rmd) and here's what it contains:\n\n```{r copy-readme-rmd, include = debug, eval = create}\nfile_copy(\n  path(owd, \"fixtures\", \"regexcite-README.Rmd\"),\n  \"README.Rmd\",\n  overwrite = TRUE\n)\n```\n\n```{r reveal-README, eval = create, echo = FALSE, comment = \"\"}\nwriteLines(readLines(\"README.Rmd\"))\n```\n\nDon't forget to render it to make `README.md`!\nThe pre-commit hook should remind you if you try to commit `README.Rmd`, but not `README.md`, and also when `README.md` appears to be out-of-date.\n\nThe very best way to render `README.Rmd` is with `build_readme()`, because it takes care to render with the most current version of your package, i.e. it installs a temporary copy from the current source.\n\n```{r readme-render, eval = create}\nbuild_readme()\n```\n\nYou can see the rendered `README.md` simply by [visiting regexcite on GitHub](https://github.com/jennybc/regexcite#readme).\n\nFinally, don't forget to do one last commit.\nAnd push, if you're using GitHub.\n\n```{r commit-rendered-readme, eval = create, include = debug}\ngit_add(c(\".Rbuildignore\", \"README.Rmd\", \"README.md\"))\ngit_commit(\"Write README.Rmd and render\")\n```\n\n```{r final-push, include = FALSE, eval = FALSE}\n# execute manually if you want to update the regexcite repo on github\n# pre-requisite:\n#   render of this with no existing cache and `where <- \"tmp_user\"`\nlibrary(gert)\ngit_remote_add(\"https://github.com/jennybc/regexcite.git\")\ngit_push(force = TRUE)\n```\n\n## The end: `check()` and `install()`\n\nLet's run `check()` again to make sure all is still well.\n\n```{r final-check-fake, eval = FALSE}\ncheck()\n```\n\n```{r final-check, eval = create, warning = TRUE, echo = FALSE, comment = \"\"}\nshhh_check(error_on = \"never\")\n```\n\nregexcite should have no errors, warnings or notes.\nThis would be a good time to re-build and install it properly.\nAnd celebrate!\n\n```{r final-install-fake, eval = FALSE}\ninstall()\n```\n\n```{r final-install, eval = create, echo = FALSE, comment = \"\"}\ncat(pretty_install(reload = FALSE, upgrade = FALSE), sep = \"\\n\")\n```\n\nFeel free to visit the [regexcite package](https://github.com/jennybc/regexcite) on GitHub, which appears exactly as developed here.\nThe commit history reflects each individual step, so use the diffs to see the addition and modification of files, as the package evolved.\nThe rest of this book goes in greater detail for each step you've seen here and much more.\n\n```{r cleanup, include = debug, eval = create}\npkgload::unload(\"regexcite\")\nremove.packages(\"regexcite\")\n\n# being kind to someone working interactively and locally\nif (is.null(getOption(\"knitr.in.progress\"))) {\n  withr::deferred_run()\n}\n\nknitr::opts_knit$set(root.dir = owd)\n```\n\n```{r cleanup-confirm, include = debug, eval = create}\ngetwd()\n```\n\n## Review\n\nThis chapter is meant to give you a sense of the typical package development workflow, summarized as a diagram in @fig-package-dev-workflow.\nEverything you see here has been touched on in this chapter, with the exception of GitHub Actions, which you will learn more about in @sec-sw-dev-practices-gha.\n\n```{r}\n#| label: fig-package-dev-workflow\n#| echo: false\n#| out-width: ~\n#| fig-cap: >\n#|   The devtools package development workflow.\n#| fig-alt: > \n#|   Diagram featuring 4 key functions in the devtools workflow: load_all(),\n#|   test(), document(), and check().\n#|   Each is part of one or more loops indicated by arrows, depicting the\n#|   typical process of editing code or tests or documentation, then test\n#|   driving that code, running tests, or previewing documentation.\n#|   check() connects externally to `git commit`, `git push`, and GitHub\n#|   Actions.\nknitr::include_graphics(\"diagrams/workflow.png\")\n```\n\nHere is a review of the key functions you've seen in this chapter, organized roughly by their role in the development process.\n\nThese functions setup parts of the package and are typically called once per package:\n\n-   `create_package()`\n-   `use_git()`\n-   `use_mit_license()`\n-   `use_testthat()`\n-   `use_github()`\n-   `use_readme_rmd()`\n\nYou will call these functions on a regular basis, as you add functions and tests or take on dependencies:\n\n-   `use_r()`\n-   `use_test()`\n-   `use_package()`\n\nYou will call these functions multiple times per day or per hour, during development:\n\n-   `load_all()`\n-   `document()`\n-   `test()`\n-   `check()`\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":["plausible.html"],"output-file":"whole-game.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.475","bibliography":["book.bib"],"editor":"source","mainfont":"Microsoft Yahei","theme":["cosmo","custom.scss"]},"extensions":{"book":{"multiFile":true}}}}}